<!DOCTYPE html>

<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Beslenme Planlayıcı</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<style>
        :root{--primary-color:#007BFF;--primary-hover:#0056b3;--success-color:#28A745;--success-hover:#218838;--danger-color:#DC3545;--danger-hover:#C82333;--secondary-color:#6C757D;--secondary-hover:#5A6268;--background-color:#F8F9FA;--white:#FFFFFF;--gray-light:#E9ECEF;--gray-border:#DEE2E6;--text-dark:#212529;--text-light:#FFFFFF;--shadow:0 2px 4px rgba(0,0,0,0.1);--shadow-lg:0 4px 8px rgba(0,0,0,0.2);}
body{font-family:'Segoe UI',Arial,sans-serif;background-color:var(--background-color);margin:0;padding:0;overflow:hidden;}
.navbar{background-color:var(--primary-color)!important;padding:0.5rem 1rem;}
.navbar-brand,.nav-link{color:var(--text-light)!important;font-size:0.9rem;}
.nav-link:hover{color:#E7F1FF!important;}
.main-container{display:flex;height:calc(100vh - 56px);overflow:hidden;}
.sidebar{width:250px;height:100%;overflow-y:auto;background-color:var(--white);border-right:1px solid var(--gray-border);transition:width 0.3s;display:flex;flex-direction:column;}
.sidebar-header{padding:10px;border-bottom:1px solid var(--gray-border);}
.sidebar-content{flex:1;overflow-y:auto;padding:10px;}
.resizer {
  width: 8px; /* Biraz daha kalın, tutması kolay */
  background-color: #dee2e6; /* Gri ton, daha görünür */
  cursor: ew-resize; /* Yatay resize simgesi */
  transition: background-color 0.2s; /* Hover efekti için */
}

.resizer:hover {
  background-color: #adb5bd; /* Hover'da koyulaşsın */
}
.main-content{flex:1;height:100%;overflow-y:auto;background-color:var(--background-color);padding:10px;}
.accordion-button{background-color:var(--primary-color);color:var(--text-light);box-shadow:none;font-size:0.9rem;padding:0.5rem;}
.accordion-button.green{background-color:var(--success-color);}
.accordion-button.green:not(.collapsed){background-color:var(--success-hover);}
.accordion-button:not(.collapsed){background-color:var(--primary-hover);}
.accordion-button:hover{background-color:var(--primary-hover);}
.category-item{padding:5px;margin-bottom:3px;border-radius:4px;background-color:var(--white);border:1px solid var(--gray-border);font-size:0.85rem;display:flex;align-items:center;justify-content:space-between;}
.category-item:hover{background-color:var(--gray-light);}
.meal-card{margin-bottom:10px;box-shadow:var(--shadow);background-color:var(--white);cursor:pointer;}
.meal-card .card-header{background-color:var(--primary-color);color:var(--text-light);padding:0.5rem;font-size:0.9rem;display:flex;justify-content:space-between;align-items:center;}
.meal-table th:nth-child(2),.meal-table td:nth-child(2){min-width:120px;text-align:left;}
.macro-display{display:flex;align-items:stretch;margin-top:15px;background-color:var(--white);padding:10px;}
#macroTotals{flex:1;margin-right:20px;}
.macro-charts{display:flex;align-items:center;}
.chart-container{text-align:center;margin-right:20px;}
.chart-container:last-child{margin-right:0;}
.chart-container h4{margin-bottom:10px;font-size:14px;}
.chart-container canvas{display:block;}
.macro-table th{background-color:var(--gray-light);font-size:0.85rem;padding:0.3rem;}
.macro-exceed{background-color:#ffcccc;}
.macro-low{background-color:#cce5ff;}
.btn{font-size:0.85rem;padding:0.3rem 0.6rem;}
.btn-primary{background-color:var(--primary-color);border-color:var(--primary-color);}
.btn-primary:hover{background-color:var(--primary-hover);}
.btn-success{background-color:var(--success-color);border-color:var(--success-color);}
.btn-success:hover{background-color:var(--success-hover);}
.btn-danger{background-color:var(--danger-color);border-color:var(--danger-color);}
.btn-danger:hover{background-color:var(--danger-hover);}
.btn-remove-from-meal {
    background-color: #28a745 !important; /* Yeşil ton */
    border-color: #28a745 !important;
    color: white;
}
.btn-remove-from-meal:hover {
    background-color: #218838 !important; /* Hover'da daha koyu yeşil */
    border-color: #218838 !important;
}
.meal-search-input {
    font-size: 0.9rem;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    border: 1px solid var(--gray-border);
    transition: box-shadow 0.2s, border-color 0.2s;
    width: 100%;
    max-width: 250px;
    min-width: 150px;
}

.meal-search-input:focus {
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    border-color: var(--primary-color);
    outline: none;
}

@media (max-width: 768px) {
    .meal-search-input {
        max-width: 200px;
        min-width: 120px;
    }
}

.search-results {
    box-shadow: var(--shadow-lg); /* Daha belirgin gölge */
    background-color: var(--white);
    border-radius: 6px; /* Yuvarlak köşeler */
    overflow: hidden; /* Köşelerde taşmayı önler */
}

.search-result-item {
    padding: 0.6rem 1rem; /* Daha geniş padding */
    font-size: 0.9rem; /* Okunabilir font */
    color: var(--text-dark); /* Koyu yazı rengi */
    border-bottom: 1px solid var(--gray-light);
    transition: background-color 0.2s ease; /* Yumuşak geçiş */
    display: flex; /* İkon ve metni hizalamak için */
    align-items: center;
    cursor: pointer;
}

.search-result-item:hover {
    background-color: #e9ecef; /* Daha yumuşak hover rengi */
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item::before {
    content: "\1F37D"; /* Unicode: Yemek tabağı emojisi */
    margin-right: 0.5rem; /* İkon ile metin arası boşluk */
    font-size: 1rem;
}

.search-result-empty {
    padding: 0.6rem 1rem;
    font-size: 0.9rem;
    color: var(--text-dark);
    font-style: italic;
}
.search-result-item {
    padding: 0.6rem 1rem;
    font-size: 0.9rem;
    color: var(--text-dark);
    border-bottom: 1px solid var(--gray-light);
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    cursor: pointer;
}

.search-result-item:hover {
    background-color: #e9ecef;
    font-weight: 500; /* Hover'da hafif kalın font */
}

.edit-food-panel {
    position: fixed;
    top: 10%;
    left: 50%;
    transform: translateX(-50%);
    width: 1000px;
    min-width: 1000px;
    background-color: var(--white);
    border: 1px solid var(--gray-border);
    padding: 20px;
    z-index: 1000;
    box-shadow: var(--shadow-lg);
    max-height: 65vh;
    overflow-y: auto;
    overflow-x: hidden;
    border-radius: 10px;
    box-sizing: border-box;
}
.edit-food-panel h5 {
    margin: 0 0 15px 0;
    font-size: 1.2rem;
    font-weight: 500;
}
.edit-food-panel .form-control-sm,
.edit-food-panel .form-select-sm {
    padding: 0.35rem 0.7rem;
    font-size: 0.9rem;
    border-radius: 5px;
    width: 100%;
    max-width: 100%;
}
.edit-food-panel .wide-input {
    width: 100%;
    min-width: 350px;
    max-width: 100%;
}
.edit-food-panel .form-label {
    font-size: 0.9rem;
    white-space: nowrap;
    color: var(--text-dark);
}
.edit-food-panel .form-check {
    margin-right: 1.5rem;
}
.edit-food-panel .form-check-input {
    margin-right: 0.5rem;
}
.edit-food-panel .btn {
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    border-radius: 5px;
}
.edit-food-panel .row {
    margin-bottom: 0.8rem;
}
.edit-food-panel .d-flex.gap-3 {
    display: flex;
    gap: 1.5rem;
    align-items: center;
}
@media (max-width: 1366px) {
    .edit-food-panel {
        width: 90%;
        max-height: 75vh;
        padding: 15px;
    }
    .edit-food-panel .col-3 {
        width: 35%;
    }
    .edit-food-panel .col-9 {
        width: 65%;
    }
    .edit-food-panel .wide-input {
        min-width: 250px;
    }
}
.close-btn {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    color: #333;
}

.close-btn:hover {
    color: #000;
}
.meal-table th:first-child, .meal-table td:first-child {
    width: 80px; /* Kural sütunu için sabit genişlik */
    text-align: center;
}
.meal-table th, .meal-table td {
    padding: 8px;
    text-align: center;
}
#ruleTextElement {
    font-size: 0.85rem;
    line-height: 1.5;
    margin-top: 10px;
    padding: 10px;
    background-color: var(--gray-light);
    border-radius: 5px;
}
#ruleTextElement strong {
    color: var(--text-dark);
}
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    justify-content: center;
    align-items: center;
}
.modal-content {
    background-color: var(--white);
    padding: 20px;
    border-radius: 10px;
    max-width: 500px;
    width: 90%;
    margin: auto;
    position: relative;
    top: 20%;
    box-shadow: var(--shadow-lg);
}
.modal-close {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 24px;
    cursor: pointer;
    color: #333;
}
.modal-close:hover {
    color: #000;
}
.noUi-target {
    margin: 10px 0;
    width: 100%;
    max-width: 300px; /* Slider genişliğini sınırlayın */
}
.noUi-connect {
    background: var(--primary-color);
}
.noUi-handle {
    background: var(--white);
    border: 1px solid var(--gray-border);
    box-shadow: var(--shadow);
}
.edit-food-panel .noUi-target,
.addFoodModal .noUi-target {
    margin-bottom: 15px;
}
.meal-table th:nth-child(1), .meal-table td:nth-child(1) { width: 15%; } /* Uygulanan Kural */
.meal-table th:nth-child(2), .meal-table td:nth-child(2) { width: 15%; } /* Çakışan Kurallar */
.btn-secondary{background-color:var(--secondary-color);border-color:var(--secondary-color);}
.btn-secondary:hover{background-color:var(--secondary-hover);}
.btn-group{display:flex;gap:5px;}
.fixed-btn{position:sticky;top:10px;z-index:10;}
.fixed-btn-group{position:fixed;top:8px;left:20px;z-index:1000;background-color:var(--background-color);padding:3px;border-radius:5px;display:flex;flex-wrap:wrap;gap:10px;justify-content:flex-end;box-shadow:var(--shadow);}
.fixed-buttons{position:fixed;bottom:10px;right:10px;z-index:1000;display:flex;gap:3px;background-color:var(--background-color);padding:5px;border-radius:5px;}
.form-control,.form-select{font-size:0.85rem;padding:0.3rem;}
.settings-panel{background-color:var(--background-color);padding:10px;border:1px solid var(--gray-border);margin-bottom:15px;}
.edit-food-panel{position:fixed;top:20%;left:50%;transform:translateX(-50%);width:300px;background-color:var(--white);border:1px solid var(--gray-border);padding:10px;z-index:1000;box-shadow:var(--shadow-lg);display:none;}
.nav-tabs .nav-link{color:var(--text-dark);background-color:var(--gray-light);font-size:0.85rem;padding:0.3rem 0.6rem;}
.nav-tabs .nav-link.active{color:var(--text-light);background-color:var(--primary-color);}
#notification{position:fixed;top:10px;right:10px;z-index:1000;}
.alert-success{background-color:var(--success-color);color:var(--text-light);padding:10px;border-radius:5px;}
.alert-warning{background-color:#FFC107;color:var(--text-dark);padding:10px;border-radius:5px;}
.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;}
.meal-checkboxes,.food-checkboxes,.role-checkboxes{display:flex;flex-wrap:wrap;gap:5px;}
.role-checkboxes{font-size:0.8rem;}
.inline-accordion{display:inline-block;width:49%;margin-right:1%;}
.macro-modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);justify-content:center;align-items:center;}
.macro-modal-content{background-color:var(--white);padding:20px;border-radius:10px;position:relative;text-align:center;max-width:700px;width:90%;}
.macro-modal-close{position:absolute;top:10px;right:15px;font-size:24px;cursor:pointer;color:#333;}
.macro-modal-content h3{margin-bottom:20px;font-size:18px;}
.macro-modal-body{display:flex;align-items:flex-start;gap:20px;}
.macro-modal-chart{flex:0 0 300px;text-align:center;} /* Sabit genişlik: 300px */
#macroModalChart{width:300px;height:300px;display:block;}
.macro-modal-analysis{flex:1;background-color:#f9f9f9;padding:15px;border-radius:5px;font-size:14px;line-height:1.5;min-height:300px;overflow-y:auto;color:#333;}
.macro-modal-analysis h4{margin:0 0 10px 0;font-size:16px;color:#222;}
.macro-modal-analysis p{margin:5px 0;color:#333;}
.macro-modal-analysis .disclaimer{margin-top:15px;font-size:12px;font-style:italic;color:#666;}
.macro-tooltip{position:absolute;background-color:rgba(0,0,0,0.8);color:var(--text-light);padding:5px 10px;border-radius:5px;font-size:12px;pointer-events:none;z-index:1000;display:none;}
@media (max-width:768px){
    .sidebar{width:0;position:fixed;z-index:1000;height:100%;}
    .sidebar.active{width:200px;}
    .resizer{display:none;}
    .inline-accordion{display:block;width:100%;margin-right:0;}
    .fixed-btn-group{top:60px;right:5px;width:100%;justify-content:center;padding:5px;flex-direction:row;overflow-x:auto;white-space:nowrap;}
    .btn-group{flex-direction:row;}
    .macro-modal-content{max-width:90%;}
    .macro-modal-body{flex-direction:column;gap:10px;}
    .macro-modal-chart,.macro-modal-analysis{flex:none;width:100%;}
    .macro-modal-analysis{max-height:200px;}
    #notification {
    background-color: red !important;
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 1000;
}
}
        </style>
<style>
.btn-remove-meal {
  background-color: #28a745 !important;
  border-color: #28a745 !important;
  color: white;
}
.btn-remove-meal:hover {
  background-color: #218838 !important;
  border-color: #218838 !important;
}
</style>
<style>
    .meal-table th, .meal-table td {
        padding: 8px;
        text-align: center;
        vertical-align: middle;
    }
    .meal-table th.rule-column, .meal-table td.rule-column {
        width: 80px; /* Kural sütunu dar */
    }
    .meal-table th.conflict-column, .meal-table td.conflict-column {
        width: 80px; /* Çakışma sütunu dar */
    }
    .meal-table th.food-column, .meal-table td.food-column {
        width: auto; /* Yemek sütunu genişleyebilir */
        min-width: 200px; /* Minimum genişlik */
    }
    .meal-table span[title] {
        cursor: pointer; /* Fare üzerine geldiğinde el işareti */
    }
</style>
<script>

document.addEventListener('DOMContentLoaded', () => {
    const dynamicInputs = document.querySelectorAll('.dynamic-input');
    dynamicInputs.forEach(input => {
        input.addEventListener('input', function() {
            const minWidth = 200; // Piksel cinsinden minimum genişlik
            const maxWidth = this.parentElement.offsetWidth; // Sütun genişliği
            const textWidth = this.scrollWidth;
            this.style.width = `${Math.min(Math.max(textWidth, minWidth), maxWidth)}px`;
        });
    });
});
document.querySelectorAll('.dynamic-input').forEach(input => {
    input.addEventListener('input', function() {
        this.style.width = '100%';
        this.style.minWidth = '100%';
    });
});
function editFoodFromElement(el) {
  const name = el.getAttribute("data-name");
  if (name) editFood(name.trim());
}</script></head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark">
<div class="container-fluid">
<a class="navbar-brand" href="#">Beslenme Planlayıcı</a>
<button aria-controls="navbarNav" aria-expanded="false" aria-label="Menüyü Aç/Kapa" class="navbar-toggler" data-bs-target="#navbarNav" data-bs-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarNav">
<ul class="navbar-nav ms-auto">
<li class="nav-item">
<a class="nav-link" href="#" onclick="toggleSidebar()" title="Menüyü Aç/Kapa"><i class="bi bi-list"></i> Menü</a>
</li>
<li class="nav-item">
<a class="nav-link" href="#" onclick="switchMode('user')" title="Kullanıcı Moduna Geç"><i class="bi bi-person"></i> Kullanıcı</a>
</li>
<li class="nav-item">
<a class="nav-link" href="#" onclick="switchMode('admin')" title="Yönetici Moduna Geç"><i class="bi bi-gear"></i> Yönetici</a>
</li>
<li class="nav-item" id="dietModeSelector">
<label class="visually-hidden" for="dietModeSelect">Diyet Modu Seç</label>
<select class="form-select" id="dietModeSelect" onchange="updateDietMode(this.value)">
<option value="keto">Keto</option>
<option value="lowcarb">Low-Carb</option>
</select>
</li>
</ul>
</div>
</div>
</nav>
<div class="main-container">
<div class="sidebar" id="sidebar">
<div class="sidebar-header">
<h5>Kategoriler</h5>
<div class="mb-2">
<div class="input-group">
<label class="visually-hidden" for="searchFilterType">Arama Filtresi</label>
<select class="form-select" id="searchFilterType" style="width: 30%;">
<option value="name">Yemek Adı</option>
<option value="tags">Etiket</option>
<option value="role">Rol</option>
</select>
<label class="visually-hidden" for="searchFoodInput">Yemek Ara</label>
<input class="form-control" id="searchFoodInput" onkeyup="searchFood(this.value)" placeholder="Yemek Ara..." type="text"/>
</div>
</div>
<button class="btn btn-success w-100 fixed-btn" onclick="addSelectedFoods()" title="Seçilen Yemekleri Öğüne Ekle"><i class="bi bi-plus-circle"></i> Öğüne Ekle</button>
</div>
<div class="sidebar-content" id="sidebar-content">
<div class="mb-2" id="patientPreferences">
<div class="text-success" id="likedFoods"></div>
<div class="text-danger" id="dislikedFoods"></div>
</div>
<div class="accordion mb-2" id="categories"></div>
<button class="btn btn-primary w-100 mt-2" onclick="openAddFoodModal()" title="Yeni Yemek Ekle"><i class="bi bi-plus-circle"></i> Yeni Yemek Ekle</button>
<div class="accordion mb-2 mt-2" id="sidebarAccordion">
<!-- Kurallar Accordion -->
<div class="accordion-item">
<h2 class="accordion-header" id="rulesHeading">
<button aria-controls="rulesCollapse" aria-expanded="false" class="accordion-button collapsed fixed-btn" data-bs-target="#rulesCollapse" data-bs-toggle="collapse" type="button">
                Kurallar
            </button>
</h2>
<div aria-labelledby="rulesHeading" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion" id="rulesCollapse">
<div class="accordion-body">
<div class="mb-2" id="rulesList"></div>
<!-- Kural Düzenleme Formu -->
<div id="editRuleForm" style="display: none;">
<form onsubmit="saveEditedRule(event)">
<input id="editRuleIndex" type="hidden"/>
<h5>Kural Düzenle</h5>
<div class="mb-2">
<label class="form-label" for="editRuleType">Kural Türü</label>
<select class="form-select form-select-sm" id="editRuleType" onchange="updateRuleForm(true)" required="">
<option value="frequency">Sıklık</option>
<option value="exclude">Hariç Tut</option>
<option value="include">Ekle</option>
<option value="minCount">Minimum Sayı</option>
<option value="maxCount">Maksimum Sayı</option>
<option value="pairWith">Birlikte Ekle</option>
<option value="avoidPair">Birlikte Ekleme</option>
<option value="singleItem">Tek Başına</option>
<option value="maxRoleCount">Maksimum Rol Sayısı</option>
<option value="dependOn">Bağımlı Olsun</option>
<option value="categoryLock">Kategori Kilidi</option>
<option value="compatibility">Uyumluluk Kuralı</option>
</select>
</div>
<div id="editRuleFormDetails">
<div class="mb-2">
<label class="form-label">Kriterler:</label>
<div class="d-flex flex-column gap-2">
<div class="form-check">
<input class="form-check-input" id="editRuleNameCheck" onchange="document.getElementById('editRuleName').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="editRuleNameCheck">Yemek Adı</label>
<input class="form-control form-control-sm" disabled="" id="editRuleName" placeholder="Örn: Balık, Tavuk (AND: ,, OR: ;;)" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="editRuleTagsCheck" onchange="document.getElementById('editRuleTags').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="editRuleTagsCheck">Etiket</label>
<input class="form-control form-control-sm" disabled="" id="editRuleTags" placeholder="Örn: balık, keto (AND: ,, OR: ;;)" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="editRuleCategoryCheck" onchange="document.getElementById('editRuleCategory').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="editRuleCategoryCheck">Kategori</label>
<select class="form-select form-select-sm" disabled="" id="editRuleCategory">
<option value="">Seç</option>
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
<option value="SALATALAR">SALATALAR</option>
<option value="ÇORBALAR">ÇORBALAR</option>
<option value="EKMEKLER">EKMEKLER</option>
<option value="TATLILAR">TATLILAR</option>
<option value="MEYVELER">MEYVELER</option>
<option value="KURUYEMİŞLER">KURUYEMİŞLER</option>
<option value="DİĞER">DİĞER</option>
</select>
</div>
<div class="form-check">
<input class="form-check-input" id="editRuleRoleCheck" onchange="document.getElementById('editRuleRole').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="editRuleRoleCheck">Rol</label>
<select class="form-select form-select-sm" disabled="" id="editRuleRole">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="drink">İçecek</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
<div class="form-check">
<input class="form-check-input" id="editRuleMealTypeCheck" onchange="document.getElementById('editRuleMealType').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="editRuleMealTypeCheck">Öğün Türü</label>
<select class="form-select form-select-sm" disabled="" id="editRuleMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
</div>
</div>
<div class="mb-2" id="editFrequencyInput" style="display: none;">
<label class="form-label" for="editRuleFrequency">Haftada Kaç Kez</label>
<input class="form-control form-control-sm" id="editRuleFrequency" max="21" min="0" type="number" value="1"/>
<label class="form-label" for="freqType">Sıklık Türü</label>
<select class="form-select form-select-sm" id="freqType">
<option value="exact">Net Sayı</option>
<option value="min">En Az</option>
<option value="max">En Fazla</option>
</select>
</div>
<div class="mb-2" id="editCountInput" style="display: none;">
<label class="form-label" for="editRuleCount">Sayı</label>
<input class="form-control form-control-sm" id="editRuleCount" min="1" type="number" value="1"/>
</div>
<div class="mb-2" id="editPairInput" style="display: none;">
<label class="form-label" for="editRulePair">Eşleşecek Yemek</label>
<input class="form-control form-control-sm" id="editRulePair" placeholder="Örn: Salata" type="text"/>
</div>
<div class="mb-2" id="editCompatInput" style="display: none;">
<label class="form-label" for="editKeyword1">Uyumluluk Etiketi 1</label>
<input class="form-control form-control-sm" id="editKeyword1" placeholder="Örn: domates" type="text"/>
<label class="form-label" for="editCompatibleFood">Uyumluluk Etiketi 2 (Virgülle ayırın)</label>
<input class="form-control form-control-sm" id="editCompatibleFood" placeholder="Örn: peynir, zeytin" type="text"/>
<label class="form-label" for="editCompatibilityDegree">Derece (-5: Çok Uyumsuz, +5: Çok Uyumlu)</label>
<input class="form-control form-control-sm" id="editCompatibilityDegree" max="5" min="-5" type="number" value="0"/>
<label class="form-label" for="editCompatibilityType">Bağlaç</label>
<select class="form-select form-select-sm" id="editCompatibilityType">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="editRuleScope">Kapsam</label>
<select class="form-select form-select-sm" id="editRuleScope" required="">
<option value="daily">Günlük</option>
<option value="weekly">Haftalık</option>
<option value="meal">Öğün</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="editRuleWeekRange">Hafta Aralığı</label>
<input class="form-control form-control-sm" id="editRuleWeekRange" placeholder="Örn: 1-2 veya 3 (boş bırakılırsa tüm haftalar)" type="text"/>
</div>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kaydet" type="submit">Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Yeni Kural Ekleme -->
<div class="mb-2">
<h6>Yeni Kural Ekle</h6>
<div class="d-flex flex-column gap-2">
<button class="btn btn-primary w-100" onclick="openFrequencyRuleForm()" title="Sıklık Kuralı Ekle">Sıklık Kuralı Ekle</button>
<button class="btn btn-primary w-100" onclick="openDependOnRuleForm()" title="Bağımlı Olsun Kuralı Ekle">Bağımlı Olsun Kuralı Ekle</button>
<button class="btn btn-primary w-100" onclick="openCompatibilityRuleForm()" title="Uyumluluk Kuralı Ekle">Uyumluluk Kuralı Ekle</button>
<button class="btn btn-primary w-100" onclick="openCategoryLockRuleForm()" title="Kategori Kilidi Kuralı Ekle">Kategori Kilidi Kuralı Ekle</button>
<button class="btn btn-primary w-100" onclick="openPairRuleForm()" title="Birliktelik Kuralı Ekle">Birliktelik Kuralı Ekle</button>
</div>
</div>
<!-- Sıklık Kuralı Formu -->
<div id="frequencyRuleForm" style="display: none;">
<form onsubmit="handleRuleSave(event)">
<h5>Sıklık Kuralı Ekle</h5>
<div class="mb-2">
<label class="form-label">Kriterler:</label>
<div class="d-flex flex-column gap-2">
<div class="form-check">
<input class="form-check-input" id="freqNameCheck" onchange="document.getElementById('freqName').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="freqNameCheck">Yemek Adı</label>
<input class="form-control form-control-sm" disabled="" id="freqName" placeholder="Örn: Balık, Tavuk (AND: ,, OR: ;;)" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="freqTagCheck" onchange="document.getElementById('freqTag').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="freqTagCheck">Etiket</label>
<input class="form-control form-control-sm" disabled="" id="freqTag" placeholder="Örn: balık, keto (AND: ,, OR: ;;)" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="freqRoleCheck" onchange="document.getElementById('freqRole').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="freqRoleCheck">Rol</label>
<select class="form-select form-select-sm" disabled="" id="freqRole">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="drink">İçecek</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
<div class="form-check">
<input class="form-check-input" id="freqCatCheck" onchange="document.getElementById('freqCat').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="freqCatCheck">Kategori</label>
<select class="form-select form-select-sm" disabled="" id="freqCat">
<option value="">Seç</option>
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
<option value="SALATALAR">SALATALAR</option>
<option value="ÇORBALAR">ÇORBALAR</option>
<option value="EKMEKLER">EKMEKLER</option>
<option value="TATLILAR">TATLILAR</option>
<option value="MEYVELER">MEYVELER</option>
<option value="KURUYEMİŞLER">KURUYEMİŞLER</option>
<option value="DİĞER">DİĞER</option>
</select>
</div>
</div>
</div>
<div class="mb-2">
<label class="form-label" for="freqType">Sıklık Türü</label>
<select class="form-select form-select-sm" id="freqType" required="">
<option value="exact">Net Sayı</option>
<option value="min">En Az</option>
<option value="max">En Fazla</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="freqCount">Sayı</label>
<input class="form-control form-control-sm" id="freqCount" min="1" required="" type="number" value="1"/>
</div>
<div class="mb-2">
<label class="form-label" for="freqScope">Kapsam</label>
<select class="form-select form-select-sm" id="freqScope" onchange="document.getElementById('freqMealContainer').style.display = this.value === 'meal' ? 'block' : 'none';" required="">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
<option value="week">Hafta</option>
</select>
</div>
<div class="mb-2" id="freqMealContainer" style="display: none;">
<label class="form-label" for="freqMeal">Öğün Türü</label>
<select class="form-select form-select-sm" id="freqMeal">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="freqWeekRange">Hafta Aralığı</label>
<input class="form-control form-control-sm" id="freqWeekRange" placeholder="Örn: 1-2 veya 3 (boş bırakılırsa tüm haftalar)" type="text"/>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kuralı Kaydet" type="submit">Kuralı Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Bağımlı Olsun Kuralı Formu -->
<div id="dependOnRuleForm" style="display: none;">
<form onsubmit="handleRuleSave(event)">
<h5>Bağımlı Olsun Kuralı</h5>
<div class="mb-2">
<label class="form-label" for="dependOnFood">Bağımlı Yemek</label>
<input class="form-control form-control-sm" id="dependOnFood" placeholder="Örn: Mayonez" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="dependOnRequiredFood">Bağımlı Olduğu Yemek</label>
<input class="form-control form-control-sm" id="dependOnRequiredFood" placeholder="Örn: Köfte" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="dependOnScope">Kapsam</label>
<select class="form-select form-select-sm" id="dependOnScope" required="">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
</select>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kuralı Kaydet" type="submit">Kuralı Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Uyumluluk Kuralı Formu -->
<div id="compatibilityRuleForm" style="display: none;">
<form onsubmit="handleRuleSave(event)">
<h5>Uyumluluk Kuralı</h5>
<div class="mb-2">
<label class="form-label" for="compatKeyword1">Uyumluluk Etiketi 1</label>
<input class="form-control form-control-sm" id="compatKeyword1" placeholder="Örn: domates" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatKeyword2">Uyumluluk Etiketi 2 (Virgülle ayırın)</label>
<input class="form-control form-control-sm" id="compatKeyword2" placeholder="Örn: peynir, zeytin" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatDegree">Derece (-5: Çok Uyumsuz, +5: Çok Uyumlu)</label>
<input class="form-control form-control-sm" id="compatDegree" max="5" min="-5" required="" type="number" value="0"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatConjunction">Bağlaç</label>
<select class="form-select form-select-sm" id="compatConjunction" required="">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kuralı Kaydet" type="submit">Kuralı Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Kategori Kilidi Kuralı Formu -->
<div id="categoryLockRuleForm" style="display: none;">
<form onsubmit="handleRuleSave(event)">
<h5>Kategori Kilidi Kuralı</h5>
<div class="mb-2">
<label class="form-label" for="categoryLockCategory">Kilitlenecek Kategori</label>
<select class="form-select form-select-sm" id="categoryLockCategory" required="">
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
<option value="SALATALAR">SALATALAR</option>
<option value="ÇORBALAR">ÇORBALAR</option>
<option value="EKMEKLER">EKMEKLER</option>
<option value="TATLILAR">TATLILAR</option>
<option value="MEYVELER">MEYVELER</option>
<option value="KURUYEMİŞLER">KURUYEMİŞLER</option>
<option value="DİĞER">DİĞER</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="categoryLockScope">Kapsam</label>
<select class="form-select form-select-sm" id="categoryLockScope" required="">
<option value="week">Hafta</option>
</select>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kuralı Kaydet" type="submit">Kuralı Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Birliktelik Kuralı Formu -->
<div id="pairRuleForm" style="display: none;">
<form onsubmit="handleRuleSave(event)">
<h5>Birliktelik Kuralı</h5>
<div class="mb-2">
<label class="form-label">Birinci Kelime:</label>
<div class="d-flex flex-column gap-2">
<div class="form-check">
<input class="form-check-input" id="pair1NameCheck" onchange="document.getElementById('pair1Name').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair1NameCheck">İsim</label>
<input class="form-control form-control-sm" disabled="" id="pair1Name" placeholder="Örn: Balık" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="pair1TagCheck" onchange="document.getElementById('pair1Tag').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair1TagCheck">Etiket</label>
<input class="form-control form-control-sm" disabled="" id="pair1Tag" placeholder="Örn: balık, keto" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="pair1RoleCheck" onchange="document.getElementById('pair1Role').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair1RoleCheck">Rol</label>
<select class="form-select form-select-sm" disabled="" id="pair1Role">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
</select>
</div>
<div class="form-check">
<input class="form-check-input" id="pair1CatCheck" onchange="document.getElementById('pair1Cat').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair1CatCheck">Kategori</label>
<select class="form-select form-select-sm" disabled="" id="pair1Cat">
<option value="">Seç</option>
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
</select>
</div>
</div>
</div>
<div class="mb-2">
<label class="form-label">İkinci Kelime:</label>
<div class="d-flex flex-column gap-2">
<div class="form-check">
<input class="form-check-input" id="pair2NameCheck" onchange="document.getElementById('pair2Name').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair2NameCheck">İsim</label>
<input class="form-control form-control-sm" disabled="" id="pair2Name" placeholder="Örn: Salata" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="pair2TagCheck" onchange="document.getElementById('pair2Tag').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair2TagCheck">Etiket</label>
<input class="form-control form-control-sm" disabled="" id="pair2Tag" placeholder="Örn: salata, keto" type="text"/>
</div>
<div class="form-check">
<input class="form-check-input" id="pair2RoleCheck" onchange="document.getElementById('pair2Role').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair2RoleCheck">Rol</label>
<select class="form-select form-select-sm" disabled="" id="pair2Role">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
</select>
</div>
<div class="form-check">
<input class="form-check-input" id="pair2CatCheck" onchange="document.getElementById('pair2Cat').disabled = !this.checked" type="checkbox"/>
<label class="form-check-label" for="pair2CatCheck">Kategori</label>
<select class="form-select form-select-sm" disabled="" id="pair2Cat">
<option value="">Seç</option>
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
</select>
</div>
</div>
</div>
<div class="mb-2">
<label class="form-label" for="pairType">Birliktelik Türü</label>
<select class="form-select form-select-sm" id="pairType" required="">
<option value="together">Birlikte Olsun</option>
<option value="apart">Birlikte Olmasın</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="pairConjunction">Bağlaç</label>
<select class="form-select form-select-sm" id="pairConjunction" required="">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="pairDirection">Yön</label>
<select class="form-select form-select-sm" id="pairDirection" required="">
<option value="bidirectional">Çift Yönlü</option>
<option value="unidirectional">Tek Yönlü</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="pairScope">Kapsam</label>
<select class="form-select form-select-sm" id="pairScope" onchange="document.getElementById('pairMealContainer').style.display = this.value === 'meal' ? 'block' : 'none';" required="">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
<option value="week">Hafta</option>
</select>
</div>
<div class="mb-2" id="pairMealContainer" style="display: none;">
<label class="form-label" for="pairMeal">Öğün Türü</label>
<select class="form-select form-select-sm" id="pairMeal">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="pairWeekRange">Hafta Aralığı</label>
<input class="form-control form-control-sm" id="pairWeekRange" placeholder="Örn: 1-2 veya 3 (boş bırakılırsa tüm haftalar)" type="text"/>
</div>
<div class="d-flex gap-2">
<button class="btn btn-success w-100" title="Kuralı Kaydet" type="submit">Kuralı Kaydet</button>
<button class="btn btn-secondary w-100" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</div>
</form>
</div>
<!-- Şablon Yönetimi -->
<div class="mb-2">
<label class="form-label" for="templateName">Şablon Adı</label>
<input class="form-control form-control-sm" id="templateName" placeholder="Şablon Adı" type="text"/>
</div>
<button class="btn btn-success w-100 mb-1" onclick="saveRuleTemplate()" title="Şablon Kaydet">Şablon Kaydet</button>
<label class="form-label" for="templateSelect">Şablon Seç</label>
<select class="form-select form-select-sm mb-1" id="templateSelect">
<option value="">Şablon Yükle</option>
</select>
<button class="btn btn-primary w-100 mb-1" onclick="loadRuleTemplate()" title="Şablon Yükle">Şablon Yükle</button>
<button class="btn btn-danger w-100" onclick="deleteRuleTemplate()" title="Şablon Sil">Şablon Sil</button>
</div>
</div>
</div>
<!-- Uyumluluk Kuralları Accordion -->
<div class="accordion-item">
<h2 class="accordion-header" id="compatibilityHeading">
<button aria-controls="compatibilityCollapse" aria-expanded="false" class="accordion-button collapsed" data-bs-target="#compatibilityCollapse" data-bs-toggle="collapse" type="button">
                                Uyumluluk Kuralları
                            </button>
</h2>
<div aria-labelledby="compatibilityHeading" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion" id="compatibilityCollapse">
<div class="accordion-body" style="max-height: 300px; overflow-y: auto;">
<div class="mb-2" id="compatibilityList"></div>
<div class="mb-2">
<label class="form-label" for="sidebarCompatKeyword1">Kelime 1</label>
<input class="form-control" id="sidebarCompatKeyword1" placeholder="örn: balık" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="sidebarCompatKeyword2">Kelime 2 (Virgülle ayırın)</label>
<input class="form-control" id="sidebarCompatKeyword2" placeholder="örn: süt,yoğurt" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatDegree">Derece (-5: Çok Uyumsuz, +5: Çok Uyumlu)</label>
<input class="form-control" id="compatDegree" max="5" min="-5" type="number" value="0"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatConjunction">Bağlaç</label>
<select class="form-select" id="compatConjunction">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<button class="btn btn-primary w-100" onclick="addCompatibilityRule()" title="Uyumluluk Ekle">Uyumluluk Ekle</button>
<button class="btn btn-primary w-100 mt-2" onclick="importFoodList()" title="Liste Al"><i class="bi bi-upload"></i> Liste Al</button>
<button class="btn btn-success w-100 mt-2" onclick="exportFoodList()" title="Son Listeyi Ver"><i class="bi bi-download"></i> Son Listeyi Ver</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="resizer" id="resizer"></div>
<div class="main-content" id="mainContent">
<div class="alert alert-success" id="notification" style="display: none;"></div>
<div class="modal" id="patientFormModal" style="display: none;">
<div class="modal-content" style="background-color: var(--white); padding: 20px; border-radius: 10px; max-width: 500px; width: 90%; margin: auto; position: relative; top: 20%;">
<span class="modal-close" onclick="closePatientFormModal()" style="position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; color: #333;">×</span>
<h3 id="patientFormTitle">Hasta Ekle</h3>
<form id="patientForm" onsubmit="handlePatientFormSubmit(event)">
<div class="mb-2">
<label class="form-label" for="userName">İsim</label>
<input class="form-control" id="userName" placeholder="Hasta Adı" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="userWeight">Kilo (kg)</label>
<input class="form-control" id="userWeight" min="1" placeholder="Kilo" required="" type="number"/>
</div>
<div class="mb-2">
<label class="form-label" for="userActivity">Aktivite Seviyesi</label>
<select class="form-select" id="userActivity" required="">
<option value="1">Hareketsiz</option>
<option value="2">Hafif Aktif</option>
<option value="3">Orta Aktif</option>
<option value="4">Çok Aktif</option>
<option value="5">Aşırı Aktif</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="likedFoodsInput">Sevdiği Yemekler</label>
<input class="form-control" id="likedFoodsInput" placeholder="Virgülle ayırın (örn: balık, salata)" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="dislikedFoodsInput">Sevmediği Yemekler</label>
<input class="form-control" id="dislikedFoodsInput" placeholder="Virgülle ayırın (örn: brokoli, karnabahar)" type="text"/>
</div>
<button class="btn btn-success w-100" type="submit">Kaydet</button>
<button class="btn btn-secondary w-100 mt-1" onclick="closePatientFormModal()" type="button">İptal</button>
</form>
</div>
</div>
<!-- Tek bir adminPanel div'i -->
<div class="p-3" id="adminPanel" style="display: block;">
<!-- Hasta Seçimi Bölümü -->
<div class="d-flex justify-content-between align-items-center mb-2">
<div class="d-flex align-items-center gap-2 flex-wrap">
<label class="visually-hidden" for="patientSelect">Hasta Seç</label>
<select class="form-select w-auto" id="patientSelect" onchange="handlePatientChange()">
<option value="">Hasta Seç</option>
</select>
<label class="visually-hidden" for="likedFoodsDisplay">Sevdiği Yemekler</label>
<input class="form-control w-auto" id="likedFoodsDisplay" onblur="updatePatientPreferences()" placeholder="Sevdiği" type="text"/>
<label class="visually-hidden" for="dislikedFoodsDisplay">Sevmediği Yemekler</label>
<input class="form-control w-auto" id="dislikedFoodsDisplay" onblur="updatePatientPreferences()" placeholder="Sevmediği" type="text"/>
<button class="btn btn-primary" onclick="addPatient()" title="Hasta Ekle"><i class="bi bi-person-plus"></i></button>
<button class="btn btn-warning" onclick="editPatient()" title="Hasta Düzenle"><i class="bi bi-pencil"></i></button>
<button class="btn btn-danger" onclick="deletePatient()" title="Hasta Sil"><i class="bi bi-trash"></i></button>
</div>
<!-- GitHub Token Giriş Alanı ve Buton -->
<div class="mb-3">
<label class="form-label" for="githubToken">GitHub Token</label>
<input class="form-control" id="githubToken" placeholder="GitHub Personal Access Token girin" required="" type="password"/>
<button class="btn btn-primary mt-2 w-100" onclick="updateGitHubData()" title="GitHub'a Gönder">
<i class="bi bi-upload"></i> GitHub'a Gönder
                            </button>
</div>
</div>
<div class="d-flex gap-2 mb-2">
<div class="accordion inline-accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="settingsHeading">
<button aria-controls="settingsCollapse" aria-expanded="false" class="accordion-button green collapsed" data-bs-target="#settingsCollapse" data-bs-toggle="collapse" type="button">
                                        Ayarlar
                                    </button>
</h2>
<div aria-labelledby="settingsHeading" class="accordion-collapse collapse" id="settingsCollapse">
<div class="accordion-body">
<div class="settings-panel">
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="minItemsPerMeal">Min. Yemek/Öğün</label>
<input class="form-control" id="minItemsPerMeal" max="10" min="1" type="number" value="2"/>
</div>
<div class="col-6">
<label class="form-label" for="maxItemsPerMeal">Maks. Yemek/Öğün</label>
<input class="form-control" id="maxItemsPerMeal" max="10" min="1" type="number" value="5"/>
</div>
</div>
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="lunchCalorieRatio">Öğle Kalori (%)</label>
<input class="form-control" id="lunchCalorieRatio" max="100" min="0" type="number" value="40"/>
</div>
<div class="col-6">
<label class="form-label" for="dinnerCalorieRatio">Akşam Kalori (%)</label>
<input class="form-control" id="dinnerCalorieRatio" max="100" min="0" type="number" value="50"/>
</div>
</div>
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="calorieFlexibility">Kalori Esneklik (±%)</label>
<input class="form-control" id="calorieFlexibility" max="20" min="0" type="number" value="10"/>
</div>
<div class="col-6">
<label class="form-label" for="varietyScore">Min. Çeşitlilik Skoru</label>
<input class="form-control" id="varietyScore" max="1" min="0" step="0.1" type="number" value="0.7"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="carbMultiplier">Karb Çarpanı</label>
<input class="form-control" id="carbMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="0.3"/>
</div>
<div class="col-4">
<label class="form-label" for="proteinMultiplier">Prot. Çarpanı</label>
<input class="form-control" id="proteinMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="0.8"/>
</div>
<div class="col-4">
<label class="form-label" for="fatMultiplier">Yağ Çarpanı</label>
<input class="form-control" id="fatMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="1.2"/>
</div>
</div>
<div class="mb-2">
<label class="form-label">Ekleme Kriteri</label>
<div>
<input checked="" id="useName" type="checkbox"/> <label for="useName">İsim</label>
<input checked="" id="useTags" type="checkbox"/> <label for="useTags">Etiket</label>
</div>
</div>
<div class="mb-2">
<label class="form-label">Öğün Tercihleri</label>
<div class="mb-1">
<strong>Kahvaltı:</strong>
<input checked="" id="prefBreakfastDrink" type="checkbox"/> <label for="prefBreakfastDrink">İçecek</label>
</div>
<div class="mb-1">
<strong>Öğle:</strong>
<input checked="" id="prefLunchEgg" type="checkbox"/> <label for="prefLunchEgg">Yumurta</label>
<input checked="" id="prefLunchSoup" type="checkbox"/> <label for="prefLunchSoup">Çorba</label>
</div>
<div class="mb-1">
<strong>Akşam Ekstraları:</strong>
<div>
<label for="prefDinnerNuts">Kuruyemiş (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerNuts" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerSoup">Çorba (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerSoup" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerDessert">Tatlı (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerDessert" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerFruit">Meyve (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerFruit" max="100" min="0" type="number" value="50"/>
</div>
</div>
</div>
<!-- Kural açıklamasını göstermek için -->
<div id="ruleTextElement"></div>
<div class="mt-3 p-2 border rounded" id="compatibilityStatus">
<h6 class="mb-2">Uyumluluk Kuralları Durumu</h6>
<div id="activeCompatRules"></div>
</div>
<div class="row mb-2">
<div class="col-12">
<label class="form-label">Hariç Tutulacak Etiketler</label>
<div class="mb-1">
<label for="excludedTagsBreakfast">Kahvaltı:</label>
<input class="form-control" id="excludedTagsBreakfast" placeholder="örn: keto,lowcarb,zeytinyağı" type="text" value="keto,lowcarb"/>
</div>
<div class="mb-1">
<label for="excludedTagsLunch">Öğle:</label>
<input class="form-control" id="excludedTagsLunch" placeholder="örn: keto,lowcarb,Zeytinyağı" type="text" value="keto,lowcarb"/>
</div>
<div class="mb-1">
<label for="excludedTagsDinner">Akşam:</label>
<input class="form-control" id="excludedTagsDinner" placeholder="örn: keto,lowcarb,zeytinyağı" type="text" value="keto,lowcarb"/>
</div>
<small class="form-text text-muted">Aynı öğünde çakışma kontrolünden hariç tutulacak etiketleri virgülle ayırarak yazın.</small>
</div>
</div>
<!-- Kural ekleme/düzenleme butonu -->
<button id="addRuleButton" onclick="handleRuleSave()">Kural Ekle</button>
<div class="settings-panel">
<h6>Öğün Bazlı Limitler</h6>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="breakfastMin">Kahvaltı Min</label>
<input class="form-control" id="breakfastMin" max="1" min="1" type="number" value="1"/>
</div>
<div class="col-4">
<label class="form-label" for="breakfastMax">Kahvaltı Max</label>
<input class="form-control" id="breakfastMax" max="1" min="1" type="number" value="1"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="lunchMin">Öğle Min</label>
<input class="form-control" id="lunchMin" min="0" type="number" value="2"/>
</div>
<div class="settings-panel">
<h6>Öğün Bazlı Sabit Yemekler</h6>
<div class="mb-2">
<label for="fixedBreakfastMeal">Kahvaltı Sabit Yemek:</label>
<select class="form-select" id="fixedBreakfastMeal">
<option value="">Yok</option>
<option selected="" value="Kurşun Geçirmez Kahve">Kurşun Geçirmez Kahve</option>
</select>
</div>
<div class="mb-2">
<label for="fixedLunchMeal">Öğle Sabit Yemek:</label>
<select class="form-select" id="fixedLunchMeal">
<option value="">Yok</option>
</select>
</div>
<div class="mb-2">
<label for="fixedDinnerMeal">Akşam Sabit Yemek:</label>
<select class="form-select" id="fixedDinnerMeal">
<option value="">Yok</option>
</select>
</div>
</div>
<div class="col-4">
<label class="form-label" for="lunchMax">Öğle Max</label>
<input class="form-control" id="lunchMax" min="0" type="number" value="5"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="dinnerMin">Akşam Min</label>
<input class="form-control" id="dinnerMin" min="0" type="number" value="2"/>
</div>
<div class="col-4">
<label class="form-label" for="dinnerMax">Akşam Max</label>
<input class="form-control" id="dinnerMax" min="0" type="number" value="5"/>
</div>
</div>
</div>
<div class="mb-2">
<label class="form-label" for="settingsTemplate">Ayar Şablonu Adı</label>
<input class="form-control" id="settingsTemplate" placeholder="Şablon Adı" type="text"/>
</div>
<button class="btn btn-success w-100 mb-1" onclick="saveSettingsTemplate(true)" title="Ayarları Varsayılan Kaydet">Varsayılan Kaydet</button>
<button class="btn btn-success w-100 mb-1" onclick="saveSettingsTemplate(false)" title="Ayarları Hasta İçin Kaydet">Hasta İçin Kaydet</button>
<label class="form-label" for="settingsTemplateSelect">Ayar Şablonu Seç</label>
<select class="form-select mb-1" id="settingsTemplateSelect">
<option value="">Ayar Yükle</option>
</select>
<button class="btn btn-primary w-100" onclick="loadSettingsTemplate()" title="Ayarları Yükle">Yükle</button>
<button class="btn btn-primary w-100 mt-2" onclick="applySettings()" title="Ayarları Uygula">Ayarları Uygula</button>
</div>
</div>
</div>
</div>
</div>
<div class="meal-plan-container" id="mealPlanArea"></div>
<div aria-labelledby="autoPlanningHeading" class="accordion-collapse collapse" id="autoPlanningCollapse">
<div class="accordion-body">
<label>Makro Hedeflere Uyun (%): <input id="macroPriority" max="100" min="0" type="range" value="80"/></label><br/>
<label>Şablon Önceliği (%): <input id="templatePriority" max="100" min="0" type="range" value="60"/></label><br/>
<label>Kural Önceliği (%): <input id="rulePriority" max="100" min="0" type="range" value="100"/></label><br/>
<label>Uyumluluk Önceliği (%): <input id="compatibilityPriority" max="100" min="0" type="range" value="70"/></label><br/>
<label>Yönetim Önceliği (%): <input id="managementPriority" max="100" min="0" type="range" value="50"/></label><br/>
<label>Makro Toleransı (±%): <input id="macroTolerance" max="20" min="0" type="range" value="10"/></label><br/>
<label>Katsayıları Optimize Et: <input checked="" id="optimizeCoefficients" type="checkbox"/></label><br/>
<label>Kahvaltı Önceliği: 
                                <select class="form-select w-auto d-inline" id="breakfastPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<label>Öğle Önceliği: 
                                <select class="form-select w-auto d-inline" id="lunchPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<label>Akşam Önceliği: 
                                <select class="form-select w-auto d-inline" id="dinnerPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<button class="btn btn-primary w-100 mb-1" onclick="generateFastPlan()" title="Hızlı Planla"><i class="bi bi-lightning"></i> Hızlı Planla</button>
<button class="btn btn-success w-100 mb-1" onclick="applyAllRules()" title="Tüm Kuralları Uygula"><i class="bi bi-check2-all"></i> Tüm Kuralları Uygula</button>
</div>
</div>
<div class="accordion inline-accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="templatesHeading">
<button aria-controls="templatesCollapse" aria-expanded="false" class="accordion-button green collapsed" data-bs-target="#templatesCollapse" data-bs-toggle="collapse" type="button">
                                    Öğün Şablonları
                                </button>
</h2>
<div aria-labelledby="templatesHeading" class="accordion-collapse collapse" id="templatesCollapse">
<div class="accordion-body">
<!-- Tek bir yükleme alanı -->
<div class="input-group mb-3">
<input accept=".xlsx,.xls,.txt" id="importFile" onchange="importFromFile(event)" style="display: none;" type="file"/>
<button class="btn btn-success w-100" onclick="document.getElementById('importFile').click()">
<i class="bi bi-upload"></i> Dosyadan Şablon Ekle (Excel/TXT)
    </button>
</div>
<div class="mb-2" id="mealTemplatesList"></div>
<div class="mb-2" id="editTemplateForm" style="display: none;">
<form onsubmit="saveEditedTemplate(event)">
<input id="editTemplateIndex" type="hidden"/>
<div class="mb-2">
<label class="form-label" for="editTemplateName">Şablon Adı</label>
<input class="form-control" id="editTemplateName" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="editTemplateMealType">Öğün Türü</label>
<select class="form-select" id="editTemplateMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="editTemplateFrequency">Haftada Kaç Gün</label>
<input class="form-control" id="editTemplateFrequency" max="7" min="1" type="number"/>
</div>
<div class="mb-2" id="editTemplateItems"></div>
<button class="btn btn-success w-100" title="Kaydet" type="submit">Kaydet</button>
<button class="btn btn-secondary w-100 mt-1" onclick="cancelEditTemplate()" title="İptal" type="button">İptal</button>
</form>
</div>
<div class="mb-2">
<label class="form-label" for="templateMealType">Öğün Türü</label>
<select class="form-select" id="templateMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="templateFrequency">Haftada Kaç Gün</label>
<input class="form-control" id="templateFrequency" max="7" min="1" type="number" value="1"/>
</div>
<div class="mb-2" id="templateItems">
<div class="row mb-1">
<div class="col-4">
<label class="form-label" for="templateItem1Keyword">Etiket</label>
<input class="form-control" id="templateItem1Keyword" placeholder="örn: yumurta, omlet" type="text"/>
</div>
<div class="col-4">
<label class="form-label" for="templateItem1Role">Rol</label>
<select class="form-select" id="templateItem1Role">
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="drink">İçecek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
<div class="col-4">
<label class="form-label" for="templateItem1Quantity">Sayı</label>
<input class="form-control" id="templateItem1Quantity" min="1" type="number" value="1"/>
</div>
</div>
</div>
<html>
<head>
<title>Excel Yükleme</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
.btn-remove-meal {
  background-color: #28a745 !important;
  border-color: #28a745 !important;
  color: white;
}
.btn-remove-meal:hover {
  background-color: #218838 !important;
  border-color: #218838 !important;
}
</style>
</head>
<body>
<!-- Yukarıdaki JS kodunu buraya kaydedin -->
<!-- SheetJS Kütüphanesi -->
<div style="margin-top: 10px;">
<label><strong>Dosyadan Yemekleri Yükle (Excel/TXT):</strong></label><br/>
<input accept=".xlsx,.xls,.txt" onchange="importFromFile(event)" type="file"/>
</div>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script>

let currentMacros = {
    calories: 1064, // Varsayılan değer
    carbs: 21,     // Varsayılan keto için
    protein: 56,   // Varsayılan
    fat: 83       // Varsayılan
};


function initializeSeasonSlider(sliderId, rangeInputId, displayId) {
    const slider = document.getElementById(sliderId);
    const rangeInput = document.getElementById(rangeInputId);
    const display = document.getElementById(displayId);

    if (!slider || !rangeInput || !display) {
        console.error("Slider elemanları bulunamadı:", { sliderId, rangeInputId, displayId });
        return;
    }

    // Ay isimleri
    const months = [
        "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran",
        "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"
    ];

    // noUiSlider oluştur
    if (!slider.noUiSlider) { // Slider zaten başlatılmamışsa
        noUiSlider.create(slider, {
            start: [4, 9], // Varsayılan: Nisan - Eylül
            connect: true,
            range: {
                'min': 1,
                'max': 12
            },
            step: 1,
            tooltips: [
                { to: value => months[Math.round(value) - 1] },
                { to: value => months[Math.round(value) - 1] }
            ],
            format: {
                to: value => Math.round(value),
                from: value => Number(value)
            }
        });
    }

    // Slider değiştiğinde
    slider.noUiSlider.on("update", function (values) {
        const [start, end] = values.map(Number);
        rangeInput.value = `[${start},${end}]`;
        display.textContent = `${months[start - 1]} - ${months[end - 1]}`;
    });

    // Varsayılan değerleri ayarla
    try {
        const initialRange = JSON.parse(rangeInput.value || "[4,9]");
        slider.noUiSlider.set(initialRange);
        display.textContent = `${months[initialRange[0] - 1]} - ${months[initialRange[1] - 1]}`;
    } catch (e) {
        console.error("Başlangıç aralığı parse edilemedi:", rangeInput.value);
        slider.noUiSlider.set([4, 9]);
        rangeInput.value = "[4,9]";
        display.textContent = "Nisan - Eylül";
    }
}

function convertOldSeasonToRange(season) {
    const seasonMap = {
        "yaz": [6, 8], // Haziran - Ağustos
        "kış": [12, 2], // Aralık - Şubat
        "ilkbahar": [3, 5], // Mart - Mayıs
        "sonbahar": [9, 11], // Eylül - Kasım
        "4 mevsim": [1, 12] // Tüm yıl
    };
    return seasonMap[season] || [1, 12];
}
// Kategorileri dönüştürme
categories.forEach(category => {
    category.items.forEach(item => {
        if (item.season && !item.seasonRange) {
            item.seasonRange = JSON.stringify(convertOldSeasonToRange(item.season));
            delete item.season;
        }
    });
});

function handleExcelUpload(event) {
    const file = event.target.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, {type: 'array'});

        // YASAK KELİMELER (tam temizlik)
        const forbiddenWords = ['pazartesi','salı','çarşamba','perşembe','cuma','cumartesi','pazar',
                                'sabah','malzeme','kart','pdf','burayı','öneri','vermeyin','not:','gün','listesi'];

        let extractedFoods = [];
        let currentCategory = null;

        workbook.SheetNames.forEach(sheetName => {
            if (sheetName.toLowerCase().includes("pdf")) return;

            const sheet = workbook.Sheets[sheetName];
            const excelData = XLSX.utils.sheet_to_json(sheet, {header: 1});
            let aktifOguneGir = false;

            excelData.forEach(row => {
                const raw = (row[0] || "").toString().toLowerCase().trim();

                // Öğle veya Akşam gelmeden hiçbir şey alma
                if (raw.includes("öğle")) {
                    currentCategory = "ÖĞLEN";
                    aktifOguneGir = true;
                    return;
                }
                if (raw.includes("akşam")) {
                    currentCategory = "AKŞAM";
                    aktifOguneGir = true;
                    return;
                }

                if (!aktifOguneGir || !currentCategory) return;

                const name = (row[0] || "").toString().trim();
                const nameLower = name.toLowerCase();

                // Yasak kelime içeriyorsa atla
                if (forbiddenWords.some(w => nameLower.includes(w))) return;

                // Satırda minimum 5 hücre olmalı
                if (!row || row.length < 5) return;

                const cal = parseFloat(row[1]);
                const carbs = parseFloat(row[2]);
                const protein = parseFloat(row[3]);
                const fat = parseFloat(row[4]);

                if (
                    isNaN(cal) || cal === 0 ||
                    isNaN(carbs) || isNaN(protein) || isNaN(fat)
                ) return;

                // Çok kısa isimli ya da sadece sayı/birim içeren adları atla
                if (name.length < 3 || /^[\d\s\-\.]+$/.test(name)) return;

                const foodObject = {
                    name,
                    calories: cal,
                    protein,
                    carbs,
                    fat,
                    category: currentCategory,
                    mealType: currentCategory === "ÖĞLEN" ? ["lunch"] : ["dinner"],
                    tags: determineTags(name),
                    role: determineRole(name),
                    keto: true,
                    lowcarb: true,
                    fillerLunch: false,
                    fillerDinner: false,
                    step: 0.5,
                    maxQuantity: 1,
                    minQuantity: 0.5
                };

                let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
                const catList = storedFoodList[foodObject.category] || [];
                const alreadyExists = catList.some(f => f.name.trim().toLowerCase() === nameLower);

                if (!alreadyExists) {
                    extractedFoods.push(foodObject);
                }
            });
        });

        integrateNewFoods(extractedFoods);
    };

    reader.readAsArrayBuffer(file);
}
</script>
<script>
// Sayfa yüklendiğinde bağlan
document.addEventListener("DOMContentLoaded", () => {
    const ids = ["editCarbs", "editProtein", "editFat"];
    ids.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesInPopup);
        }
    });
});

function updateCaloriesInPopup() {
    const carbs = parseFloat(document.getElementById("editCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}
</script>
<script>
function initializeEditFoodPanel() {
    ["editFoodCarbs", "editFoodProtein", "editFoodFat"].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesLive);
        }
    });
    updateCaloriesLive();
}

function updateCaloriesLive() {
    const carbs = parseFloat(document.getElementById("editFoodCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editFoodProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFoodFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editFoodCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}

function updateCompatibilityStatus() {
  const activeRulesDiv = document.getElementById('activeCompatRules');
  if (!activeRulesDiv) return;
  
  // Uyumluluk kurallarını filtrele
  const compatRules = rules.filter(rule => 
    rule.type === 'compatibility' && rule.keyword1 && rule.keyword2 && rule.keyword2.length > 0
  );
  
  if (compatRules.length === 0) {
    activeRulesDiv.innerHTML = '<p class="text-warning">Hiç uyumluluk kuralı tanımlanmamış!</p>';
    return;
  }
  
  // Aktif yemeklerin uyumluluk etiketlerini topla
  const activeMeals = weeks[selectedWeek - 1].days[selectedDay].meals;
  const mealTags = new Map();
  
  ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
    const mealItems = activeMeals[mealType] || [];
    mealItems.forEach(item => {
      const food = findFood(item.name);
      if (!food) return;
      
      const tags = (food.compatibilityTags && food.compatibilityTags.length) ? 
                   food.compatibilityTags.map(tag => tag.toLowerCase()) : 
                   (food.tags ? food.tags.map(tag => tag.toLowerCase()) : []);
      
      if (!mealTags.has(mealType)) mealTags.set(mealType, new Set());
      
      tags.forEach(tag => {
        mealTags.get(mealType).add(tag);
      });
    });
  });
  
  // Her kural için kontrol et ve göster
  let html = '<table class="table table-sm"><thead><tr><th>ID</th><th>Etiket 1</th><th>Etiket 2</th><th>Durum</th><th>Öğün</th></tr></thead><tbody>';
  
  compatRules.forEach(rule => {
    const keyword1 = rule.keyword1.toLowerCase();
    const keyword2List = rule.keyword2.map(k => k.toLowerCase());
    let ruleApplied = false;
    let appliedMeals = [];
    
    ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
      const tags = mealTags.get(mealType);
      if (!tags) return;
      
      const hasKeyword1 = tags.has(keyword1);
      const hasKeyword2 = keyword2List.some(k => tags.has(k));
      
      if ((rule.degree > 0 && hasKeyword1 && hasKeyword2) || 
          (rule.degree < 0 && (!hasKeyword1 || !hasKeyword2))) {
        ruleApplied = true;
        appliedMeals.push(mealType);
      }
    });
    
    const status = ruleApplied ? 
      '<span class="text-success">✓ Uygulandı</span>' : 
      '<span class="text-danger">✗ Uygulanmadı</span>';
    
    html += `<tr>
      <td>${rule.id}</td>
      <td>${rule.keyword1}</td>
      <td>${rule.keyword2.join(', ')}</td>
      <td>${status}</td>
      <td>${appliedMeals.length > 0 ? appliedMeals.join(', ') : '-'}</td>
    </tr>`;
  });
  
  html += '</tbody></table>';
  
  // Hatırlatıcı ekle
  html += `<div class="mt-2 text-info small">
    <p><strong>Not:</strong> 
      <ul>
        <li>Pozitif derece (>0) kurallar: Etiket 1 ve Etiket 2 birlikte olmalı</li>
        <li>Negatif derece (<0) kurallar: Etiket 1 ve Etiket 2 birlikte olmamalı</li>
        <li>Öğünlere yemek eklerken yemek üzerinde ilgili etiketlerin olduğundan emin olun</li>
        <li>Bir kural uygulanmıyorsa, ilgili etiketleri kontrol edin ve "Tüm Kuralları Uygula" butonunu kullanın</li>
      </ul>
    </p>
  </div>`;
  
  activeRulesDiv.innerHTML = html;
}




document.addEventListener("DOMContentLoaded", () => {
    const panel = document.getElementById("editFoodPanel");
    if (panel) {
        panel.addEventListener("click", () => {
            setTimeout(() => {
                initializeEditFoodPanel();
            }, 50);
        });
    }
});
</script>
<script>
</script>
</body>
</html>
<button class="btn btn-primary w-100 mb-1" onclick="addTemplateItem()" title="Öğe Ekle"><i class="bi bi-plus-circle"></i> Öğe Ekle</button>
<button class="btn btn-success w-100 mb-1" onclick="addMealTemplate()" title="Şablon Ekle">Şablon Ekle</button>
<button class="btn btn-warning w-100" onclick="generateRandomTemplate()" title="Rastgele Şablon Oluştur">Rastgele Şablon</button>
<button class="btn btn-primary w-100 mt-1" onclick="exportTemplatesToTXT()" title="Şablonları TXT Olarak Dışa Aktar"><i class="bi bi-download"></i> Şablonları TXT Dışa Aktar</button>
<input accept=".txt" id="importTemplatesFile" onchange="importTemplatesFromTXT(event)" style="display:none" type="file"/>
<button class="btn btn-primary w-100 mt-1" onclick="document.getElementById('importTemplatesFile').click()" title="Şablonları TXT'dan Yükle"><i class="bi bi-upload"></i> Şablonları TXT'dan Yükle</button>
</div>
</div>
</div>
</div>
</div>
<ul class="nav nav-tabs mb-2" id="weekTabs"></ul>
<ul class="nav nav-tabs mb-2" id="dayTabs"></ul>
<div class="d-flex justify-content-between mb-2">
<div class="btn-group fixed-btn-group">
<input accept=".xlsx" id="importExcelFile" onchange="importFromExcel(event)" style="display:none" type="file"/>
<button class="btn btn-success me-1" onclick="document.getElementById('importExcelFile').click()" title="Excel'den Şablon Ekle">
<i class="bi bi-upload"></i> Excel'den Şablon Ekle
    </button>
<button class="btn btn-primary me-1" onclick="addWeek()" title="Hafta Ekle"><i class="bi bi-plus-circle"></i> Hafta Ekle</button>
<button class="btn btn-danger me-1" onclick="deleteWeek()" title="Hafta Sil"><i class="bi bi-trash"></i> Hafta Sil</button>
<button class="btn btn-secondary" onclick="copyWeek()" title="Hafta Kopyala"><i class="bi bi-files"></i> Hafta Kopyala</button>
<!-- 🚀 GELİŞMİŞ PLAN OLUŞTURMA KONTROLLERI -->
<div class="btn-group me-2">
    <button class="btn btn-success dropdown-toggle" data-bs-toggle="dropdown" title="Plan Oluştur">
        <i class="bi bi-cpu"></i> Akıllı Plan
    </button>
    <div class="dropdown-menu p-3" style="min-width: 300px;">
        <h6 class="dropdown-header">🧠 Plan Algoritması</h6>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="planAlgorithm" id="useSmartPlanning" checked>
            <label class="form-check-label" for="useSmartPlanning">
                <strong>Smart Planning v2.0</strong><br>
                <small class="text-muted">Genetik algoritma, çoklu optimizasyon</small>
            </label>
        </div>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="planAlgorithm" id="useClassicPlanning">
            <label class="form-check-label" for="useClassicPlanning">
                <strong>Klasik Algoritma</strong><br>
                <small class="text-muted">Mevcut sistem (yedek)</small>
            </label>
        </div>
        <hr>
        <div class="d-grid gap-2">
            <button class="btn btn-success btn-sm" onclick="generateAdvancedPlan()" title="Gelişmiş Plan Oluştur">
                <i class="bi bi-magic"></i> Plan Oluştur
            </button>
            <button class="btn btn-outline-primary btn-sm" onclick="showPlanSettings()" title="Plan Ayarları">
                <i class="bi bi-gear"></i> Ayarlar
            </button>
        </div>
    </div>
</div>
<!-- 🌐 GITHUB YÖNETİM KONTROL PANELİ -->
<div class="btn-group me-2">
    <button class="btn btn-info dropdown-toggle" data-bs-toggle="dropdown" title="GitHub Yönetimi">
        <i class="bi bi-cloud"></i> GitHub
    </button>
    <div class="dropdown-menu p-3" style="min-width: 350px;">
        <h6 class="dropdown-header">🌐 GitHub Veri Yönetimi</h6>
        <div id="githubStatus" class="alert alert-info py-2 mb-2">
            <small><i class="bi bi-info-circle"></i> GitHub bağlantısı kontrol ediliyor...</small>
        </div>
        
        <div class="mb-2">
            <label class="form-label small">GitHub Repository</label>
            <input type="text" class="form-control form-control-sm" id="githubRepo" 
                   placeholder="kullanici/nutrition-planner" readonly>
        </div>
        
        <div class="btn-group-vertical d-grid gap-1">
            <button class="btn btn-outline-primary btn-sm" onclick="refreshGitHubData()" title="GitHub verilerini yenile">
                <i class="bi bi-arrow-clockwise"></i> Verileri Yenile
            </button>
            <button class="btn btn-outline-success btn-sm" onclick="loadPlanFromGitHub(currentPatient)" 
                    title="Mevcut hastanın planını GitHub'dan yükle" 
                    :disabled="!currentPatient">
                <i class="bi bi-cloud-download"></i> Plan Yükle
            </button>
            <button class="btn btn-outline-warning btn-sm" onclick="saveCurrentPlanToGitHub()" 
                    title="Mevcut planı GitHub'a kaydet" 
                    :disabled="!currentPatient">
                <i class="bi bi-cloud-upload"></i> Plan Kaydet
            </button>
        </div>
        
        <hr class="my-2">
        <div class="text-center">
            <small class="text-muted">
                <i class="bi bi-shield-check"></i> Güvenli GitHub API
            </small>
        </div>
    </div>
</div>
<button class="btn btn-primary me-1" id="fastPlanButton" onclick="generateFastPlan()" title="Hızlı Planla (Eski)"><i class="bi bi-lightning"></i> Hızlı Planla</button>
<button class="btn btn-secondary" disabled="" id="undoButton" title="Geri Al"><i class="bi bi-arrow-left"></i> Geri</button>
<button class="btn btn-secondary" disabled="" id="redoButton" title="İleri Al"><i class="bi bi-arrow-right"></i> İleri</button>
<button class="btn btn-primary me-1" id="exportButton" title="Tüm Verileri Dışa Aktar">
<i class="bi bi-download"></i> Tüm Verileri Dışa Aktar
                        </button>
<input accept=".json" id="importFile" onchange="importAllData(event)" style="display:none" type="file"/>
<button class="btn btn-primary me-1" onclick="document.getElementById('importFile').click()" title="Tüm Verileri İçe Aktar"><i class="bi bi-upload"></i> Tüm Verileri İçe Aktar</button>
<button class="btn btn-primary me-1" onclick="exportToTXT()" title="TXT Olarak Dışa Aktar"><i class="bi bi-download"></i> TXT Dışa Aktar</button>
<input accept=".txt" id="importTXTFile" onchange="importFromTXT(event)" style="display:none" type="file"/>
<button class="btn btn-primary me-1" onclick="document.getElementById('importTXTFile').click()" title="TXT'dan Yemek Ekle"><i class="bi bi-upload"></i> TXT'dan Ekle</button>
<button class="btn btn-secondary" onclick="clearCache()" title="Cache Temizle"><i class="bi bi-trash"></i> Cache Temizle</button>
<button class="btn btn-primary" onclick="applyAllRules()" title="Tüm Kuralları Uygula"><i class="bi bi-check-circle"></i> Tüm Kuralları Uygula</button>
</div>
</div>
<div id="meals"></div>
<div class="macro-display">
<table id="macroTotals"></table>
<!-- Grafikler calculateMacros() tarafından buraya eklenecek -->
</div>
<div class="row mb-2">
<div class="col-3">
<label class="form-label" for="bmrDisplay">BMR</label>
<input class="form-control" id="bmrDisplay" readonly="" type="number"/>
</div>
<div class="col-3">
<label class="form-label" for="targetCalories">Kalori</label>
<input class="form-control" id="targetCalories" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetProtein">Protein</label>
<input class="form-control" id="targetProtein" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetCarbs">Karb.</label>
<input class="form-control" id="targetCarbs" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetFat">Yağ</label>
<input class="form-control" id="targetFat" readonly="" type="number"/>
</div>
</div>
<table class="table macro-table">
<tbody id="macroTotals"></tbody>
</table>
</div>
<div class="p-3" id="userPanel" style="display: none;">
<h5>Kullanıcı Profili</h5>
<form id="userForm" onsubmit="handleUserFormSubmit(event)">
<div class="mb-2">
<label class="form-label" for="userName">İsim</label>
<input autocomplete="off" class="form-control" id="userName" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="userWeight">Kilo (kg)</label>
<input autocomplete="off" class="form-control" id="userWeight" min="0" required="" step="0.1" type="number"/>
</div>
<div class="mb-2">
<label class="form-label" for="userActivity">Aktivite Seviyesi (1-5)</label>
<input autocomplete="off" class="form-control" id="userActivity" max="5" min="1" required="" step="1" type="number"/>
</div>
<div class="mb-2">
<label class="form-label" for="likedFoodsInput">Sevdiği Yemekler (virgülle ayırın)</label>
<input autocomplete="off" class="form-control" id="likedFoodsInput" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="dislikedFoodsInput">Sevmediği Yemekler (virgülle ayırın)</label>
<input autocomplete="off" class="form-control" id="dislikedFoodsInput" type="text"/>
</div>
<button class="btn btn-primary" title="Profil Kaydet" type="submit">Kaydet</button>
</form>
</div>
<div class="mt-2">
<div class="input-group">
<label class="visually-hidden" for="editSearchFilterType">Arama Filtresi</label>
<select class="form-select" id="editSearchFilterType" style="width: 30%;">
<option value="name">Yemek Adı</option>
<option value="tags">Etiket</option>
<option value="role">Rol</option>
</select>
<label class="visually-hidden" for="editSearchFoodInput">Yemek Ara</label>
<input class="form-control" id="editSearchFoodInput" onkeyup="searchEditFood(this.value)" placeholder="Yemek Ara..." type="text"/>
<div class="btn-group">
<button class="btn btn-primary" onclick="addNewCategory()" title="Yeni Kategori Ekle"><i class="bi bi-plus"></i> Yeni</button>
<button class="btn btn-warning" onclick="editSelectedCategory()" title="Seçilen Kategoriyi Düzenle"><i class="bi bi-pencil"></i> Düzenle</button>
<button class="btn btn-danger" onclick="deleteSelectedCategory()" title="Seçilen Kategoriyi Sil"><i class="bi bi-trash"></i> Sil</button>
</div>
</div>
<div class="accordion" id="editCategories"></div>
</div>
</div>
<div class="edit-food-panel" id="editFoodPanel">
<h5>Yemek Düzenle</h5>
<span class="close-btn" onclick="closeEditFoodPanel()">×</span>
<form onsubmit="saveEditedFood(event)">
<input id="editFoodIndex" type="hidden"/>
<input id="editFoodOriginalName" type="hidden"/>
<div class="container-fluid">
<div class="row g-2">
<!-- Sol Sütun -->
<div class="col-6">
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodName">Yemek Adı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodName" placeholder="Örn: Kurşun Geçirmez Kahve" required="" type="text"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodCalories">Kalori:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodCalories" min="0" placeholder="0" readonly="" step="0.1" style="background-color: #f3f3f3;" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodCarbs">Karb. (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodCarbs" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodProtein">Protein (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodProtein" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodFat">Yağ (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodFat" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMaxQuantity">Maks. Katsayı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMaxQuantity" max="2" min="1" step="0.5" type="number" value="1"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMinQuantity">Min. Katsayı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMinQuantity" max="2" min="0" step="0.1" type="number" value="0.5"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodStep">Adım Değeri:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodStep" max="2" min="0.1" step="0.1" type="number" value="0.5"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodCompatibilityTags">Uyumluluk Etiketleri:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodCompatibilityTags" placeholder="Örn: domates, peynir, zeytin" type="text"/>
<small class="form-text text-muted">Bu etiketler yemek uyumluluğunu kontrol etmek için kullanılır.</small>
</div>
</div>
</div>
<!-- Sağ Sütun -->
<div class="col-6">
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodRole">Rol:</label>
<div class="col-9">
<select class="form-select form-select-sm" id="editFoodRole" required="">
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="drink">İçecek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMoveToCategory">Kategori:</label>
<div class="col-9">
<select class="form-select form-select-sm" id="editFoodMoveToCategory" required="">
<option value="">Kategori Seç</option>
<!-- Kategoriler JavaScript ile doldurulacak -->
</select>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodTags">Etiketler:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodTags" placeholder="Örn: keto, kahve, kurşun geçirmez" type="text"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Mevsim Aralığı:</label>
<div class="col-9">
<div class="d-flex align-items-center mb-2">
<input class="form-control form-control-sm" id="editFoodSeasonFrom" max="12" min="1" placeholder="Başlangıç Ayı" style="width: 80px;" type="number"/>
<span class="mx-2">-</span>
<input class="form-control form-control-sm" id="editFoodSeasonTo" max="12" min="1" placeholder="Bitiş Ayı" style="width: 80px;" type="number"/>
<span class="ms-2" id="editFoodSeasonLabel">(Ocak → Aralık)</span>
</div>
<small class="form-text text-muted">Boş bırakılırsa tüm yıl kullanılabilir.</small>
<div class="mb-2">
<label class="form-label" for="editStartMonthSlider">Başlangıç Ayı</label>
<div class="noUi-target" id="editStartMonthSlider"></div>
<div id="editStartMonthDisplay" style="margin-top: 5px; font-size: 0.9rem;"></div>
</div>
<div class="mb-2">
<label class="form-label" for="editEndMonthSlider">Bitiş Ayı</label>
<div class="noUi-target" id="editEndMonthSlider"></div>
<div id="editEndMonthDisplay" style="margin-top: 5px; font-size: 0.9rem;"></div>
</div>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodPortionFixed">Porsiyon Sabit:</label>
<div class="col-9">
<input class="form-check-input" id="editFoodPortionFixed" name="editFoodPortionFixed" type="checkbox"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMultiplier">Çarpan:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMultiplier" min="0.1" placeholder="Örn: 1" step="0.1" type="number" value="1"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Öğün Türü:</label>
<div class="col-9 d-flex gap-3">
<div class="form-check">
<input class="form-check-input" id="editMealType_breakfast" name="editMealType" type="checkbox" value="breakfast"/>
<label class="form-check-label" for="editMealType_breakfast">Kahvaltı</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editMealType_lunch" name="editMealType" type="checkbox" value="lunch"/>
<label class="form-check-label" for="editMealType_lunch">Öğle</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editMealType_dinner" name="editMealType" type="checkbox" value="dinner"/>
<label class="form-check-label" for="editMealType_dinner">Akşam</label>
</div>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Dolgu Türü:</label>
<div class="col-9 d-flex gap-3">
<div class="form-check">
<input class="form-check-input" id="editFoodFillerLunch" name="editFoodFillerLunch" type="checkbox"/>
<label class="form-check-label" for="editFoodFillerLunch">Öğlen</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editFoodFillerDinner" name="editFoodFillerDinner" type="checkbox"/>
<label class="form-check-label" for="editFoodFillerDinner">Akşam</label>
</div>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Diyet Türü:</label>
<div class="col-9 d-flex gap-3">
<div class="form-check">
<input class="form-check-input" id="editFoodKeto" name="editFoodKeto" type="checkbox"/>
<label class="form-check-label" for="editFoodKeto">Keto</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editFoodLowCarb" name="editFoodLowCarb" type="checkbox"/>
<label class="form-check-label" for="editFoodLowCarb">Low-Carb</label>
</div>
</div>
</div>
</div>
</div>
<div class="row mt-3">
<div class="col-6">
<button class="btn btn-success w-100" title="Kaydet" type="submit">Kaydet</button>
</div>
<div class="col-6">
<button class="btn btn-secondary w-100" onclick="closeEditFoodPanel()" title="İptal" type="button">İptal</button>
</div>
</div>
</div>
</form>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<!-- 🚀 GITHUB DATA MANAGER - Veri yönetimi sistemi -->
<script>
/**
 * GITHUB VERİ YÖNETİCİSİ v1.0
 * GitHub API ile veri yönetimi ve senkronizasyon
 */

class GitHubDataManager {
    constructor(config = {}) {
        this.config = {
            owner: config.owner || 'mustafakaya',        // GitHub kullanıcı adınız
            repo: config.repo || 'nutrition-planner',    // Repository adı
            branch: config.branch || 'main',             // Branch adı
            token: config.token || null,                 // GitHub Personal Access Token (isteğe bağlı)
            apiUrl: 'https://api.github.com',
            rawUrl: 'https://raw.githubusercontent.com',
            ...config
        };
        
        this.cache = new Map();
        this.lastUpdate = new Map();
        
        console.log('🐙 GitHub Data Manager başlatıldı:', this.config.owner + '/' + this.config.repo);
    }

    /**
     * GITHUB'DAN DOSYA YÜK
     */
    async loadFile(path) {
        const cacheKey = path;
        
        // Cache kontrolü (5 dakika)
        if (this.cache.has(cacheKey)) {
            const lastUpdate = this.lastUpdate.get(cacheKey);
            if (Date.now() - lastUpdate < 5 * 60 * 1000) {
                console.log(`📋 Cache'den yüklendi: ${path}`);
                return this.cache.get(cacheKey);
            }
        }

        try {
            const url = `${this.config.rawUrl}/${this.config.owner}/${this.config.repo}/${this.config.branch}/${path}`;
            console.log(`🌐 GitHub'dan yükleniyor: ${path}`);
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            // Cache'e kaydet
            this.cache.set(cacheKey, data);
            this.lastUpdate.set(cacheKey, Date.now());
            
            console.log(`✅ Başarıyla yüklendi: ${path}`);
            return data;
            
        } catch (error) {
            console.error(`❌ Dosya yükleme hatası (${path}):`, error);
            
            // Cache'de varsa onu döndür
            if (this.cache.has(cacheKey)) {
                console.log(`⚠️ Cache'den eski veri döndürülüyor: ${path}`);
                return this.cache.get(cacheKey);
            }
            
            throw error;
        }
    }

    /**
     * YEMEK VERİTABANI YÜK
     */
    async loadFoods() {
        try {
            const foodsData = await this.loadFile('data/foods.json');
            console.log(`🍽️ ${foodsData.categories?.length || 0} kategori yüklendi`);
            return foodsData.categories || [];
        } catch (error) {
            console.error('❌ Yemek verisi yükleme hatası:', error);
            return this.getDefaultFoods();
        }
    }

    /**
     * KURALLAR YÜK
     */
    async loadRules() {
        try {
            const rulesData = await this.loadFile('data/rules.json');
            console.log(`⚙️ ${rulesData.systemRules?.length || 0} kural yüklendi`);
            return rulesData.systemRules || [];
        } catch (error) {
            console.error('❌ Kural verisi yükleme hatası:', error);
            return this.getDefaultRules();
        }
    }

    /**
     * SİSTEM AYARLARI YÜK
     */
    async loadConfig() {
        try {
            const configData = await this.loadFile('data/config.json');
            console.log(`🔧 Sistem ayarları yüklendi (v${configData.version})`);
            return configData;
        } catch (error) {
            console.error('❌ Config yükleme hatası:', error);
            return this.getDefaultConfig();
        }
    }

    /**
     * KULLANICI VERİSİ YÜK (LocalStorage'dan)
     */
    async loadUser(userId) {
        try {
            // Önce localStorage'dan dene
            const localUserData = localStorage.getItem(`user_${userId}`);
            if (localUserData) {
                const userData = JSON.parse(localUserData);
                console.log(`👤 Kullanıcı localStorage'dan yüklendi: ${userId}`);
                return userData;
            }

            // Yoksa varsayılan oluştur
            const newUser = this.createDefaultUser(userId);
            
            // LocalStorage'a kaydet
            await this.saveUser(newUser);
            console.log(`👤 Yeni kullanıcı oluşturuldu: ${userId}`);
            return newUser;

        } catch (error) {
            console.error(`❌ Kullanıcı yükleme hatası (${userId}):`, error);
            return this.createDefaultUser(userId);
        }
    }

    /**
     * KULLANICI VERİSİ KAYDET
     */
    async saveUser(userData) {
        try {
            localStorage.setItem(`user_${userData.userId}`, JSON.stringify(userData));
            console.log(`💾 Kullanıcı kaydedildi: ${userData.userId}`);
            return true;
        } catch (error) {
            console.error('❌ Kullanıcı kaydetme hatası:', error);
            return false;
        }
    }

    /**
     * VERİ İSTATİSTİKLERİ
     */
    async getStats() {
        try {
            const [foods, rules, config] = await Promise.all([
                this.loadFoods(),
                this.loadRules(),
                this.loadConfig()
            ]);

            const totalFoods = foods.reduce((sum, cat) => sum + (cat.items?.length || 0), 0);

            return {
                repository: `${this.config.owner}/${this.config.repo}`,
                totalCategories: foods.length,
                totalFoods: totalFoods,
                totalRules: rules.length,
                cacheSize: this.cache.size,
                version: config.version,
                lastSync: new Date().toISOString()
            };
        } catch (error) {
            console.error('❌ İstatistik alma hatası:', error);
            return { error: error.message };
        }
    }

    // VARSAYILAN DEĞERLER
    getDefaultFoods() {
        return [
            {
                name: "KAHVALTI",
                items: [
                    {
                        name: "Menemen",
                        calories: 180,
                        protein: 12,
                        carbs: 8,
                        fat: 12,
                        maxQuantity: 2,
                        minQuantity: 0.5,
                        tags: ["yumurta", "sebze"],
                        role: "mainDish",
                        mealType: ["breakfast"],
                        keto: false,
                        lowcarb: true
                    }
                ]
            }
        ];
    }

    getDefaultRules() {
        return [
            {
                id: "rule_001",
                type: "maxRoleCount",
                mealType: "lunch",
                role: "mainDish",
                count: 1,
                scope: "meal",
                active: true
            }
        ];
    }

    getDefaultConfig() {
        return {
            version: "1.0.0",
            settings: {
                planningAlgorithm: "smart_v2",
                autoSave: true
            }
        };
    }

    createDefaultUser(userId) {
        return {
            userId: userId,
            profile: {
                name: "Varsayılan Kullanıcı",
                age: 30,
                gender: "male",
                height: 175,
                weight: 70,
                activityLevel: 3
            },
            preferences: {
                dietType: "keto",
                likedFoods: [],
                dislikedFoods: [],
                allergies: []
            },
            targets: {
                calories: 2000,
                protein: 150,
                carbs: 50,
                fat: 150
            },
            createdAt: new Date().toISOString()
        };
    }

    clearCache() {
        this.cache.clear();
        this.lastUpdate.clear();
        console.log('🗑️ GitHub cache temizlendi');
    }
}

// 🌐 GLOBAL GITHUB DATA MANAGER INSTANCE
const githubDataManager = new GitHubDataManager({
    owner: 'mustafakaya',           // 👈 BURAYA GITHUB KULLANICI ADINIZI YAZIN
    repo: 'nutrition-planner'       // 👈 BURAYA REPOSITORY ADINIZI YAZIN
});

// GitHub bağlantı testi
(async () => {
    try {
        console.log('🔄 GitHub bağlantı testi başlatılıyor...');
        const stats = await githubDataManager.getStats();
        console.log('📊 GitHub İstatistikleri:', stats);
    } catch (error) {
        console.warn('⚠️ GitHub bağlantı testi başarısız - Offline modda çalışılacak:', error.message);
    }
})();

</script>

<script>

const roleOrder = {
    "soup": 1,
    "mainDish": 2,
    "sideDish": 3,
    "bread": 4,
    "dessert": 5,
    "fruit": 6,
    "snack": 7,
    "drink": 8,
    "supplement": 9,
    "bilinmiyor": 10
};

let globalTargetCalories = 0;
let globalTargetProtein = 0;
let globalTargetFat = 0;
let globalTargetCarbs = 0;

// 🚀 GELIŞMIŞ PLAN ALGORİTMASI - Smart Planning Engine
class SmartPlanningEngine {
    constructor(config = {}) {
        this.config = {
            populationSize: 30,           // Performans için azaltıldı
            maxGenerations: 50,           // Web için optimize edildi
            mutationRate: 0.15,
            crossoverRate: 0.7,
            elitismRate: 0.1,
            
            weights: {
                macroAccuracy: 0.40,      // Makro hedefleri en önemli
                varietyScore: 0.25,       // Çeşitlilik
                ruleCompliance: 0.20,     // Kural uyumu
                seasonality: 0.08,        // Mevsimsellik
                compatibility: 0.07       // Uyumluluk
            },
            
            tolerances: {
                calories: 0.08,           // ±8% kalori toleransı
                protein: 0.12,           // ±12% protein toleransı
                carbs: 0.20,             // ±20% karbonhidrat toleransı
                fat: 0.15                // ±15% yağ toleransı
            },
            
            ...config
        };
    }

    /**
     * GELİŞMİŞ MAKRO HESAPLAMA
     * Daha doğru formüller ve kişiselleştirme
     */
    calculatePersonalizedTargets(userProfile) {
        const { weight, height, age, gender, activityLevel, dietType, goal } = userProfile;
        
        // Mifflin-St Jeor Equation (daha doğru BMR)
        let bmr;
        if (gender === 'male') {
            bmr = (10 * weight) + (6.25 * height) - (5 * age) + 5;
        } else {
            bmr = (10 * weight) + (6.25 * height) - (5 * age) - 161;
        }
        
        // Gelişmiş aktivite çarpanları
        const activityMultipliers = {
            1: 1.2,   // Sedentary
            2: 1.375, // Light
            3: 1.55,  // Moderate
            4: 1.725, // Active
            5: 1.9    // Very Active
        };
        
        const tdee = bmr * (activityMultipliers[activityLevel] || 1.55);
        
        // Hedef ayarlaması
        let targetCalories = tdee;
        if (goal === 'lose') {
            targetCalories = tdee * 0.85;  // %15 açık (sürdürülebilir)
        } else if (goal === 'gain') {
            targetCalories = tdee * 1.1;   // %10 fazla
        }
        
        // Diyet türüne göre makro dağılımı
        const macroRatios = this.getMacroRatiosByDiet(dietType);
        
        const targetProtein = (targetCalories * macroRatios.protein) / 4;
        const targetCarbs = (targetCalories * macroRatios.carbs) / 4;
        const targetFat = (targetCalories * macroRatios.fat) / 9;
        
        return {
            calories: Math.round(targetCalories),
            protein: Math.round(targetProtein),
            carbs: Math.round(targetCarbs),
            fat: Math.round(targetFat),
            bmr: Math.round(bmr),
            tdee: Math.round(tdee)
        };
    }

    getMacroRatiosByDiet(dietType) {
        const ratios = {
            'keto': { protein: 0.25, carbs: 0.05, fat: 0.70 },
            'lowcarb': { protein: 0.30, carbs: 0.15, fat: 0.55 },
            'balanced': { protein: 0.25, carbs: 0.45, fat: 0.30 }
        };
        return ratios[dietType] || ratios['keto'];
    }

    /**
     * 🌐 GITHUB ENTEGRELİ AKILLI PLAN OLUŞTURMA
     * GitHub'dan veri yükleyerek optimize edilmiş plan oluşturma
     */
    async generateSmartPlan(settings) {
        console.log('🚀 GitHub entegreli Smart Planning Engine başlatılıyor...');
        console.log('Hedefler:', settings);

        try {
            // 🌐 GitHub'dan veri yükle
            showNotification('🔄 GitHub\'dan veriler yükleniyor...', 'info');
            
            const [githubFoods, githubRules, githubConfig] = await Promise.all([
                githubDataManager.loadFoods().catch(err => {
                    console.warn('⚠️ GitHub foods yüklenemedi, mevcut veri kullanılacak:', err);
                    return categories;
                }),
                githubDataManager.loadRules().catch(err => {
                    console.warn('⚠️ GitHub rules yüklenemedi, mevcut kurallar kullanılacak:', err);
                    return rules;
                }),
                githubDataManager.loadConfig().catch(err => {
                    console.warn('⚠️ GitHub config yüklenemedi, varsayılan ayarlar kullanılacak:', err);
                    return null;
                })
            ]);

            // Verileri güncelle
            if (githubFoods && githubFoods.length > 0) {
                categories = githubFoods;
                console.log(`📊 ${githubFoods.length} kategori GitHub'dan yüklendi`);
                showNotification(`✅ ${githubFoods.length} kategori GitHub'dan yüklendi`, 'success');
            }

            if (githubRules && githubRules.length > 0) {
                rules = githubRules;
                console.log(`⚙️ ${githubRules.length} kural GitHub'dan yüklendi`);
            }

            // Kullanıcı profili oluştur
            const patientData = currentPatient ? 
                await githubDataManager.loadUser(currentPatient) : 
                await githubDataManager.loadUser('default');
        
            const userProfile = {
                weight: patientData.profile?.weight || 70,
                height: patientData.profile?.height || 175,
                age: patientData.profile?.age || 30,
                gender: patientData.profile?.gender || 'male',
                activityLevel: patientData.profile?.activityLevel || 3,
                dietType: dietMode,
                goal: patientData.profile?.goal || 'maintain'
            };

            showNotification('✅ GitHub veriler yüklendi, plan hesaplanıyor...', 'info');

        } catch (error) {
            console.error('❌ GitHub veri yükleme hatası:', error);
            showNotification('⚠️ GitHub hatası, offline verilerle devam ediliyor...', 'warning');

            // Offline fallback
            const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
            
            const userProfile = {
                weight: patientData.weight || 70,
                height: patientData.height || 175,
                age: patientData.age || 30,
                gender: patientData.gender || 'male',
                activityLevel: patientData.activity || 3,
                dietType: dietMode,
                goal: patientData.goal || 'maintain'
            };
        }

        // Hedefleri yeniden hesapla
        const recalculatedTargets = this.calculatePersonalizedTargets(userProfile);
        
        // Global değişkenleri güncelle
        globalTargetCalories = recalculatedTargets.calories;
        globalTargetProtein = recalculatedTargets.protein;
        globalTargetCarbs = recalculatedTargets.carbs;
        globalTargetFat = recalculatedTargets.fat;

        // UI'ı güncelle
        document.getElementById('targetCalories').value = recalculatedTargets.calories;
        document.getElementById('targetProtein').value = recalculatedTargets.protein;
        document.getElementById('targetCarbs').value = recalculatedTargets.carbs;
        document.getElementById('targetFat').value = recalculatedTargets.fat;

        console.log('🎯 Yeniden hesaplanan hedefler:', recalculatedTargets);

        // Mevcut yemek veritabanını hazırla
        const availableFoods = this.prepareAvailableFoods();
        
        // Her hafta için plan oluştur
        const planResults = [];
        
        for (let weekIndex = 0; weekIndex < weeks.length; weekIndex++) {
            console.log(`📅 Hafta ${weekIndex + 1} planlanıyor...`);
            
            const weekPlan = await this.generateWeekPlan(
                recalculatedTargets, 
                availableFoods, 
                userProfile,
                weekIndex
            );
            
            // Planı weeks dizisine uygula
            this.applyWeekPlan(weekPlan, weekIndex);
            planResults.push(weekPlan);
        }

        // Sonuçları göster
        renderWeeks();
        updateMacroDisplay();
        
        console.log('✅ GitHub entegreli Smart Planning tamamlandı!');
        showNotification('🎉 GitHub entegreli akıllı plan oluşturuldu!', 'success');
        
        return planResults;
    }

    prepareAvailableFoods() {
        const foods = [];
        
        for (const category of categories) {
            for (const food of category.items) {
                if (food.calories > 0) {
                    // Diyet uyumluluğunu kontrol et
                    const isDietCompatible = this.checkDietCompatibility(food);
                    if (isDietCompatible) {
                        foods.push({
                            ...food,
                            category: category.name
                        });
                    }
                }
            }
        }
        
        console.log(`📊 ${foods.length} uygun yemek bulundu`);
        return foods;
    }

    checkDietCompatibility(food) {
        if (dietMode === 'keto') {
            return food.keto === true;
        } else if (dietMode === 'lowcarb') {
            return food.lowcarb === true || food.keto === true;
        }
        return true;
    }

    async generateWeekPlan(targets, availableFoods, userProfile, weekIndex) {
        const weekPlan = {
            weekIndex,
            days: {},
            totalScore: 0
        };

        const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
        
        for (const day of days) {
            const dayPlan = await this.generateDayPlan(
                targets, 
                availableFoods, 
                userProfile, 
                day
            );
            weekPlan.days[day] = dayPlan;
        }

        // Hafta skorunu hesapla
        weekPlan.totalScore = this.calculateWeekScore(weekPlan, targets);
        
        return weekPlan;
    }

    async generateDayPlan(targets, availableFoods, userProfile, dayName) {
        const dayTargets = {
            calories: targets.calories,
            protein: targets.protein,
            carbs: targets.carbs,
            fat: targets.fat
        };

        // Öğün dağılımı (geliştirilebilir)
        const mealRatios = {
            breakfast: 0.25,
            lunch: 0.40,
            dinner: 0.35
        };

        const dayPlan = {
            meals: {
                breakfast: [],
                lunch: [],
                dinner: []
            }
        };

        // Her öğün için plan oluştur
        for (const [mealType, ratio] of Object.entries(mealRatios)) {
            const mealTargets = {
                calories: dayTargets.calories * ratio,
                protein: dayTargets.protein * ratio,
                carbs: dayTargets.carbs * ratio,
                fat: dayTargets.fat * ratio
            };

            const mealPlan = this.generateMealPlan(
                mealTargets, 
                availableFoods, 
                mealType
            );
            
            dayPlan.meals[mealType] = mealPlan;
        }

        return dayPlan;
    }

    generateMealPlan(mealTargets, availableFoods, mealType) {
        // Öğün türüne uygun yemekleri filtrele
        const suitableFoods = availableFoods.filter(food => {
            const mealTypes = Array.isArray(food.mealType) ? food.mealType : food.mealType.split(',');
            return mealTypes.includes(mealType);
        });

        // Role göre gruplama
        const foodsByRole = this.groupFoodsByRole(suitableFoods);
        
        const meal = [];
        let remainingCalories = mealTargets.calories;

        // Ana yemek ekle (öncelik)
        if (foodsByRole.mainDish && foodsByRole.mainDish.length > 0) {
            const mainDish = this.selectRandomFood(foodsByRole.mainDish);
            const quantity = this.calculateOptimalQuantity(mainDish, remainingCalories * 0.6);
            
            meal.push({
                name: mainDish.name,
                quantity: quantity
            });
            
            remainingCalories -= mainDish.calories * quantity;
        }

        // Yan yemek ekle
        if (foodsByRole.sideDish && foodsByRole.sideDish.length > 0 && remainingCalories > 100) {
            const sideDish = this.selectRandomFood(foodsByRole.sideDish);
            const quantity = this.calculateOptimalQuantity(sideDish, remainingCalories * 0.4);
            
            meal.push({
                name: sideDish.name,
                quantity: quantity
            });
            
            remainingCalories -= sideDish.calories * quantity;
        }

        // Ek yemekler (çorba, ekmek, vb.)
        const additionalRoles = ['soup', 'bread', 'supplement'];
        for (const role of additionalRoles) {
            if (foodsByRole[role] && foodsByRole[role].length > 0 && remainingCalories > 50) {
                // %30 ihtimalle ekle
                if (Math.random() < 0.3) {
                    const food = this.selectRandomFood(foodsByRole[role]);
                    const quantity = this.calculateOptimalQuantity(food, Math.min(remainingCalories, food.calories * 2));
                    
                    meal.push({
                        name: food.name,
                        quantity: quantity
                    });
                    
                    remainingCalories -= food.calories * quantity;
                }
            }
        }

        return meal;
    }

    groupFoodsByRole(foods) {
        const grouped = {};
        
        for (const food of foods) {
            const role = food.role || 'other';
            if (!grouped[role]) {
                grouped[role] = [];
            }
            grouped[role].push(food);
        }
        
        return grouped;
    }

    selectRandomFood(foods) {
        return foods[Math.floor(Math.random() * foods.length)];
    }

    calculateOptimalQuantity(food, targetCalories) {
        let quantity = targetCalories / food.calories;
        
        // Min-max sınırları
        quantity = Math.max(food.minQuantity || 0.1, quantity);
        quantity = Math.min(food.maxQuantity || 3.0, quantity);
        
        return Math.round(quantity * 100) / 100;
    }

    calculateWeekScore(weekPlan, targets) {
        // Basit skor hesaplama (geliştirilebilir)
        let totalCalories = 0;
        let totalProtein = 0;
        let totalCarbs = 0;
        let totalFat = 0;

        for (const day of Object.values(weekPlan.days)) {
            for (const meal of Object.values(day.meals)) {
                for (const item of meal) {
                    const food = this.findFoodByName(item.name);
                    if (food) {
                        totalCalories += food.calories * item.quantity;
                        totalProtein += food.protein * item.quantity;
                        totalCarbs += food.carbs * item.quantity;
                        totalFat += food.fat * item.quantity;
                    }
                }
            }
        }

        // Haftalık hedefler (7 gün)
        const weeklyTargets = {
            calories: targets.calories * 7,
            protein: targets.protein * 7,
            carbs: targets.carbs * 7,
            fat: targets.fat * 7
        };

        // Doğruluk skoru
        const calorieDiff = Math.abs(weeklyTargets.calories - totalCalories) / weeklyTargets.calories;
        const proteinDiff = Math.abs(weeklyTargets.protein - totalProtein) / weeklyTargets.protein;
        
        return Math.max(0, 1 - (calorieDiff + proteinDiff) / 2);
    }

    findFoodByName(name) {
        for (const category of categories) {
            const food = category.items.find(f => f.name === name);
            if (food) return food;
        }
        return null;
    }

    applyWeekPlan(weekPlan, weekIndex) {
        if (!weeks[weekIndex]) return;
        
        for (const [dayName, dayPlan] of Object.entries(weekPlan.days)) {
            if (weeks[weekIndex].days[dayName]) {
                weeks[weekIndex].days[dayName].meals = dayPlan.meals;
            }
        }
    }
}

/**
 * 💾 MEVCUT PLANI GITHUB'A KAYDET
 * Aktif planı GitHub repository'sine kaydeder
 */
async function saveCurrentPlanToGitHub() {
    if (!currentPatient) {
        throw new Error('Hasta seçilmedi');
    }
    
    if (!githubDataManager) {
        throw new Error('GitHub bağlantısı kurulamadı');
    }
    
    try {
        console.log('💾 Mevcut plan GitHub\'a kaydediliyor...');
        
        // Mevcut plan verilerini topla
        const planData = {
            patient: currentPatient,
            weeks: weeks,
            settings: {
                targetCalories: globalTargetCalories,
                targetProtein: globalTargetProtein,
                targetCarbs: globalTargetCarbs,
                targetFat: globalTargetFat,
                dietMode: dietMode
            },
            timestamp: new Date().toISOString(),
            planType: 'smart-planning',
            version: '2.0'
        };
        
        // GitHub'a kaydet
        await githubDataManager.saveUserPlan(currentPatient, planData);
        
        console.log('✅ Plan başarıyla GitHub\'a kaydedildi');
        return true;
        
    } catch (error) {
        console.error('❌ GitHub plan kaydetme hatası:', error);
        throw error;
    }
}

/**
 * 📥 GITHUB'DAN PLAN YÜKLEMESİ
 * GitHub repository'sinden plan yükler
 */
async function loadPlanFromGitHub(patientId) {
    if (!githubDataManager) {
        throw new Error('GitHub bağlantısı kurulamadı');
    }
    
    try {
        console.log(`📥 ${patientId} hastasının planı GitHub'dan yükleniyor...`);
        
        const planData = await githubDataManager.loadUserPlan(patientId);
        
        if (planData) {
            // Plan verilerini uygula
            weeks = planData.weeks || [];
            globalTargetCalories = planData.settings?.targetCalories || 2000;
            globalTargetProtein = planData.settings?.targetProtein || 150;
            globalTargetCarbs = planData.settings?.targetCarbs || 250;
            globalTargetFat = planData.settings?.targetFat || 65;
            dietMode = planData.settings?.dietMode || 'balanced';
            
            // UI'ı güncelle
            renderWeeks();
            updateMacroDisplay();
            
            console.log('✅ Plan başarıyla GitHub\'dan yüklendi');
            showNotification('📥 Plan GitHub\'dan yüklendi!', 'success');
            return true;
        } else {
            console.log('📂 GitHub\'da plan bulunamadı');
            return false;
        }
        
    } catch (error) {
        console.error('❌ GitHub plan yükleme hatası:', error);
        throw error;
    }
}

/**
 * 🔄 GITHUB VERİLERİNİ YENİLE
 * GitHub'dan tüm verileri yeniden yükler
 */
async function refreshGitHubData() {
    if (!githubDataManager) {
        showNotification('⚠️ GitHub bağlantısı kurulamadı', 'warning');
        return;
    }
    
    try {
        showNotification('🔄 GitHub verileri yenileniyor...', 'info');
        
        // Cache'i temizle
        githubDataManager.clearCache();
        
        // Verileri yeniden yükle
        const [foods, rules, config] = await Promise.all([
            githubDataManager.loadFoods(),
            githubDataManager.loadRules(),
            githubDataManager.loadConfig()
        ]);
        
        // Global değişkenleri güncelle
        if (foods && foods.length > 0) {
            categories = foods;
            console.log(`📊 ${foods.length} kategori güncellendi`);
        }
        
        if (rules && rules.length > 0) {
            rules = rules;
            console.log(`⚙️ ${rules.length} kural güncellendi`);
        }
        
        showNotification('✅ GitHub verileri başarıyla yenilendi!', 'success');
        
    } catch (error) {
        console.error('❌ GitHub veri yenileme hatası:', error);
        showNotification('⚠️ GitHub verileri yenilenemedi: ' + error.message, 'error');
    }
}

/**
 * 🌐 GITHUB DURUM KONTROLÜ VE BAŞLATMA
 * GitHub bağlantısını kontrol eder ve UI'ı günceller
 */
async function initializeGitHub() {
    console.log('🌐 GitHub bağlantısı kontrol ediliyor...');
    
    const statusElement = document.getElementById('githubStatus');
    const repoElement = document.getElementById('githubRepo');
    
    try {
        // GitHub repository bilgilerini göster
        if (repoElement) {
            repoElement.value = `${githubDataManager.username}/${githubDataManager.repository}`;
        }
        
        // Bağlantı testi
        const testResult = await githubDataManager.testConnection();
        
        if (testResult.success) {
            if (statusElement) {
                statusElement.className = 'alert alert-success py-2 mb-2';
                statusElement.innerHTML = `
                    <small><i class="bi bi-check-circle"></i> GitHub bağlantısı aktif</small>
                `;
            }
            console.log('✅ GitHub bağlantısı başarılı');
        } else {
            throw new Error(testResult.error);
        }
        
    } catch (error) {
        console.error('❌ GitHub bağlantı hatası:', error);
        
        if (statusElement) {
            statusElement.className = 'alert alert-warning py-2 mb-2';
            statusElement.innerHTML = `
                <small><i class="bi bi-exclamation-triangle"></i> GitHub offline - Yerel mod</small>
            `;
        }
    }
}

/**
 * 🔄 SAYFA YÜKLENİRKEN GITHUB'I BAŞLAT
 */
document.addEventListener('DOMContentLoaded', function() {
    // GitHub'ı başlat
    if (typeof githubDataManager !== 'undefined') {
        setTimeout(() => {
            initializeGitHub();
        }, 1000);
    }
    
    console.log('📱 GitHub entegreli sistem hazır!');
});

// Global Smart Planning Engine instance
const smartPlanner = new SmartPlanningEngine();

document.addEventListener('DOMContentLoaded', () => {
    // Checkbox'lar için başlangıç durumu
    toggleInput('freqNameCheck', 'freqName');
    toggleInput('freqTagCheck', 'freqTag');
    toggleInput('freqRoleCheck', 'freqRole');
    toggleInput('freqCatCheck', 'freqCat');

    // freqScope değiştiğinde freqMeal görünürlüğünü güncelle
    const freqScope = document.getElementById('freqScope');
    const freqMeal = document.getElementById('freqMeal');
    freqScope.addEventListener('change', () => {
        freqMeal.style.display = freqScope.value === 'meal' ? 'inline-block' : 'none';
    });
    freqMeal.style.display = freqScope.value === 'meal' ? 'inline-block' : 'none';
});




        document.addEventListener("DOMContentLoaded", function() {
            if (initialCategories && initialCategories.length > 0) {
        categories = initialCategories;
    }

    document.querySelectorAll("select[id^='editMoveToCategory']").forEach(function(categorySelect) {
        categorySelect.innerHTML = '';
        const defaultOption = document.createElement("option");
defaultOption.value = "";
defaultOption.textContent = "Kategori Seç";
categorySelect.appendChild(defaultOption);
        categories.forEach(function(cat, index) {
            const option = document.createElement("option");
            option.value = cat.name;
            option.textContent = cat.name;
            if (index === 0) option.selected = true;
            categorySelect.appendChild(option);
        });
    });
        
    // BU KODU BURAYA EKLE:
    if (initialCategories && initialCategories.length > 0) {
        categories = initialCategories;
    }
// Tüm kategori dropdownlarını doldur (birden fazla olabilir)
document.querySelectorAll("select[id^='editMoveToCategory']").forEach(categorySelect => {
    categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
    categories.forEach(cat => {
        const option = document.createElement("option");
        option.value = cat.name;
        option.textContent = cat.name;
        categorySelect.appendChild(option);
    });
});

    const categorySelect = document.getElementById("editMoveToCategory");
    if (categorySelect && categories.length > 0) {
        categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
        categories.forEach(cat => {
            const option = document.createElement("option");
            option.value = cat.name;
            option.textContent = cat.name;
            categorySelect.appendChild(option);
        });
    }




    searchEditFood('');
});

let categories = [];
const initialCategories = [
    {
        name: "KAHVALTI",
        items: [
            { name: "Kurşun Geçirmez Kahve", calories: 200, protein: 0, carbs: 0, fat: 22, maxQuantity: 1, minQuantity: 1, tags: ["keto", "içecek"], role: "drink", mealType: "breakfast", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "ÖĞLEN",
        items: [
            { name: "Yumurtalı Ispanak Kavurma", calories: 337, protein: 23, carbs: 3, fat: 26, maxQuantity: 1.5, minQuantity: 0.5, tags: ["keto", "yumurta"], role: "mainDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Keto Tost", calories: 250, protein: 15, carbs: 5, fat: 18, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "ekmek"], role: "mainDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Sabah Yeşillikleri", calories: 50, protein: 2, carbs: 5, fat: 3, maxQuantity: 2, minQuantity: 0.5, tags: ["keto", "salata"], role: "sideDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "AKŞAM",
        items: [
            { name: "Köfte", calories: 250, protein: 20, carbs: 0, fat: 18, maxQuantity: 2, minQuantity: 1, tags: ["keto", "et"], role: "mainDish", mealType: "dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Tavuk Çorbası", calories: 114, protein: 10, carbs: 5, fat: 6, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "çorba"], role: "soup", mealType: "dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "DİĞER",
        items: [
            { name: "Zeytinyağı", calories: 120, protein: 0, carbs: 0, fat: 14, maxQuantity: 2, minQuantity: 0.5, tags: ["keto", "yağ"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true },
            { name: "Keten Tohumu", calories: 44, protein: 2, carbs: 0, fat: 4, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "tohum"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true },
            { name: "Kollajen", calories: 40, protein: 10, carbs: 0, fat: 0, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "ek"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true }
        ]
    },
    {
        name: "KURUYEMİŞLER",
        items: [
            { name: "Badem", calories: 160, protein: 6, carbs: 6, fat: 14, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "kuruyemiş"], role: "snack", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Badem?", calories: 160, protein: 6, carbs: 6, fat: 14, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "kuruyemiş"], role: "snack", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }

        ]
    },
    {
        name: "TATLILAR",
        items: [
            { name: "Bitter Çikolata", calories: 150, protein: 2, carbs: 8, fat: 12, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "tatlı"], role: "dessert", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    }
];
categories = initialCategories;
        let weeks = [];
        let selectedWeek = 1;
        let selectedDay = "monday";
        let currentPatient = null;
        let dietMode = "keto";
        let rules = [];
        rules.push({ type: 'maxRoleCount', mealType: 'lunch', role: 'mainDish', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'dinner', role: 'mainDish', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'lunch', role: 'soup', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'dinner', role: 'soup', count: 1 });

        let compatibilityTable = [];

        const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
        const roles = [
            { role: "soup", active: false },
            { role: "mainDish", active: true },
            { role: "sideDish", active: true },
            { role: "drink", active: true },
            { role: "dessert", active: false },
            { role: "fruit", active: false },
            { role: "bread", active: false },
            { role: "snack", active: false },
            { role: "supplement", active: false }
        ];

        function initializeWeeks() {
            if (weeks.length === 0) {
                weeks.push({
                    days: {
                        monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
                    }
                });
            }
        }
// Şablonlar ve benzersizlik kontrolü
let mealTemplates = [];
let lunchCounter = 1;
let dinnerCounter = 1;
const existingMeals = new Set();

function openDependOnRuleForm() {
    console.log("openDependOnRuleForm çağrıldı");

    // Formu bul
    const dependOnForm = document.getElementById('dependOnRuleForm');
    if (!dependOnForm) {
        console.error("dependOnRuleForm bulunamadı!");
        showNotification("Bağımlı Olsun formu bulunamadı!", "error");
        return;
    }

    // Tüm diğer formları gizle
    const forms = [
        "editRuleForm",
        "frequencyRuleForm",
        "compatibilityRuleForm",
        "categoryLockRuleForm",
        "pairRuleForm"
    ];
    forms.forEach(formId => {
        const form = document.getElementById(formId);
        if (form) {
            form.style.display = "none";
        }
    });

    // Bağımlı Olsun formunu göster
    dependOnForm.style.display = "block";

    // Formu sıfırla
    const formElement = dependOnForm.querySelector('form');
    if (formElement) {
        formElement.reset();
        document.getElementById('dependOnFood').value = '';
        document.getElementById('dependOnRequiredFood').value = '';
        document.getElementById('dependOnScope').value = 'meal';
    } else {
        console.error("dependOnRuleForm içindeki form elementi bulunamadı!");
    }

    // Kurallar accordion'unu açık tut
    const rulesCollapse = document.getElementById('rulesCollapse');
    if (rulesCollapse && !rulesCollapse.classList.contains('show')) {
        const rulesButton = document.querySelector('#rulesHeading button');
        if (rulesButton) {
            rulesButton.click(); // Accordion'u aç
        }
    }

    console.log("Bağımlı Olsun formu açıldı");
}

function openCompatibilityRuleForm() {
    console.log("Uyumluluk Kuralı Formu açılıyor...");
    const form = document.getElementById("compatibilityRuleForm");
    const otherForms = [
        "frequencyRuleForm",
        "dependOnRuleForm",
        "categoryLockRuleForm",
        "pairRuleForm",
        "editRuleForm"
    ];

    otherForms.forEach(formId => {
        const otherForm = document.getElementById(formId);
        if (otherForm) {
            otherForm.style.display = "none";
        }
    });

    if (form) {
        form.style.display = "block";
        document.getElementById("compatKeyword1").value = "";
        document.getElementById("compatKeyword2").value = "";
        document.getElementById("compatDegree").value = "0";
        document.getElementById("compatConjunction").value = "or";
    } else {
        console.error("compatibilityRuleForm bulunamadı!");
    }

    // Akordiyonu aç
    const rulesCollapse = document.getElementById("rulesCollapse");
    if (rulesCollapse) {
        rulesCollapse.classList.add("show");
    }
}

document.addEventListener("DOMContentLoaded", () => {
    const compatButton = document.querySelector('button[onclick="openCompatibilityRuleForm()"]');
    if (compatButton) {
        compatButton.addEventListener("click", openCompatibilityRuleForm);
    } else {
        console.error("Uyumluluk Kuralı Ekle butonu bulunamadı!");
    }
});

function addToCategoriesIfNew(foodName, line, mealType) {
    let found = false;
    for (const category of categories) {
        if (category.items.some(item => item.name === foodName)) {
            found = true;
            break;
        }
    }
    if (!found) {
        const macroMatch = line.match(/(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)/);
        const newFood = {
            name: foodName,
            calories: macroMatch ? parseFloat(macroMatch[1]) : 0,
            protein: macroMatch ? parseFloat(macroMatch[3]) : 0,
            carbs: macroMatch ? parseFloat(macroMatch[2]) : 0,
            fat: macroMatch ? parseFloat(macroMatch[4]) : 0,
            maxQuantity: 2,
            minQuantity: 0.5,
            tags: ["keto"], // Varsayılan, özelleştirilebilir
            role: inferRole(foodName),
            mealType: [mealType],
            keto: true,
            lowcarb: true,
            fillerLunch: false,
            fillerDinner: false,
            step: 0.5,
            category: "Yeni Yemekler"
        };
        const newCategory = categories.find(cat => cat.name === "Yeni Yemekler") || { name: "Yeni Yemekler", items: [] };
        newCategory.items.push(newFood);
        if (!categories.some(cat => cat.name === "Yeni Yemekler")) categories.push(newCategory);
        console.log(`Yeni yemek eklendi: ${foodName}`, newFood);
    }
}


       

function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        function switchMode(mode) {
    document.getElementById('adminPanel').style.display = mode === 'admin' ? 'block' : 'none';
    document.getElementById('userPanel').style.display = mode === 'user' ? 'block' : 'none';
}

function updateDietMode(mode) {
    dietMode = mode;
    // --- SEÇİLİ HAFTANIN MODUNU GÜNCELLE ---
    if (weeks[selectedWeek - 1]) {
        weeks[selectedWeek - 1].dietMode = mode;
    }
    const carbMultiplier = mode === 'keto' ? 0.3 : 0.6;
    const proteinMultiplier = 0.8;
    const fatMultiplier = mode === 'keto' ? 1.2 : 1.0;
    document.getElementById('carbMultiplier').value = carbMultiplier;
    document.getElementById('proteinMultiplier').value = proteinMultiplier;
    document.getElementById('fatMultiplier').value = fatMultiplier;
    loadCategories();
    renderMeals();
    calculateMacros();
    showNotification(`Diyet modu ${mode} olarak güncellendi!`);
}

function loadCategories() {
    if (!Array.isArray(categories)) {
    categories = Object.values(categories);
}
    console.log("Kategoriler yükleniyor...");
    console.log("categories dizisi:", JSON.stringify(categories, null, 2)); // categories dizisini logla

    // 1. Kategori seçim dropdown'unu güncelle
    const categorySelect = document.getElementById('foodCategory');
    if (categorySelect) {
        categorySelect.innerHTML = '<option value="">Kategori Seçin</option>' + 
            categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
    } else {
        console.error("foodCategory elemanı bulunamadı!");
    }

    // 2. Sidebar'daki akordiyon menüyü güncelle (filtresiz)
    const sidebarCategories = document.getElementById('categories');
    if (sidebarCategories) {
        sidebarCategories.innerHTML = categories.map((category, index) => `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                        ${category.name} (${category.items.length})
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                    <div class="accordion-body">
                        ${category.items.map(item => `
                            <div class="category-item d-flex justify-content-between align-items-center">
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-danger btn-sm me-1" onclick="deleteFood('${item.name}', '${category.name}')" title="Sil"><i class="bi bi-trash"></i></button>
                                    <button class="btn btn-warning btn-sm me-2" onclick="editFood('${item.name}')" title="Düzenle"><i class="bi bi-pencil"></i></button>
                                    <span>${item.name} (${item.calories} kcal)</span>
                                </div>
                                <div class="food-checkboxes">
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="breakfast" title="Sabah"> S
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="lunch" title="Öğle"> Ö
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="dinner" title="Akşam"> A
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `).join('');
        console.log("Sidebar güncellendi:", sidebarCategories.innerHTML); // Kontrol için
    } else {
        console.error("Sidebar'daki 'categories' elemanı bulunamadı!");
    }

    // 3. Sağ paneli güncelle
    searchEditFood('');
    // searchFood('') çağrısını kaldırdık, sadece kullanıcı arama yaptığında çalışsın
}

document.addEventListener('DOMContentLoaded', function() {
    fetch('https://raw.githubusercontent.com/mustafasacar35/beslenme/refs/heads/main/sistem_JSON.json')
        .then(response => response.json())
        .then(data => {
            window.categories = data.categories || [];
            window.patients = data.patients || {};
            window.settingsTemplates = data.settingsTemplates || {};
            window.mealTemplates = data.mealTemplates || [];
            window.rules = data.rules || [];
            window.compatibilityTable = data.compatibilityTable || [];

            // localStorage'a GitHub verilerini yaz
            Object.entries(window.patients).forEach(([key, value]) => {
                localStorage.setItem(key, JSON.stringify(value));
            });

            categories = window.categories;
            loadCategories();
            testUpdateSidebar();
            rules = window.rules;
            mealTemplates = window.mealTemplates;
            compatibilityTable = window.compatibilityTable;

            console.log("Yüklenen Kategoriler:", window.categories);
            console.log("Yüklenen Hastalar:", window.patients);
            console.log("Yüklenen Kurallar:", window.rules);

            testUpdateSidebar();
            loadPatientSelect(); // testLoadPatientSelect yerine
            loadSettingsTemplates();
            loadMealTemplates();
            loadRules();
            loadCompatibilityRules();
            renderMeals();
            calculateMacros();

            showNotification("GitHub'dan veriler başarıyla yüklendi!", "success");
        })
        .catch(error => {
            console.error("Veriler yüklenirken hata oluştu:", error);
            showNotification("GitHub'dan veriler yüklenemedi!", "warning");
        });
});

    function testUpdateSidebar() {
        const sidebarContent = document.getElementById('categories');
        if (!sidebarContent) {
            console.error("categories elementi bulunamadı!");
            return;
        }
        sidebarContent.innerHTML = '';
        window.categories.forEach((category, index) => {
            const itemCount = category.items.length;
            const accordionItem = `
                <div class="accordion-item">
                    <h2 class="accordion-header" id="heading${index}">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                            ${category.name} (${itemCount})
                        </button>
                    </h2>
                    <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                        <div class="accordion-body">
                            ${category.items.map(food => `
                                <div class="category-item">
                                    <span>${food.name} (${food.calories} kcal)</span>
                                    <div class="food-checkboxes">
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="breakfast" title="Sabah"> S
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="lunch" title="Öğle"> Ö
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="dinner" title="Akşam"> A
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            sidebarContent.innerHTML += accordionItem;
        });
        console.log("Test Sidebar güncellendi!");
    }

    function testLoadPatientSelect() {
        const patientSelect = document.getElementById('patientSelect');
        if (!patientSelect) {
            console.error("patientSelect elementi bulunamadı! DOM'da 'patientSelect' ID'sine sahip bir eleman yok.");
            return;
        }
        console.log("patientSelect elementi bulundu:", patientSelect);

        // `window.patients` verisini kontrol et
        console.log("Yüklenmeye çalışılan hastalar (ham veri):", window.patients);

        if (!window.patients || Object.keys(window.patients).length === 0) {
            console.warn("window.patients boş veya tanımsız!");
            patientSelect.innerHTML = '<option value="">Hasta Yok</option>';
            return;
        }

        // Objedeki hastaları bir diziye çevir
        const patientArray = Object.values(window.patients);
        console.log("Hastalar diziye çevrildi:", patientArray);

        patientSelect.innerHTML = '<option value="">Hasta Seç</option>';
        patientArray.forEach((patient, index) => {
            const option = document.createElement('option');
            option.value = patient.name || `Hasta-${index}`;
            option.textContent = patient.name || `Hasta-${index}`;
            patientSelect.appendChild(option);
            console.log("Eklenen hasta:", patient.name || `Hasta-${index}`);
        });
        console.log("Test Hasta Seçimi güncellendi! Toplam hasta sayısı:", patientArray.length);
    }



        function searchFood(query) {
            const filterType = document.getElementById('searchFilterType').value;
            const sidebarContent = document.getElementById('categories');
            const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
            const likedFoods = patientData.likedFoods || [];
            const dislikedFoods = patientData.dislikedFoods || [];

            sidebarContent.innerHTML = categories.map((category, index) => {
                let filteredItems = category.items.filter(item => {
                    const matchesDiet = dietMode === 'keto' ? item.keto : item.lowcarb;
                    const notDisliked = !dislikedFoods.some(df => item.name.toLowerCase().includes(df.toLowerCase()) || item.tags.some(t => t.toLowerCase().includes(df.toLowerCase())));
                    if (filterType === 'name') return matchesDiet && notDisliked && item.name.toLowerCase().includes(query.toLowerCase());
                    if (filterType === 'tags') return matchesDiet && notDisliked && item.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));
                    if (filterType === 'role') return matchesDiet && notDisliked && item.role.toLowerCase().includes(query.toLowerCase());
                    return matchesDiet && notDisliked;
                });

                filteredItems.sort((a, b) => {
                    const aLiked = likedFoods.some(lf => a.name.toLowerCase().includes(lf.toLowerCase()) || a.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
                    const bLiked = likedFoods.some(lf => b.name.toLowerCase().includes(lf.toLowerCase()) || b.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
                    return bLiked - aLiked;
                });

                return `
                    <div class="accordion-item">
                        <h2 class="accordion-header" id="heading${index}">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
    ${category.name} (${filteredItems.length})
</button>
                        </h2>
                        <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                            <div class="accordion-body">
                                ${filteredItems.map(item => `
                                    <div class="category-item">
                                        <span>${item.name} (${item.calories} kcal)</span>
                                        <div class="food-checkboxes">
                                            <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="breakfast" title="Sabah"> S
                                            <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="lunch" title="Öğle"> Ö
                                            <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="dinner" title="Akşam"> A
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addNewCategory() {
    const categoryName = prompt("Yeni kategori adını girin:");
    if (categoryName && !categories.some(cat => cat.name === categoryName)) {
        categories.push({ name: categoryName, items: [] });
        loadCategories();
        showNotification("Yeni kategori eklendi!");
    } else if (categories.some(cat => cat.name === categoryName)) {
        showNotification("Bu kategori zaten var!", "warning");
    }
}

function editSelectedCategory() {
    const selectedCheckbox = document.querySelector('.category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    const oldName = categories[index].name;
    const newName = prompt("Yeni kategori adını girin:", oldName);
    if (newName && newName !== oldName && !categories.some(cat => cat.name === newName)) {
        categories[index].name = newName;
        loadCategories();
        showNotification("Kategori güncellendi!");
    } else if (categories.some(cat => cat.name === newName)) {
        showNotification("Bu kategori zaten var!", "warning");
    }
}

function deleteSelectedCategory() {
    const selectedCheckbox = document.querySelector('.category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    if (confirm(`${categories[index].name} kategorisini silmek istediğinize emin misiniz?`)) {
        categories.splice(index, 1);
        loadCategories();
        showNotification("Kategori silindi!");
    }
}

        function addSelectedFoods() {
    const checkboxes = document.querySelectorAll('.meal-checkbox:checked');
    if (checkboxes.length === 0) {
        showNotification("Lütfen en az bir öğün seçin!", "warning");
        return;
    }
    checkboxes.forEach(checkbox => {
        const foodName = checkbox.getAttribute('data-name');
        const mealType = checkbox.getAttribute('data-meal');
        weeks[selectedWeek - 1].days[selectedDay].meals[mealType].push({ name: foodName, quantity: 1 });
        checkbox.checked = false;
    });
    renderMeals();
    calculateMacros();
    toggleSidebar();
    showNotification("Yemekler eklendi!");
    updateGitHubData(); // Otomatik kaydet
}

        function toggleAddFoodForm() {
            const form = document.getElementById('addFoodForm');
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
        }

        function addNewFood(event) {
  event.preventDefault();
  console.log("Yeni yemek ekleniyor...");

  const form = document.getElementById("addFoodFormInner");
  console.log("Form durumu:", form);

  // Formun varlığını kontrol et
  if (!form) {
    console.error("addFoodFormInner bulunamadı!");
    showNotification("Form bulunamadı, lütfen sayfayı yenileyin!", "warning");
    return;
  }

  const categoryName = document.getElementById("foodCategory").value;
  const name = document.getElementById("foodName").value.trim();
  const calories = parseFloat(document.getElementById("foodCalories").value) || 0;
  const protein = parseFloat(document.getElementById("foodProtein").value) || 0;
  const carbs = parseFloat(document.getElementById("foodCarbs").value) || 0;
  const fat = parseFloat(document.getElementById("foodFat").value) || 0;
  const maxQuantity = parseFloat(document.getElementById("foodMaxQuantity").value) || 1;
  const minQuantity = parseFloat(document.getElementById("foodMinQuantity").value) || 0.5;
  const step = parseFloat(document.getElementById("foodStep").value) || 0.5;
  const tags = document.getElementById("foodTags").value.split(",").map(t => t.trim()).filter(t => t) || [];
  
  // YENİ: Uyumluluk etiketlerini al
  const compatibilityTags = document.getElementById("foodCompatibilityTags").value.split(",").map(t => t.trim()).filter(t => t) || [];
  
  const keto = document.getElementById("foodKeto").checked;
  const lowcarb = document.getElementById("foodLowCarb").checked;
  const fillerLunch = document.getElementById("foodFillerLunch").checked;
  const fillerDinner = document.getElementById("foodFillerDinner").checked;
  const portionFixed = document.getElementById("editFoodPortionFixed").checked;
  const multiplier = parseFloat(document.getElementById("editFoodMultiplier").value) || 1;
  
  // Güvenli erişim için null kontrolü ekleyelim
  let seasonFrom = 1; // Varsayılan değer
  let seasonTo = 12;  // Varsayılan değer
  
  const seasonFromElement = document.getElementById("foodSeasonFrom");
  const seasonToElement = document.getElementById("foodSeasonTo");
  
  if (seasonFromElement && seasonFromElement.value) {
    seasonFrom = parseInt(seasonFromElement.value);
  }
  
  if (seasonToElement && seasonToElement.value) {
    seasonTo = parseInt(seasonToElement.value);
  }

  // MealType checkbox'larından değerleri topla
  const mealTypes = [];
  ["breakfast", "lunch", "dinner"].forEach(type => {
    const checkbox = document.getElementById(`mealType_${type}`);
    if (checkbox && checkbox.checked) {
      mealTypes.push(type);
    }
  });
  const mealType = mealTypes.length > 0 ? mealTypes : [];

  // Mevcut yemek kontrolü
  const existing = categories.some(cat => cat.items.some(item => item.name.toLowerCase() === name.toLowerCase()));
  if (existing) {
    showNotification("Bu isimde bir yemek zaten var!", "warning");
    console.log(`Hata: ${name} zaten mevcut!`);
    return;
  }

  // Yeni yemek objesi
  const newFood = {
    name,
    calories,
    protein,
    carbs,
    fat,
    maxQuantity,
    minQuantity,
    step,
    tags,
    compatibilityTags, // YENİ: Uyumluluk etiketleri alanı
    role: document.getElementById("foodRole").value || "mainDish",
    mealType,
    keto,
    lowcarb,
    fillerLunch,
    fillerDinner,
    portionFixed,
    multiplier,
    
    // seasonRange formatını kullan
    seasonRange: `[${seasonFrom},${seasonTo}]`
  };

  // Kategoriye ekle
  let category = categories.find(cat => cat.name === categoryName);
  if (category) {
    category.items.push(newFood);
  } else {
    categories.push({
      name: categoryName,
      items: [newFood]
    });
  }

  // Formu sıfırla
  form.reset();
  document.getElementById("foodMaxQuantity").value = 1;
  document.getElementById("foodMinQuantity").value = 0.5;
  document.getElementById("foodStep").value = 0.5;

  // Kategorileri ve diğer panelleri güncelle
  loadCategories();
  searchEditFood("");
  showNotification(`${name} yemeği eklendi!`, "success");
  console.log(`Yemek eklendi: ${name}`);

  // GitHub'a verileri gönder
  updateGitHubData();

  // Modal'ı kapat
  closeAddFoodModal();
}

        function renderWeekTabs() {
            const weekTabs = document.getElementById('weekTabs');
            weekTabs.innerHTML = weeks.map((_, index) => `
                <li class="nav-item">
                    <a class="nav-link ${selectedWeek === index + 1 ? 'active' : ''}" href="#" onclick="selectWeek(${index + 1})">Hafta ${index + 1}</a>
                </li>
            `).join('');
        }

        function renderDayTabs() {
            const dayTabs = document.getElementById('dayTabs');
            dayTabs.innerHTML = days.map(day => `
                <li class="nav-item">
                    <a class="nav-link ${selectedDay === day ? 'active' : ''}" href="#" onclick="selectDay('${day}')">${day.charAt(0).toUpperCase() + day.slice(1)}</a>
                </li>
            `).join('');
        }

        function selectWeek(week) {
    selectedWeek = week;
    // --- SEÇİLEN HAFTANIN MODUNU YÜKLE ---
    const mode = weeks[selectedWeek - 1]?.dietMode || "keto";
    dietMode = mode;
    document.getElementById('dietModeSelect').value = mode;
    updateDietMode(mode);
    renderWeekTabs();
    renderMeals();
    calculateMacros();
}

        function selectDay(day) {
            selectedDay = day;
            renderDayTabs();
            renderMeals();
            calculateMacros();
        }

        function addWeek() {
    if (typeof saveState === 'function') {
        saveState();
    }
    // --- DİYET MODU BELİRLE ---
    let mode = "keto";
    if (weeks.length >= 9 && weeks.length < 13) mode = "lowcarb";
    if (weeks.length >= 13) mode = "lowcarb";
    weeks.push({
        days: {
            monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
        },
        dietMode: mode // <-- HER HAFTA İÇİN MODU KAYDET
    });
    selectedWeek = weeks.length;
    renderWeekTabs();
    renderMeals();
    calculateMacros();

    if (typeof generatePlan === 'function') {
        const lastWeekIndex = weeks.length - 1;
        generatePlan(getPlanningSettings(), lastWeekIndex);
    }
    if (typeof showNotification === 'function') {
        showNotification("Yeni hafta eklendi ve otomatik planlama yapıldı!", "success");
    }
    // --- DİYET MODU OTOMATİK AYARLA ---
    dietMode = mode;
    document.getElementById('dietModeSelect').value = mode;
    updateDietMode(dietMode);
}

function deleteWeek() {
    if (weeks.length > 1) {
        if (typeof saveState === 'function') {
            saveState(); // İşlemden önce durumu kaydet
        }
        weeks.splice(selectedWeek - 1, 1);
        selectedWeek = Math.min(selectedWeek, weeks.length);
        renderWeekTabs();
        renderMeals();
        calculateMacros();
        if (typeof showNotification === 'function') {
            showNotification("Hafta silindi!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("En az bir hafta kalmalı!", "warning");
        }
    }
}

function copyWeek() {
    if (typeof saveState === 'function') {
        saveState(); // İşlemden önce durumu kaydet
    }
    const newWeek = JSON.parse(JSON.stringify(weeks[selectedWeek - 1]));
    weeks.push(newWeek);
    selectedWeek = weeks.length;
    renderWeekTabs();
    renderMeals();
    calculateMacros();
    if (typeof showNotification === 'function') {
        showNotification("Hafta kopyalandı!", "success");
    }
}

function getActiveRoles(meal) {
    const mealItems = meal.map(item => findFood(item.name)?.role);
    return roles.map(role => ({
        ...role,
        active: mealItems.includes(role.role)
    }));
}

function toggleRole(mealType, roleIndex) {
    if (!weeks || !Array.isArray(weeks) || selectedWeek < 1 || !weeks[selectedWeek - 1] || !weeks[selectedWeek - 1].days[selectedDay]) {
        console.warn(`toggleRole: Hafta ${selectedWeek} veya gün ${selectedDay} tanımsız!`);
        return;
    }

    const meal = weeks[selectedWeek - 1].days[selectedDay].meals[mealType];
    if (!meal || !Array.isArray(meal)) {
        console.warn(`toggleRole: ${mealType} öğünü tanımsız veya dizi değil!`);
        return;
    }

    const activeRoles = getActiveRoles(meal);
    if (roleIndex < 0 || roleIndex >= activeRoles.length) {
        console.warn(`toggleRole: Geçersiz roleIndex: ${roleIndex}`);
        return;
    }

    const role = activeRoles[roleIndex].role;
    const isActive = activeRoles.some((r) => r.role === role && r.active);

    if (typeof saveState === 'function') {
        saveState(); // İşlemden önce durumu kaydet
    }

    if (!isActive) {
        const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || "{}") : {};
        const likedFoods = patientData.likedFoods || [];
        const dislikedFoods = patientData.dislikedFoods || [];

        const availableFoods = categories
            .flatMap((cat) => cat.items)
            .filter((food) => 
                food.role === role &&
                isMealTypeCompatible(food, mealType) &&
                (dietMode === "keto" ? food.keto : food.lowcarb) &&
                !dislikedFoods.some((df) => food.name.toLowerCase().includes(df.toLowerCase()) || (food.tags && food.tags.some((t) => t.toLowerCase().includes(df.toLowerCase())))) &&
                !checkKeywordConflict(food.name, meal) // Etiket çakışma kontrolü
            );

        if (availableFoods.length === 0) {
            console.warn(`toggleRole: ${mealType} için ${role} rolünde uygun yemek bulunamadı!`);
            if (typeof showNotification === 'function') {
                showNotification(`${mealType} için ${role} rolünde yemek eklenemedi: Uygun seçenek yok.`, "warning");
            }
            return;
        }

        const preferredFoods = availableFoods.filter((food) =>
            likedFoods.some((lf) => food.name.toLowerCase().includes(lf.toLowerCase()) || (food.tags && food.tags.some((t) => t.toLowerCase().includes(lf.toLowerCase()))))
        );

        const selectedFood = preferredFoods.length > 0 ? preferredFoods[Math.floor(Math.random() * preferredFoods.length)] : availableFoods[Math.floor(Math.random() * availableFoods.length)];
        
        meal.push({ name: selectedFood.name, quantity: 1 });
        console.log(`toggleRole: ${mealType} öğününe ${selectedFood.name} (${role}) eklendi.`);
        if (typeof showNotification === 'function') {
            showNotification(`${selectedFood.name} ${mealType} öğününe eklendi!`, "success");
        }
    } else {
        const index = meal.findIndex((item) => {
            const food = findFood(item.name);
            return food && food.role === role;
        });

        if (index !== -1) {
            const removedFood = meal[index].name;
            meal.splice(index, 1);
            console.log(`toggleRole: ${mealType} öğününden ${removedFood} (${role}) kaldırıldı.`);
            if (typeof showNotification === 'function') {
                showNotification(`${removedFood} ${mealType} öğününden kaldırıldı!`, "success");
            }
        }
    }

    renderMeals();
    calculateMacros();
}

function renderMeals() {
    if (!Array.isArray(categories)) {
    categories = Object.values(categories);
}
    console.log("renderMeals çalışıyor...");
    const mealsDiv = document.getElementById('meals');
    if (!mealsDiv) {
        console.error("meals elementi bulunamadı!");
        return;
    }

    const weekIndex = selectedWeek ? Math.max(0, Math.min(selectedWeek - 1, weeks.length - 1)) : 0;
    const day = selectedDay || "monday";

    if (!weeks || !Array.isArray(weeks) || !weeks[weekIndex] || !weeks[weekIndex].days || !weeks[weekIndex].days[day]) {
        console.warn(`Hafta ${weekIndex + 1} veya gün ${day} tanımsız!`, weeks);
        return;
    }

    const dayMeals = weeks[weekIndex].days[day].meals;
    if (!dayMeals || typeof dayMeals !== 'object' || 
        !Array.isArray(dayMeals.breakfast) || 
        !Array.isArray(dayMeals.lunch) || 
        !Array.isArray(dayMeals.dinner)) {
        console.warn(`Gün ${day} için meals yapısı eksik!`, dayMeals);
        return;
    }

    const calculateCalories = (items) => items.reduce((total, item) => {
        const food = findFood(item.name);
        return food ? total + food.calories * (item.quantity || 1) : total;
    }, 0);

    const breakfastCalories = calculateCalories(dayMeals.breakfast);
    const lunchCalories = calculateCalories(dayMeals.lunch);
    const dinnerCalories = calculateCalories(dayMeals.dinner);

    const targetCalories = parseFloat(document.getElementById('targetCalories')?.value) || 2000;
    const lunchRatio = parseFloat(document.getElementById('lunchCalorieRatio')?.value) || 40;
    const dinnerRatio = parseFloat(document.getElementById('dinnerCalorieRatio')?.value) || 30;

    const sortMealsByRole = (meals) => {
        return meals.slice().sort((a, b) => {
            const foodA = findFood(a.name) || { role: "Bilinmiyor" };
            const foodB = findFood(b.name) || { role: "Bilinmiyor" };
            const roleA = foodA.role || "Bilinmiyor";
            const roleB = foodB.role || "Bilinmiyor";
            console.log(`sortMealsByRole: ${a.name} (role: ${roleA}), ${b.name} (role: ${roleB})`);
            const roleOrder = {
                "soup": 1,
                "mainDish": 2,
                "sideDish": 3,
                "bread": 4,
                "dessert": 5,
                "fruit": 6,
                "snack": 7,
                "drink": 8,
                "supplement": 9,
                "bilinmiyor": 10
            };
            return (roleOrder[roleA] || 10) - (roleOrder[roleB] || 10);
        });
    };

    const sortedBreakfast = sortMealsByRole(dayMeals.breakfast);
    const sortedLunch = sortMealsByRole(dayMeals.lunch);
    const sortedDinner = sortMealsByRole(dayMeals.dinner);

    const requiredFunctions = { findFood, getActiveRoles, renderMealItem, toggleRole };
    for (const [name, fn] of Object.entries(requiredFunctions)) {
        if (typeof fn !== 'function') {
            console.warn(`${name} fonksiyonu tanımlı değil, bazı özellikler çalışmayabilir.`);
        }
    }

    mealsDiv.innerHTML = `
        <div class="card meal-card">
            <div class="card-header">
                <span>Kahvaltı (${breakfastCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * (1 - lunchRatio / 100 - dinnerRatio / 100)).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="breakfast"
                               aria-label="Kahvaltı için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.breakfast).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('breakfast', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedBreakfast.map((item, index) => renderMealItem(item, 'breakfast', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card meal-card">
            <div class="card-header">
                <span>Öğle (${lunchCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * lunchRatio / 100).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="lunch"
                               aria-label="Öğle için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                    ${typeof addCurrentMealToTemplates === 'function' ? `
                        <button class="btn btn-sm btn-success template-add-btn ms-2" 
                                onclick="addCurrentMealToTemplates('lunch')">Öğün Kayıt</button>
                    ` : ''}
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.lunch).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('lunch', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedLunch.map((item, index) => renderMealItem(item, 'lunch', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card meal-card">
            <div class="card-header">
                <span>Akşam (${dinnerCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * dinnerRatio / 100).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="dinner"
                               aria-label="Akşam için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                    ${typeof addCurrentMealToTemplates === 'function' ? `
                        <button class="btn btn-sm btn-success template-add-btn ms-2" 
                                onclick="addCurrentMealToTemplates('dinner')">Öğün Kayıt</button>
                    ` : ''}
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.dinner).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('dinner', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedDinner.map((item, index) => renderMealItem(item, 'dinner', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;

    document.querySelectorAll('.meal-search-input').forEach(input => {
        input.addEventListener('input', handleMealSearch);
        input.addEventListener('focus', () => {
            if (input.value.trim()) {
                showSearchResults(input);
            }
        });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                const resultsDiv = input.nextElementSibling;
                resultsDiv.style.display = 'none';
            }, 200);
        });
    });
    updateCompatibilityStatus();
}

// Debounce yardımcı fonksiyonu
function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// handleMealSearch güncellenmiş hali
function handleMealSearch(event) {
    const input = event.target;
    const query = input.value.trim().toLowerCase();
    const mealType = input.dataset.mealType;
    const resultsDiv = input.nextElementSibling;

    if (!query) {
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
        return;
    }

    showSearchResults(input);
}

// Arama input'larına debounce ekle
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.meal-search-input').forEach(input => {
        input.addEventListener('input', debounce(handleMealSearch, 300)); // 300ms gecikme
        input.addEventListener('focus', () => {
            if (input.value.trim()) {
                showSearchResults(input);
            }
        });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                const resultsDiv = input.nextElementSibling;
                resultsDiv.style.display = 'none';
            }, 200);
        });
    });
});

function showSearchResults(input) {
    const query = input.value.trim().toLowerCase();
    const mealType = input.dataset.mealType;
    const resultsDiv = input.nextElementSibling;

    // Sorguyu kelimelere ayır (boşluklara göre)
    const queryWords = query.split(/\s+/).filter(word => word.length > 0);

    // Yemekleri filtrele
    const filteredFoods = [];
    categories.forEach(category => {
        category.items.forEach(food => {
            // Yemek ismini normalleştir
            const normalizedFoodName = food.name
                .toLowerCase()
                .replace(/[\d.]+/g, '') // Sayıları çıkar (örn. "1", "0.5")
                .replace(/\b(dilim|kase|bardak|porsiyon|adet|kaşık|fincan|tabak)\b/g, '') // Ölçü birimlerini çıkar
                .replace(/\s+/g, ' ') // Fazla boşlukları temizle
                .trim();

            // Sorgudaki her kelimenin yemek isminde olup olmadığını kontrol et
            const matches = queryWords.every(queryWord => 
                normalizedFoodName.includes(queryWord)
            );

            if (matches) {
                // Eşleşme puanını hesapla (daha fazla kelime eşleşmesi = daha yüksek puan)
                const matchScore = queryWords.reduce((score, word) => 
                    score + (normalizedFoodName.includes(word) ? 1 : 0), 0);
                filteredFoods.push({ ...food, category: category.name, matchScore });
            }
        });
    });

    // Sonuçları eşleşme puanına göre sırala (daha yüksek puan üstte)
    filteredFoods.sort((a, b) => b.matchScore - a.matchScore);

    // Sonuçları render et
    if (filteredFoods.length === 0) {
        resultsDiv.innerHTML = `
            <div class="search-result-empty">
                "${query}" ile eşleşen yemek bulunamadı.
            </div>
        `;
    } else {
        resultsDiv.innerHTML = filteredFoods.map(food => `
            <div class="search-result-item" 
                 onclick="addFoodToMeal('${mealType}', '${food.name}', '${food.category}')">
                ${food.name} (${food.calories} kcal)
            </div>
        `).join('');
    }

    resultsDiv.style.display = 'block';
}
function hasKeywordOrTagConflict(food, mealFoods) {
    if (!food) return false;

    // Hariç tutulacak kelimeler ve etiketler
    const ignoreWords = [
        "ve", "ile", "artış", "düzeyi", "adet", "kase", "porsiyon", "dilim", "kaşığı", "tatlı", "yemek", "çorba", "tabak", "fincan", "yaprak", "kare"
    ];
    const ignoreTags = ["keto", "lowcarb", "zeytinyağı"];

    // İsim ve etiketlerden anlamlı kelimeleri topla
    function extractKeywords(str) {
        return str
            .toLowerCase()
            .replace(/[^a-zçğıöşü\s]/gi, ' ')
            .split(/\s+/)
            .filter(w => w.length > 2 && !ignoreWords.includes(w));
    }
    // Hem isim hem tags hem de compatibilityTags (varsa) dahil
    const foodKeywords = [
        ...extractKeywords(food.name),
        ...(food.tags || []).map(t => t.toLowerCase()),
        ...(food.compatibilityTags || []).map(t => t.toLowerCase())
    ].filter(t => !ignoreTags.includes(t));

    for (const item of mealFoods) {
        const otherFood = findFood(item.name);
        if (!otherFood) continue;
        const otherKeywords = [
            ...extractKeywords(otherFood.name),
            ...(otherFood.tags || []).map(t => t.toLowerCase()),
            ...(otherFood.compatibilityTags || []).map(t => t.toLowerCase())
        ].filter(t => !ignoreTags.includes(t));

        // Ortak anlamlı kelime veya etiket var mı?
        if (foodKeywords.some(w => otherKeywords.includes(w))) {
            return true;
        }
    }
    return false;
}
function addFoodToMeal(mealType, foodName, categoryName) {
    if (typeof saveState === 'function') {
        saveState(); // Save state before modifying
    }

    const category = categories.find(cat => cat.name === categoryName);
    const food = category?.items.find(item => item.name === foodName);
    if (!food) {
        showNotification(`Yemek bulunamadı: ${foodName}`, 'warning');
        return;
    }
    const weekIndex = selectedWeek ? selectedWeek - 1 : 0;
    const day = selectedDay || "monday";
    const dayMeals = weeks[weekIndex].days[day].meals;

    // Check if food already exists in the meal
    const existingFood = dayMeals[mealType].find(item => item.name === foodName);
    if (existingFood) {
        if (typeof showNotification === 'function') {
            showNotification(`${foodName} zaten bu öğünde mevcut!`, 'warning');
        }
        return;
    }
if (hasKeywordOrTagConflict(food, dayMeals[mealType])) {
        showNotification(`${foodName} ile aynı anahtar kelimeye/tag'e sahip başka bir yemek zaten bu öğünde var!`, 'warning');
        return;
    }
    // Add food to meal
    dayMeals[mealType].push({
        name: food.name,
        calories: food.calories || 0,
        carbs: food.carbs || 0,
        protein: food.protein || 0,
        fat: food.fat || 0,
        quantity: 1,
        role: food.role || 'maindish'
    });

// --- UYUMLU YAN YEMEKLERİ OTOMATİK EKLE ---
if (food.role === "mainDish" && Array.isArray(food.compatibilityTags) && food.compatibilityTags.length > 0) {
    const compatTags = food.compatibilityTags.map(t => t.toLowerCase());
    const alreadyAdded = dayMeals[mealType].map(item => item.name);
    const usedTags = new Set();
    dayMeals[mealType].forEach(item => {
        const f = findFood(item.name);
        if (f) {
            if (Array.isArray(f.compatibilityTags)) {
                f.compatibilityTags.forEach(tag => usedTags.add(tag.toLowerCase()));
            }
            if (Array.isArray(f.tags)) {
                f.tags.forEach(tag => usedTags.add(tag.toLowerCase()));
            }
        }
    });
    let compatibleFood = null;
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    const macroTolerance = parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1;
    for (const tag of compatTags) {
        if (usedTags.has(tag)) continue;
        for (const cat of categories) {
            for (const item of cat.items) {
                if (
                    item.role !== "mainDish" &&
                    !alreadyAdded.includes(item.name) &&
                    !hasKeywordOrTagConflict(item, dayMeals[mealType])
                ) {
                    const allTags = [
                        ...(item.name ? item.name.toLowerCase().split(/\s+/) : []),
                        ...(item.tags ? item.tags.map(t => t.toLowerCase()) : []),
                        ...(item.compatibilityTags ? item.compatibilityTags.map(t => t.toLowerCase()) : [])
                    ];
                    if (allTags.includes(tag)) {
                        if (canAddFoodToMealWithMacros(dayMeals[mealType], item, macroTolerance, patientData)) {
                            compatibleFood = item;
                        }
                        break;
                    }
                }
            }
            if (compatibleFood) break;
        }
        if (compatibleFood) break;
    }
    if (compatibleFood) {
        dayMeals[mealType].push({
            name: compatibleFood.name,
            calories: compatibleFood.calories || 0,
            carbs: compatibleFood.carbs || 0,
            protein: compatibleFood.protein || 0,
            fat: compatibleFood.fat || 0,
            quantity: 1,
            role: compatibleFood.role || 'sideDish'
        });
    }
}
    // Eğer eklenen yemek ana yemekse ve uyumluluk etiketi varsa
    if (food.role === "mainDish" && Array.isArray(food.compatibilityTags) && food.compatibilityTags.length > 0) {
    const compatTags = food.compatibilityTags.map(t => t.toLowerCase());
    const alreadyAdded = dayMeals[mealType].map(item => item.name);
    // Öğündeki tüm yemeklerin tag'larını topla (tekrar etmesin)
    const usedTags = new Set();
    dayMeals[mealType].forEach(item => {
        const f = findFood(item.name);
        if (f) {
            if (Array.isArray(f.compatibilityTags)) {
                f.compatibilityTags.forEach(tag => usedTags.add(tag.toLowerCase()));
            }
            if (Array.isArray(f.tags)) {
                f.tags.forEach(tag => usedTags.add(tag.toLowerCase()));
            }
        }
    });

    let compatibleFood = null;
    // Sırayla tag'ları dene, ilk bulduğunu ekle
    for (const tag of compatTags) {
        if (usedTags.has(tag)) continue; // Bu tag zaten kullanıldıysa atla
        // Uygun ve çakışmasız bir yemek bul
        for (const cat of categories) {
            for (const item of cat.items) {
                if (
                    item.role !== "mainDish" &&
                    !alreadyAdded.includes(item.name) &&
                    !hasKeywordOrTagConflict(item, dayMeals[mealType])
                ) {
                    // Hem isimde hem tag'larda arama
                    const allTags = [
                        ...(item.name ? item.name.toLowerCase().split(/\s+/) : []),
                        ...(item.tags ? item.tags.map(t => t.toLowerCase()) : []),
                        ...(item.compatibilityTags ? item.compatibilityTags.map(t => t.toLowerCase()) : [])
                    ];
                    if (allTags.includes(tag)) {
                        compatibleFood = item;
                        break;
                    }
                }
            }
            if (compatibleFood) break;
        }
        if (compatibleFood) break; // İlk uygun tag için bulduysa döngüyü kır
    }
    if (compatibleFood) {
        dayMeals[mealType].push({
            name: compatibleFood.name,
            calories: compatibleFood.calories || 0,
            carbs: compatibleFood.carbs || 0,
            protein: compatibleFood.protein || 0,
            fat: compatibleFood.fat || 0,
            quantity: 1,
            role: compatibleFood.role || 'sideDish'
        });
    }
}
    // Update UI
   renderMeals();
    if (typeof calculateMacros === 'function') calculateMacros();
    if (typeof showNotification === 'function') showNotification(`${foodName} ${mealType} öğününe eklendi!`, 'success');


     // Clear search input and hide results
    const input = document.querySelector(`.meal-search-input[data-meal-type="${mealType}"]`);
    if (input) {
        input.value = '';
        input.nextElementSibling.style.display = 'none';
    }
}


function renderMealItem(item, mealType, index) {
    const food = findFood(item.name);
    if (!food) {
        console.warn(`Yemek bulunamadı: ${item.name}`);
        return '';
    }

    let quantity = item.quantity || 1;
    const week = selectedWeek - 1;
    const day = selectedDay;

    // Yemek adını güncelleyen fonksiyon
    const updateName = (name, quantity) => {
        let updatedName = name;
        const units = ["gram", "adet", "kase", "porsiyon", "dilim", "kaşık", "tatlı kaşığı", "yemek kaşığı", "yaprak", "kare"];
        for (const unit of units) {
            const regex = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${unit}`, "g");
            updatedName = updatedName.replace(regex, (match, number) => {
                const baseValue = parseFloat(number);
                let updatedValue = baseValue * quantity;
                updatedValue = roundQuantity(updatedValue, true); // Artırma için yuvarla
                return formatQuantityWithText(`${updatedValue} ${unit}`);
            });
        }

        // Özel kaşık dönüşümleri
        if (quantity === 0.5 && updatedName.includes("yemek kaşığı")) {
            updatedName = updatedName.replace(/\byemek kaşığı\b/, "tatlı kaşığı");
        }
        if (updatedName.includes("yarım yemek kaşığı")) {
            updatedName = updatedName.replace(/\byarım yemek kaşığı\b/, "1 tatlı kaşığı");
        }
        if (updatedName.includes("2 tatlı kaşığı")) {
            updatedName = updatedName.replace(/\b2 tatlı kaşığı\b/, "1 yemek kaşığı");
        }
        if (updatedName.includes("0.25 yemek kaşığı")) {
            updatedName = updatedName.replace(/\b0\.25 yemek kaşığı\b/, "çeyrek yemek kaşığı");
        }

        return updatedName;
    };

    let updatedName = updateName(food.name, quantity);
    const category = categories.find(cat => cat.items.some(i => i.name === item.name))?.name || 'Bilinmiyor';
    const role = food.role || 'Bilinmiyor';

    // Kuralı bul
    const { appliedRule, conflictingRules } = findAppliedRule(food, mealType);

    // Kural açıklamasını oluştur
    const getRuleDescription = (rule) => {
        if (!rule) return '-';
        switch (rule.type) {
            case 'frequency':
                const freqText = rule.frequencyType === 'max' ? 'en fazla' :
                    rule.frequencyType === 'min' ? 'en az' : '';
                return `(${rule.id}) Rol: ${rule.role || 'herhangi'} her ${rule.mealType || 'öğünde'} ${freqText} ${rule.frequency} kez`;
            case 'dependOn':
                return `(${rule.id}) ${rule.food} yalnızca ${rule.requiredFood} ile eklensin`;
            case 'compatibility':
                return `(${rule.id}) ${rule.keyword1} ile ${rule.keyword2.join(', ')} (${rule.degree > 0 ? 'Uyumlu' : 'Uyumsuz'}, Derece: ${rule.degree})`;
            default:
                return `(${rule.id}) ${rule.type}`;
        }
    };

    const ruleText = appliedRule
        ? `<span title="${getRuleDescription(appliedRule)}">${appliedRule.id} / ${appliedRule.type}</span>`
        : '-';
    const conflictingText = conflictingRules.length > 0
        ? conflictingRules.map(r => `<span title="${getRuleDescription(r)}">${r.id} / ${r.type}</span>`).join(', ')
        : '-';

    // Uyumlu yan yemek işareti (✔️)
    let compatibleMark = '';
    if (food.role !== 'mainDish') {
        // Aynı öğünde bir ana yemek var mı ve bu yemeğin compatibilityTags'i ile eşleşiyor mu?
        const meal = weeks[selectedWeek - 1].days[selectedDay].meals[mealType];
        const mainDish = meal.find(i => {
            const f = findFood(i.name);
            return f && f.role === 'mainDish';
        });
        if (mainDish) {
            const mainFood = findFood(mainDish.name);
            if (
                mainFood &&
                Array.isArray(mainFood.compatibilityTags) &&
                mainFood.compatibilityTags.length > 0
            ) {
                // Ana yemeğin compatibilityTags'i ile yan yemeğin compatibilityTags VEYA tags'i eşleşiyor mu?
                const sideTags = [
                    ...(Array.isArray(food.compatibilityTags) ? food.compatibilityTags : []),
                    ...(Array.isArray(food.tags) ? food.tags : [])
                ];
                if (
                    mainFood.compatibilityTags.some(tag => sideTags.includes(tag))
                ) {
                    compatibleMark = ' <span title="Uyumlu Yan Yemek" style="color:green;font-size:1.2em;">✔️</span>';
                }
            }
        }
    }

    return `
    <tr class="meal-item" data-name="${item.name}" data-meal="${mealType}" data-day="${day}" data-week="${week}">
        <td class="rule-column">${ruleText}</td>
        <td class="conflict-column">${conflictingText}</td>
        <td class="food-column">
            ${updatedName}${compatibleMark}
            <br><small style="color:gray;">Artış düzeyi: ${food.step || 0.5}</small>
        </td>
        <td>${category} / ${role}</td>
        <td>
            <input type="number" 
                   value="${quantity}" 
                   min="${food.minQuantity || 0.1}" 
                   max="${food.maxQuantity || 10}" 
                   step="${food.step || 0.5}" 
                   onchange="updateMealQuantityFromDOM(this)">
        </td>
        <td>${((food.carbs * 4 + food.protein * 4 + food.fat * 9) * quantity).toFixed(1)}</td>
        <td>${(food.carbs * quantity).toFixed(1)}</td>
        <td>${(food.protein * quantity).toFixed(1)}</td>
        <td>${(food.fat * quantity).toFixed(1)}</td>
        <td>
            <button class="btn btn-warning btn-sm" onclick="editMealItemFromDOM(this)" title="Düzenle">
                <i class="bi bi-pencil"></i>
            </button>
            <button class="btn btn-remove-from-meal btn-sm" onclick="deleteMealItemFromDOM(this)" title="Öğünden Sil">
                <i class="bi bi-trash"></i>
            </button>
            <button class="btn btn-danger btn-sm" onclick="deleteFoodFromSystem('${item.name}')" title="Sistemden Sil">
                <i class="bi bi-trash-fill"></i>
            </button>
            <button class="btn btn-primary btn-sm" onclick="replaceWithAlternative('${item.name}', '${mealType}')" title="Alternatif ile Değiştir">
                <i class="bi bi-arrow-repeat"></i>
            </button>
        </td>
    </tr>
    `;
}

// Önceki alternatifleri takip etmek için global bir değişken (isteğe bağlı)
let lastUsedAlternatives = {};

function replaceWithAlternative(foodName, mealType) {
    // Değişiklikten önceki durumu kaydet
    saveState();

    // Mevcut yemeği bul
    const currentFood = findFood(foodName);
    if (!currentFood) {
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }

    // Makro fark aralığını kademeli olarak genişlet
    const tolerances = [0.1, 0.2, 0.3, 0.4, 0.5]; // %10, %20, %30, %40, %50
    let alternatives = [];

    for (const tolerance of tolerances) {
        categories.forEach(category => {
            if (category.name === currentFood.category) {
                category.items.forEach(item => {
                    if (item.name !== foodName && // Kendisi hariç
                        item.role === currentFood.role) { // Aynı rol
                        const proteinDiff = Math.abs(item.protein - currentFood.protein);
                        const fatDiff = Math.abs(item.fat - currentFood.fat);
                        const maxProteinDiff = currentFood.protein * tolerance;
                        const maxFatDiff = currentFood.fat * tolerance;

                        if (proteinDiff <= maxProteinDiff && fatDiff <= maxFatDiff) {
                            alternatives.push(item);
                        }
                    }
                });
            }
        });

        // Bu toleransta alternatif varsa döngüyü kır
        if (alternatives.length > 0) {
            break;
        }
    }

    if (alternatives.length === 0) {
        showNotification("Hiçbir makro aralığında uygun alternatif bulunamadı!", "warning");
        return;
    }

    // Önceki kullanılan alternatifi kontrol et
    const key = `${foodName}-${mealType}`;
    const lastAlternative = lastUsedAlternatives[key];

    // Önceki alternatif hariç birini seç
    let newFood;
    if (alternatives.length === 1) {
        newFood = alternatives[0]; // Tek alternatif varsa onu kullan
    } else {
        const availableAlternatives = lastAlternative
            ? alternatives.filter(alt => alt.name !== lastAlternative.name)
            : alternatives;
        if (availableAlternatives.length === 0) {
            newFood = alternatives[0]; // Tüm alternatifler kullanıldıysa rastgele birini seç
        } else {
            newFood = availableAlternatives[Math.floor(Math.random() * availableAlternatives.length)];
        }
    }

    // Yeni alternatifi kaydet
    lastUsedAlternatives[key] = newFood;

    // Öğünde yemeği değiştir
    const weekIndex = selectedWeek - 1;
    const dayMeals = weeks[weekIndex].days[selectedDay].meals[mealType];
    const foodIndex = dayMeals.findIndex(meal => meal.name === foodName);
    if (foodIndex !== -1) {
        dayMeals[foodIndex] = {
            name: newFood.name,
            quantity: dayMeals[foodIndex].quantity || 1, // Mevcut miktarı koru
        };
    }
    // Arayüzü güncelle
    renderMeals();
    calculateMacros();
    showNotification(`${foodName}, ${newFood.name} ile değiştirildi!`, "success");
}

function findAppliedRule(meal, mealType) {
    if (!rules || !Array.isArray(rules) || rules.length === 0) {
        console.log("Kural dizisi boş veya tanımlı değil:", rules);
        return { appliedRule: null, conflictingRules: [] };
    }

    const mealNameLower = meal.name.toLowerCase();
    const mealTags = (meal.tags || []).map(tag => tag.toLowerCase());
    const mealCategory = (meal.category || '').toLowerCase();
    const mealRole = (meal.role || '').toLowerCase();

    // Mevcut öğün verilerini al
    const currentDayMeals = weeks[selectedWeek - 1].days[selectedDay].meals;
    const currentMealItems = currentDayMeals[mealType].map(item => item.name.toLowerCase());

    // Kural türlerine göre hiyerarşi
    const typeHierarchy = {
        'dependOn': 1,      // Highest priority
        'compatibility': 2,
        'frequency': 3      // Lowest priority
    };

    let matchedRules = [];

    for (const rule of rules) {
        console.log(`Kural ${rule.id} kontrol ediliyor:`, rule);

        // dependOn kuralı
        if (rule.type === 'dependOn') {
            const ruleFoodLower = rule.food?.toLowerCase() || '';
            const requiredFoodLower = rule.requiredFood?.toLowerCase() || '';
            if (ruleFoodLower === mealNameLower && 
                currentMealItems.some(item => item.includes(requiredFoodLower))) {
                console.log(`Kural ${rule.id} (dependOn) eşleşti: ${meal.name} -> ${rule.requiredFood} (${mealType})`);
                matchedRules.push(rule);
            }
        }

        // frequency kuralı
        if (rule.type === 'frequency') {
            const matchesName = rule.nameCheck && rule.names?.length > 0 && 
                rule.names.some(name => mealNameLower.includes(name.toLowerCase()));
            const matchesTags = rule.tagsCheck && rule.tags?.length > 0 && 
                mealTags.some(tag => rule.tags.map(t => t.toLowerCase()).includes(tag));
            const matchesRole = rule.roleCheck && rule.role && 
                mealRole === rule.role.toLowerCase();
            const matchesCategory = rule.catCheck && rule.category && 
                mealCategory === rule.category.toLowerCase();
            const matchesMealType = rule.mealTypeCheck && rule.mealType && 
                mealType === rule.mealType;

            const matchesConditions = matchesName || matchesTags || matchesRole || matchesCategory;
            if (matchesConditions && (!rule.mealTypeCheck || matchesMealType)) {
                console.log(`Kural ${rule.id} (frequency) eşleşti: ${meal.name} (${mealType})`);
                matchedRules.push(rule);
            }
        }

        // compatibility kuralı
        if (rule.type === 'compatibility') {
            const keyword1Lower = rule.keyword1?.toLowerCase() || '';
            const keyword2List = (rule.keyword2 || []).map(kw => kw.toLowerCase());
            if (mealNameLower.includes(keyword1Lower)) {
                if (rule.conjunction === 'and') {
                    const anyKeyword2Match = currentMealItems.some(item => 
                        keyword2List.some(kw => item.includes(kw)));
                    if (anyKeyword2Match) {
                        console.log(`Kural ${rule.id} (compatibility - and) eşleşti: ${meal.name} (${mealType})`);
                        matchedRules.push(rule);
                    }
                } else if (rule.conjunction === 'or') {
                    const anyKeyword2Match = keyword2List.some(kw => mealNameLower.includes(kw));
                    if (anyKeyword2Match) {
                        console.log(`Kural ${rule.id} (compatibility - or) eşleşti: ${meal.name} (${mealType})`);
                        matchedRules.push(rule);
                    }
                }
            }
        }
    }

    if (matchedRules.length === 0) {
        console.log(`Hiçbir kural eşleşmedi: ${meal.name} (${mealType})`);
        return { appliedRule: null, conflictingRules: [] };
    }

    // Sort rules by hierarchy and then priority
    matchedRules.sort((a, b) => {
        const hierarchyA = typeHierarchy[a.type] || 999;
        const hierarchyB = typeHierarchy[b.type] || 999;
        if (hierarchyA !== hierarchyB) {
            return hierarchyA - hierarchyB;  // Lower hierarchy value wins
        }
        return (a.priority || 999) - (b.priority || 999);  // Lower priority value wins
    });

    // Select the most important rule and list conflicts
    const appliedRule = matchedRules[0];
    const conflictingRules = matchedRules.slice(1);

    console.log(`Uygulanan kural: ${appliedRule?.id}, Çakışan kurallar: ${conflictingRules.map(r => r.id).join(', ')}`);
    return { appliedRule, conflictingRules };
}


function deleteFoodFromSystem(foodName) {
  console.log("deleteFoodFromSystem başladı, silinecek yemek:", foodName);
  if (!confirm(`"${foodName}" yemeğini sistemden silmek istiyor musunuz?`)) return;

  // İşlemden önce mevcut durumu kaydet (undo için)
  if (typeof saveState === 'function') {
    saveState();
  }

  // 1. LocalStorage'daki tüm kategorilerden kaldır
  let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
  console.log("Mevcut food_list:", storedFoodList);
  for (const cat in storedFoodList) {
    storedFoodList[cat] = storedFoodList[cat].filter(f => f.name !== foodName);
  }
  localStorage.setItem("food_list", JSON.stringify(storedFoodList));
  console.log("Güncellenmiş food_list:", storedFoodList);

  // 2. Global categories dizisinden kaldır (opsiyonel, varsa çalışır)
  if (typeof categories !== 'undefined' && Array.isArray(categories)) {
    console.log("Mevcut categories:", categories);
    categories.forEach(category => {
      if (category.items && Array.isArray(category.items)) {
        category.items = category.items.filter(item => item.name !== foodName);
      }
    });
    console.log("Güncellenmiş categories:", categories);
  } else {
    console.log("categories tanımlı değil, bu adım atlanıyor.");
  }

  // 3. Sağ paneldeki öğünlerden kaldır (weeks veya allData kontrolü)
  let dataSource = typeof weeks !== 'undefined' ? weeks : (typeof allData !== 'undefined' ? allData : null);
  console.log("Kullanılan veri kaynağı:", dataSource);
  if (dataSource && Array.isArray(dataSource)) {
    for (const week of dataSource) {
      if (week.days && typeof week.days === 'object') {
        for (const day in week.days) {
          if (week.days[day].meals && typeof week.days[day].meals === 'object') {
            for (const mealType in week.days[day].meals) {
              if (Array.isArray(week.days[day].meals[mealType])) {
                week.days[day].meals[mealType] = week.days[day].meals[mealType].filter(m => m.name !== foodName);
              }
            }
          }
        }
      }
    }
    console.log("Güncellenmiş veri kaynağı:", dataSource);
  } else {
    console.log("Veri kaynağı (weeks veya allData) tanımlı değil, öğünler güncellenemedi.");
  }

  // 4. Görünümü yeniden çiz (fonksiyonlar varsa çalışır)
  if (typeof loadCategories === 'function') {
    console.log("loadCategories çağrılıyor...");
    loadCategories();
  } else {
    console.log("loadCategories fonksiyonu tanımlı değil.");
  }

  if (typeof renderMeals === 'function') {
    console.log("renderMeals çağrılıyor...");
    renderMeals();
  } else {
    console.log("renderMeals fonksiyonu tanımlı değil.");
  }

  if (typeof searchEditFood === 'function') {
    console.log("searchEditFood çağrılıyor...");
    searchEditFood('');
  } else {
    console.log("searchEditFood fonksiyonu tanımlı değil.");
  }

  // 5. Grafikleri güncelle
  if (typeof calculateMacros === 'function') {
    console.log("calculateMacros çağrılıyor...");
    calculateMacros();
  } else {
    console.log("calculateMacros fonksiyonu tanımlı değil.");
  }

  // 6. Bildirim göster (durumu tekrar kaydetmeye gerek yok, applyState zaten bunu yapacak)
  if (typeof showNotification === 'function') {
    showNotification(`"${foodName}" sistemden tamamen silindi.`, "success");
  }
  console.log("deleteFoodFromSystem tamamlandı.");
}

function updateMealQuantityFromDOM(input) {
    if (typeof saveState === 'function') {
        saveState();
    }

    const itemRow = input.closest('.meal-item');
    const foodName = itemRow.getAttribute('data-name');
    const mealType = itemRow.getAttribute('data-meal');
    const day = itemRow.getAttribute('data-day');
    const week = itemRow.getAttribute('data-week');

    let newQuantity = parseFloat(input.value);
    const food = findFood(foodName);

    if (!food) {
        console.warn("Yemek bulunamadı:", foodName);
        return;
    }

    // Sınırları kontrol et
    const minQuantity = food.minQuantity || 0.1;
    const maxQuantity = food.maxQuantity || 10;
    const currentQuantity = parseFloat(input.getAttribute('value')) || minQuantity;

    // Yuvarlama: Sadece artırırken uygula
    const isIncreasing = newQuantity > currentQuantity;
    newQuantity = roundQuantity(newQuantity, isIncreasing);

    // Sınırlara uydur
    if (newQuantity < minQuantity) {
        newQuantity = minQuantity;
    } else if (newQuantity > maxQuantity) {
        newQuantity = maxQuantity;
    }

    const mealList = weeks[week].days[day].meals[mealType];
    const item = mealList.find(f => f.name === foodName);

    if (item) {
        item.quantity = newQuantity;
        input.value = newQuantity; // Input'u senkronize et
        renderMeals();
        if (typeof calculateMacros === 'function') {
            calculateMacros();
        }
        if (typeof showNotification === 'function') {
            const unit = ['dilim', 'kase', 'bardak', 'yemek', 'porsiyon', 'adet', 'tatlı kaşığı', 'çorba kaşığı', 'tabak', 'fincan', 'yaprak', 'yemek kaşığı', 'gram', 'kare']
                .find(u => foodName.toLowerCase().includes(u)) || 'porsiyon';
            showNotification(`Miktar güncellendi: ${formatQuantityWithText(`${newQuantity} ${unit}`)}`, 'success');
        }
    } else {
        console.warn("Yemek bulunamadı:", foodName);
    }
}

function roundQuantity(quantity, isIncreasing = false) {
    // 0.5 ve 0.25 için özel durum
    if (quantity === 0.5 || quantity === 0.25) return quantity;
    
    // Sadece artırırken yuvarla
    if (isIncreasing && quantity % 1 !== 0) {
        return Math.ceil(quantity);
    }
    
    // Azaltırken veya tam sayıysa direkt dön
    return quantity;
}
function editMealItemFromDOM(button) {
    const item = button.closest('.meal-item');
    const foodName = item.getAttribute('data-name');
    editFood(foodName); // mevcut editFood() fonksiyonunu çağırabiliriz
}


function deleteMealItemFromDOM(button) {
    updateCaloriesInPopup();
    saveState(); // Silmeden önce durumu kaydet
    const item = button.closest('.meal-item');
    const foodName = item.getAttribute('data-name');
    const mealType = item.getAttribute('data-meal');
    const day = item.getAttribute('data-day'); // düzeltildi
    const week = parseInt(item.getAttribute('data-week'));

    const mealList = weeks[week].days[day].meals[mealType];
    const index = mealList.findIndex(m => m.name === foodName);
    if (index !== -1) {
        mealList.splice(index, 1);
        renderMeals();
        calculateMacros();
        showNotification("Yemek silindi!");
    }
}




// Yemeği bulma fonksiyonu
function findFood(name) {
    const normalizedName = name.toLowerCase().trim();
    for (const category of categories) {
        for (const item of category.items) {
            const itemName = item.name.toLowerCase().trim();
            if (itemName === normalizedName) {
                item.category = category.name;
                return item;
            }
        }
    }
    // Esnek eşleşme: Eğer tam eşleşme bulunamazsa, isim içinde geçen bir eşleşme ara
    for (const category of categories) {
        for (const item of category.items) {
            const itemName = item.name.toLowerCase().trim();
            if (itemName.includes(normalizedName) || normalizedName.includes(itemName)) {
                item.category = category.name;
                return item;
            }
        }
    }
    return null;
}

function updateMealQuantity(mealType, index, value) {
    saveState(); // Değişiklikten önce durumu kaydet
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType][index].quantity = parseFloat(value);
    renderMeals();
    calculateMacros();
}

function deleteMealItem(mealType, index) {
    saveState(); // Silmeden önce durumu kaydet
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType].splice(index, 1);
    renderMeals();
    calculateMacros();
    showNotification("Yemek silindi!");
}

function editMealItem(mealType, index) {
    const foodItem = weeks[selectedWeek - 1].days[selectedDay].meals[mealType][index];
    const food = findFood(foodItem.name);
    if (!food) return;

    const panel = document.getElementById('editFoodPanel');
    document.getElementById('editFoodIndex').value = `${mealType}_${index}`;
    document.getElementById('editFoodOriginalName').value = foodItem.name;
    document.getElementById('editFoodName').value = foodItem.name;
    document.getElementById('editFoodCalories').value = food.calories;
    document.getElementById('editFoodProtein').value = food.protein;
    document.getElementById('editFoodCarbs').value = food.carbs;
    document.getElementById('editFoodFat').value = food.fat;
    document.getElementById('editFoodMaxQuantity').value = food.maxQuantity;
    document.getElementById('editFoodMinQuantity').value = food.minQuantity || 0.5;
    document.getElementById('editFoodRole').value = food.role;
    document.getElementById('editFoodTags').value = food.tags.join(', ');
    document.getElementById('editFoodMealType').value = food.mealType;
    document.getElementById('editFoodKeto').checked = food.keto;
    document.getElementById('editFoodLowCarb').checked = food.lowcarb;
    panel.style.display = 'block';
}


function migrateSeasonData() {
    let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
    for (const cat in storedFoodList) {
        storedFoodList[cat].forEach(food => {
            if (food.season && !food.seasonRange) {
                food.seasonRange = convertSeasonToRange(food.season);
                delete food.season;
                console.log(`Yemek düzeltildi: ${food.name}, seasonRange: ${food.seasonRange}`);
            }
        });
    }
    localStorage.setItem("food_list", JSON.stringify(storedFoodList));
    categories = Object.keys(storedFoodList).map(cat => ({
        name: cat,
        items: storedFoodList[cat]
    }));
}

document.addEventListener("DOMContentLoaded", () => {
    migrateSeasonData();
});




function calculateWeeklyAverages() {
    const week = weeks[selectedWeek - 1];
    const weeklyTotals = {
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0
    };
    let dayCount = 0;

    // Haftanın tüm günlerini dolaş
    Object.values(week.days).forEach(day => {
        const dayMeals = day.meals;
        Object.values(dayMeals).forEach(meal => {
            meal.forEach(item => {
                const food = findFood(item.name);
                if (food) {
                    const quantity = item.quantity || 1;
                    weeklyTotals.calories += food.calories * quantity;
                    weeklyTotals.protein += food.protein * quantity;
                    weeklyTotals.carbs += food.carbs * quantity;
                    weeklyTotals.fat += food.fat * quantity;
                }
            });
        });
        dayCount++;
    });

    // Ortalamaları hesapla (7 güne böl), string yerine sayı döndür
    return {
        calories: dayCount > 0 ? weeklyTotals.calories / 7 : 0,
        protein: dayCount > 0 ? weeklyTotals.protein / 7 : 0,
        carbs: dayCount > 0 ? weeklyTotals.carbs / 7 : 0,
        fat: dayCount > 0 ? weeklyTotals.fat / 7 : 0
    };
}
function generateAnalysisText(type, day, actualValues, targetValues, weeklyData = null) {
    const isKeto = true; // Varsayılan olarak ketojenik beslenme (kullanıcı ayarı eklenebilir)
    const dietType = isKeto ? "ketojenik" : "low-carb";
    const carbLimit = isKeto ? 30 : 70; // Ketojenik için 30g, low-carb için 70g sınır

    // Değer farklarını hesapla
    const diffs = {
        calories: actualValues.calories - targetValues.calories,
        fat: actualValues.fat - targetValues.fat,
        protein: actualValues.protein - targetValues.protein,
        carbs: actualValues.carbs - targetValues.carbs
    };

    // Günlük veya haftalık metni oluştur
    let title, status, highlights, evaluation, suggestions;

    if (type === "daily") {
        title = `<h4>Günlük Makro Analizi (${day})</h4>`;
        status = `
            <p>Kalori: ${actualValues.calories.toFixed(0)} kcal (Hedef: ${targetValues.calories.toFixed(0)} kcal, ${diffs.calories > 0 ? '+' : ''}${diffs.calories.toFixed(0)} kcal ${diffs.calories >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Yağ: ${actualValues.fat.toFixed(0)} g (Hedef: ${targetValues.fat.toFixed(0)} g, ${diffs.fat > 0 ? '+' : ''}${diffs.fat.toFixed(0)} g ${diffs.fat >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Protein: ${actualValues.protein.toFixed(0)} g (Hedef: ${targetValues.protein.toFixed(0)} g, ${diffs.protein > 0 ? '+' : ''}${diffs.protein.toFixed(0)} g ${diffs.protein >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Karbonhidrat: ${actualValues.carbs.toFixed(0)} g (Hedef: ${targetValues.carbs.toFixed(0)} g, ${diffs.carbs > 0 ? '+' : ''}${diffs.carbs.toFixed(0)} g ${diffs.carbs >= 0 ? 'üstünde' : 'altında'})</p>
        `;

        // Değerlendirme
        evaluation = "<p><strong>Değerlendirme:</strong><br>";
        if (isKeto) {
            evaluation += `Harika bir iş çıkarıyorsun! Karbonhidrat alımını ${actualValues.carbs.toFixed(0)} g'da tutarak ketozis sürecini desteklemeye devam ediyorsun, bu ${dietType} beslenme için mükemmel bir seviye. `;
            if (diffs.protein > 0) {
                evaluation += `Protein hedefini ${diffs.protein.toFixed(0)} g aşmışsın, bu da kaslarını desteklemek için harika. `;
            } else {
                evaluation += `Protein alımın hedefin ${Math.abs(diffs.protein).toFixed(0)} g altında, kas kütleni desteklemek için biraz artırabilirsin. `;
            }
            if (diffs.calories < 0 || diffs.fat < 0) {
                evaluation += `Ancak kalori ve yağ alımın hedefin altında kalmış, bu da gün içinde enerjini düşürebilir.`;
            } else {
                evaluation += `Kalori ve yağ alımın dengeli, ketozis sürecin harika bir şekilde destekleniyor!`;
            }
        } else {
            evaluation += `Çok iyi gidiyorsun! Karbonhidrat alımını ${actualValues.carbs.toFixed(0)} g'da tutarak ${dietType} beslenmenin sınırları içinde kalmayı başarmışsın, bu koruma modun için harika bir denge. `;
            if (diffs.fat > 0 && diffs.protein > 0) {
                evaluation += `Yağ ve protein hedeflerini aşmışsın, bu da enerji seviyeni desteklemek için olumlu. `;
            }
            if (diffs.calories < 0) {
                evaluation += `Kalori hedefin ${Math.abs(diffs.calories).toFixed(0)} kcal altında, bu uzun vadede enerjini etkileyebilir.`;
            } else {
                evaluation += `Kalori alımın dengeli, harika bir denge yakalamışsın!`;
            }
        }
        evaluation += "</p>";

        // Öneriler
        suggestions = "<p><strong>Öneriler:</strong><br>";
        if (diffs.calories < 0) {
            suggestions += `- Kalori açığını kapatmak için ${isKeto ? 'sağlıklı yağ kaynaklarına yönelebilirsin. Örneğin, öğünlerine biraz daha avokado, zeytinyağı veya hindistancevizi yağı eklemek hem kalorini artırır hem de ketozis sürecini destekler.' : 'karbonhidratı artırmadan sağlıklı yağlar ve protein kaynakları ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı yoğurt eklemek harika bir seçenek.'} `;
        }
        if (diffs.fat < 0) {
            suggestions += `- Yağ alımın ${dietType} beslenme için biraz düşük kalmış. Öğünlerine daha fazla sağlıklı yağ ekleyerek ${isKeto ? 'ketozis sürecini destekleyebilirsin' : 'enerji seviyeni destekleyebilirsin'}. Örneğin, salatalarına zeytinyağı veya yemeklerine avokado eklemeyi deneyebilirsin. `;
        }
        if (diffs.protein < 0) {
            suggestions += `- Protein alımın kas kütleni desteklemek için biraz düşük kalmış. Öğünlerine daha fazla protein eklemek için haşlanmış yumurta, ızgara tavuk veya tam yağlı yoğurt gibi seçenekler deneyebilirsin. `;
        }
        if (diffs.carbs > (isKeto ? 30 : 70)) {
            suggestions += `- Karbonhidrat alımın ${dietType} için biraz yüksek kalmış. Bir sonraki öğünde karbonhidratı daha düşük tutarak ${isKeto ? 'ketozis sürecini destekleyebilirsin' : 'dengenizi sağlayabilirsin'}. Örneğin, karbonhidrat yerine daha fazla yeşil sebze (ıspanak, brokoli) tercih edebilirsin. `;
        }
        suggestions += `Hedefine çok yakınsın, böyle devam et!</p>`;
    } else {
        // Haftalık analiz
        title = `<h4>Haftalık Makro Trend Analizi</h4>`;
        status = `
            <p>Ortalama Kalori: ${actualValues.calories.toFixed(0)} kcal (Hedef: ${targetValues.calories.toFixed(0)} kcal, ${diffs.calories > 0 ? '+' : ''}${diffs.calories.toFixed(0)} kcal ${diffs.calories >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Yağ: ${actualValues.fat.toFixed(0)} g (Hedef: ${targetValues.fat.toFixed(0)} g, ${diffs.fat > 0 ? '+' : ''}${diffs.fat.toFixed(0)} g ${diffs.fat >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Protein: ${actualValues.protein.toFixed(0)} g (Hedef: ${targetValues.protein.toFixed(0)} g, ${diffs.protein > 0 ? '+' : ''}${diffs.protein.toFixed(0)} g ${diffs.protein >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Karbonhidrat: ${actualValues.carbs.toFixed(0)} g (Hedef: ${targetValues.carbs.toFixed(0)} g, ${diffs.carbs > 0 ? '+' : ''}${diffs.carbs.toFixed(0)} g ${diffs.carbs >= 0 ? 'üstünde' : 'altında'})</p>
        `;

        // Öne çıkanlar (haftalık verilerden analiz)
        highlights = "<p><strong>Öne Çıkanlar:</strong><br>";
        let maxCarbDay = { day: '', value: 0 };
        let minCalorieDay = { day: '', value: Infinity };
        let maxProteinDay = { day: '', value: 0 };

        const days = ['Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazar'];
        days.forEach((day, index) => {
            const dayData = weeklyData[index];
            if (dayData) {
                if (dayData.carbs > maxCarbDay.value) maxCarbDay = { day, value: dayData.carbs };
                if (dayData.calories < minCalorieDay.value) minCalorieDay = { day, value: dayData.calories };
                if (dayData.protein > maxProteinDay.value) maxProteinDay = { day, value: dayData.protein };
            }
        });

        if (maxCarbDay.value > carbLimit) {
            highlights += `- ${maxCarbDay.day} günü karbonhidrat ${maxCarbDay.value.toFixed(0)} g'a çıkmış, bu ${dietType} sınırını biraz aşmış olabilir.<br>`;
        }
        if (minCalorieDay.value < targetValues.calories) {
            highlights += `- ${minCalorieDay.day} günü kalori hedefin oldukça altında kalmış (${minCalorieDay.value.toFixed(0)} kcal, ${(minCalorieDay.value - targetValues.calories).toFixed(0)} kcal).<br>`;
        }
        if (maxProteinDay.value > targetValues.protein) {
            highlights += `- Protein alımın haftanın her günü hedefin üstünde, özellikle ${maxProteinDay.day} günü %${((maxProteinDay.value / targetValues.protein) * 100).toFixed(0)}'ye ulaşmış (${maxProteinDay.value.toFixed(0)} g).`;
        }
        highlights += "</p>";

        // Değerlendirme
        evaluation = "<p><strong>Değerlendirme:</strong><br>";
        if (isKeto) {
            evaluation += `Ketozis sürecini desteklemek için karbonhidratı ${actualValues.carbs.toFixed(0)} g'ın altında tutmayı başarmışsın, bu harika bir başarı! `;
            if (diffs.calories < 0 || diffs.fat < 0) {
                evaluation += `Yağ ve kalori alımın ise haftalık ortalamada hedefin biraz altında kalmış, bu da bazı günlerde enerjini etkilemiş olabilir. `;
            }
            if (diffs.protein > 0) {
                evaluation += `Protein alımın kas kütleni desteklemek için mükemmel bir seviyede.`;
            }
        } else {
            evaluation += `Low-carb beslenmende harika bir denge yakalamışsın! Karbonhidratı genelde ${carbLimit} g'ın altında tutmayı başarmışsın, ancak ${maxCarbDay.day} günü hafif bir aşım olmuş, bu dikkat gerektirebilir. `;
            if (diffs.calories < 0) {
                evaluation += `Kalori alımın haftalık ortalamada hedefin ${Math.abs(diffs.calories).toFixed(0)} kcal altında, bu da bazı günlerde enerjini etkilemiş olabilir. `;
            }
            if (diffs.fat > 0 && diffs.protein > 0) {
                evaluation += `Yağ ve protein alımın ise hedefin üstünde, bu da enerji seviyeni desteklemek için olumlu.`;
            }
        }
        evaluation += "</p>";

        // Öneriler
        suggestions = "<p><strong>Öneriler:</strong><br>";
        if (maxCarbDay.value > carbLimit) {
            suggestions += `- ${maxCarbDay.day} gibi karbonhidratın yükseldiği günleri dengelemek için düşük glisemik indeksli seçeneklere odaklanabilirsin. Örneğin, karbonhidratı artırmak yerine daha fazla yeşil sebze (ıspanak, kabak) tercih edebilirsin. `;
        }
        if (diffs.calories < 0) {
            suggestions += `- Kalori açığını kapatmak için ${isKeto ? 'sağlıklı yağlar ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı peynir eklemek hem kalorini artırır hem de ketozis sürecini destekler.' : 'karbonhidratı artırmadan sağlıklı yağlar ve protein kaynakları ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı peynir eklemek hem kalorini artırır hem de low-carb sınırlarını korur.'} `;
        }
        suggestions += `Harika bir hafta geçirmişsin, bu dengeyi koruyarak devam et!</p>`;
    }

    // Sorumluluk reddi
    const disclaimer = `
        <p class="disclaimer"><strong>Sorumluluk Reddi:</strong><br>
        Bu analiz ve öneriler, genel bilgilendirme ve motivasyon amaçlı hazırlanmıştır. Beslenme planınızı oluştururken veya değişiklik yaparken, özellikle bir sağlık sorununuz varsa, öncelikle doktorunuza veya bir diyetisyene danışmanız önemlidir. Her bireyin sağlık durumu, metabolizması ve ihtiyaçları farklıdır; bu nedenle, önerilerimiz sizin için uygun olmayabilir. Sağlıklı bir yaşam tarzı için profesyonel bir uzmandan destek almayı unutmayın.</p>
    `;

    return `${title}${status}${type === "weekly" ? highlights : ""}${evaluation}${suggestions}${disclaimer}`;
}

function calculateMacros() {
    console.log("Makrolar hesaplanıyor...");
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    const weight = patientData.weight || 70;
    const activityLevel = patientData.activity || 3;
    const bmr = 10 * weight + 6.25 * 175 - 5 * 30 + 5;
    const activityMultiplier = [0.8, 0.9, 1.0, 1.1, 1.2][activityLevel - 1];
    const tdee = bmr * activityMultiplier;

    const carbMultiplier = parseFloat(document.getElementById('carbMultiplier').value) || 0.5;
    const proteinMultiplier = parseFloat(document.getElementById('proteinMultiplier').value) || 2;
    const fatMultiplier = parseFloat(document.getElementById('fatMultiplier').value) || 0.8;

    const targetCarbs = weight * carbMultiplier * activityMultiplier;
    const targetProtein = weight * proteinMultiplier * activityMultiplier;
    const targetFat = weight * fatMultiplier * activityMultiplier;
    const targetCalories = targetCarbs * 4 + targetProtein * 4 + targetFat * 9;

    globalTargetCalories = targetCalories;
    globalTargetProtein = targetProtein;
    globalTargetCarbs = targetCarbs;
    globalTargetFat = targetFat;

    console.log(`Makro Hedefleri Güncellendi - Hasta: ${currentPatient || 'Varsayılan'}, Kalori: ${targetCalories.toFixed(0)}, Protein: ${targetProtein.toFixed(0)}, Karb: ${targetCarbs.toFixed(0)}, Yağ: ${targetFat.toFixed(0)}`);

    document.getElementById('bmrDisplay').value = bmr.toFixed(0);
    document.getElementById('targetCalories').value = targetCalories.toFixed(0);
    document.getElementById('targetProtein').value = targetProtein.toFixed(0);
    document.getElementById('targetCarbs').value = targetCarbs.toFixed(0);
    document.getElementById('targetFat').value = targetFat.toFixed(0);

    const weekIndex = selectedWeek ? Math.max(0, selectedWeek - 1) : 0;
    const day = selectedDay || "monday";

    if (!weeks[weekIndex] || !weeks[weekIndex].days[day]) {
        console.warn(`calculateMacros: Hafta ${weekIndex + 1} veya gün ${day} tanımsız!`, weeks);
        return;
    }

    const dayMeals = weeks[weekIndex].days[day].meals;
    const totals = {
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0
    };

    Object.values(dayMeals).forEach(meal => {
        meal.forEach(item => {
            const food = findFood(item.name);
            if (food) {
                const quantity = item.quantity || 1;
                totals.calories += food.calories * quantity;
                totals.protein += food.protein * quantity;
                totals.carbs += food.carbs * quantity;
                totals.fat += food.fat * quantity;
            }
        });
    });

    const proteinSapma = Math.abs(totals.protein - targetProtein) / targetProtein;
    const fatSapma = Math.abs(totals.fat - targetFat) / targetFat;
    let proteinStatus = proteinSapma <= 0.05 ? "±%5 içinde" : proteinSapma <= 0.10 ? "±%10 içinde" : `${(proteinSapma * 100).toFixed(1)}% saptı`;
    let fatStatus = fatSapma <= 0.05 ? "±%5 içinde" : fatSapma <= 0.10 ? "±%10 içinde" : `${(fatSapma * 100).toFixed(1)}% saptı`;
    let oneriler = [];

    if (proteinSapma > 0.05) {
        if (totals.protein < targetProtein) {
            oneriler.push("Protein eksik, öğleye hindi füme gibi yüksek proteinli bir yemek ekle.");
        } else {
            oneriler.push("Protein fazla, öğlede yüksek proteinli bir yemeğin katsayısını azalt veya sebze ekle.");
        }
    }
    if (fatSapma > 0.05) {
        if (totals.fat < targetFat) {
            oneriler.push("Yağ eksik, akşama zeytinyağı gibi yüksek yağlı bir yemek ekle.");
        } else {
            oneriler.push("Yağ fazla, akşamda yüksek yağlı bir yemeğin katsayısını azalt veya sebze ekle.");
        }
    }

    if (typeof showNotification === 'function') {
        showNotification(
            `Protein: ${totals.protein.toFixed(0)}/${targetProtein.toFixed(0)} (${proteinStatus})\n` +
            `Yağ: ${totals.fat.toFixed(0)}/${targetFat.toFixed(0)} (${fatStatus})\n` +
            (oneriler.length > 0 ? `Öneriler: ${oneriler.join(" ")}` : ""),
            proteinSapma > 0.10 || fatSapma > 0.10 ? "warning" : "success",
            5000
        );
    }

    const flexibility = parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1;
    const macroTotals = document.getElementById('macroTotals');
    const weeklyAverages = calculateWeeklyAverages();

    macroTotals.innerHTML = `
        <tr>
            <th>Makro</th>
            <th>Hedef</th>
            <th>Günlük (${day})</th>
            <th>Fark</th>
            <th>Haftalık Ortalama (Fark)</th>
        </tr>
        <tr class="${totals.calories > targetCalories * (1 + flexibility) ? 'macro-exceed' : totals.calories < targetCalories * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Kalori</td>
            <td>${targetCalories.toFixed(0)}</td>
            <td>${totals.calories.toFixed(0)}</td>
            <td>${(totals.calories - targetCalories).toFixed(0)}</td>
            <td>${weeklyAverages.calories.toFixed(0)} (${(weeklyAverages.calories - targetCalories).toFixed(0)})</td>
        </tr>
        <tr class="${totals.protein > targetProtein * (1 + flexibility) ? 'macro-exceed' : totals.protein < targetProtein * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Protein</td>
            <td>${targetProtein.toFixed(0)}</td>
            <td>${totals.protein.toFixed(0)}</td>
            <td>${(totals.protein - targetProtein).toFixed(0)}</td>
            <td>${weeklyAverages.protein.toFixed(0)} (${(weeklyAverages.protein - targetProtein).toFixed(0)})</td>
        </tr>
        <tr class="${totals.carbs > targetCarbs * (1 + flexibility) ? 'macro-exceed' : totals.carbs < targetCarbs * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Karb.</td>
            <td>${targetCarbs.toFixed(0)}</td>
            <td>${totals.carbs.toFixed(0)}</td>
            <td>${(totals.carbs - targetCarbs).toFixed(0)}</td>
            <td>${weeklyAverages.carbs.toFixed(0)} (${(weeklyAverages.carbs - targetCarbs).toFixed(0)})</td>
        </tr>
        <tr class="${totals.fat > targetFat * (1 + flexibility) ? 'macro-exceed' : totals.fat < targetFat * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Yağ</td>
            <td>${targetFat.toFixed(0)}</td>
            <td>${totals.fat.toFixed(0)}</td>
            <td>${(totals.fat - targetFat).toFixed(0)}</td>
            <td>${weeklyAverages.fat.toFixed(0)} (${(weeklyAverages.fat - targetFat).toFixed(0)})</td>
        </tr>
    `;

    const macroDisplay = document.querySelector('.macro-display');
    if (macroDisplay) {
        const existingCharts = macroDisplay.querySelector('.macro-charts');
        if (existingCharts) {
            existingCharts.remove();
        }

        const chartsDiv = document.createElement('div');
        chartsDiv.className = 'macro-charts';
        chartsDiv.innerHTML = `
            <div class="chart-container">
                <h4>Günlük (${day})</h4>
                <canvas id="dailyMacroChart" width="150" height="150"></canvas>
            </div>
            <div class="chart-container">
                <h4>Haftalık Ortalama</h4>
                <canvas id="weeklyMacroChart" width="150" height="150"></canvas>
            </div>
        `;
        macroDisplay.appendChild(chartsDiv);
    }

    const targetValues = {
        calories: targetCalories,
        carbs: targetCarbs,
        protein: targetProtein,
        fat: targetFat
    };

    drawMacroChart('dailyMacroChart', {
        calories: totals.calories / targetCalories,
        carbs: totals.carbs / targetCarbs,
        protein: totals.protein / targetProtein,
        fat: totals.fat / targetFat
    }, totals, targetValues, `Günlük (${day})`);

    drawMacroChart('weeklyMacroChart', {
        calories: weeklyAverages.calories / targetCalories,
        carbs: weeklyAverages.carbs / targetCarbs,
        protein: weeklyAverages.protein / targetProtein,
        fat: weeklyAverages.fat / targetFat
    }, weeklyAverages, targetValues, 'Haftalık Ortalama');
    updateCompatibilityStatus();
}

function drawMacroChart(canvasId, data, actualValues = null, targetValues = null, title = '', type = 'daily', weeklyData = null) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`Canvas with ID ${canvasId} not found!`);
        return;
    }
    const ctx = canvas.getContext('2d');

    console.log(`Canvas ${canvasId} dimensions: ${canvas.width}x${canvas.height}`);

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const maxRadius = canvas.width >= 300 ? 120 : canvas.width * 0.4;
    const ringWidth = canvas.width >= 300 ? 24 : canvas.width * 0.08;
    const gap = canvas.width >= 300 ? 2 : 1;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const rings = [
        { name: 'Kalori', value: data.calories, actual: actualValues?.calories || 0, target: targetValues?.calories || 0, radius: maxRadius, color: 'rgba(40, 167, 69, 0.8)', excessColor: 'rgba(20, 120, 40, 0.8)' },
        { name: 'Yağ', value: data.fat, actual: actualValues?.fat || 0, target: targetValues?.fat || 0, radius: maxRadius - ringWidth - gap, color: 'rgba(255, 193, 7, 0.8)', excessColor: 'rgba(200, 150, 0, 0.8)' },
        { name: 'Protein', value: data.protein, actual: actualValues?.protein || 0, target: targetValues?.protein || 0, radius: maxRadius - 2 * (ringWidth + gap), color: 'rgba(0, 123, 255, 0.8)', excessColor: 'rgba(0, 80, 200, 0.8)' },
        { name: 'Karb.', value: data.carbs, actual: actualValues?.carbs || 0, target: targetValues?.carbs || 0, radius: maxRadius - 3 * (ringWidth + gap), color: 'rgba(220, 53, 69, 0.8)', excessColor: 'rgba(180, 30, 40, 0.8)' }
    ];

    function drawRing(context, value, radius, color, excessColor, centerX, centerY, ringWidth) {
        const startAngle = -Math.PI / 2;
        const maxAngle = 2 * Math.PI;
        let fillAngle = maxAngle * Math.min(value, 1);
        context.beginPath();
        context.arc(centerX, centerY, radius, startAngle, startAngle + fillAngle);
        context.lineWidth = ringWidth;
        context.strokeStyle = color;
        context.stroke();
        if (value > 1) {
            const excessAngle = maxAngle * (value - 1);
            context.beginPath();
            context.arc(centerX, centerY, radius, startAngle, startAngle + excessAngle);
            context.lineWidth = ringWidth;
            context.strokeStyle = excessColor;
            context.stroke();
        }
    }

    rings.forEach(ring => drawRing(ctx, ring.value, ring.radius, ring.color, ring.excessColor, centerX, centerY, ringWidth));

    if (!actualValues || !targetValues) {
        return;
    }

    let tooltip = document.getElementById(`${canvasId}-tooltip`);
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = `${canvasId}-tooltip`;
        tooltip.className = 'macro-tooltip';
        document.body.appendChild(tooltip);
    }

    const addTooltipListeners = (targetCanvas, targetRings, targetCenterX, targetCenterY, targetRingWidth) => {
        targetCanvas.addEventListener('mousemove', (e) => {
            const rect = targetCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const dx = x - targetCenterX;
            const dy = y - targetCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            let activeRing = null;
            for (const ring of targetRings) {
                const outerRadius = ring.radius + targetRingWidth / 2;
                const innerRadius = ring.radius - targetRingWidth / 2;
                if (distance >= innerRadius && distance <= outerRadius) {
                    activeRing = ring;
                    break;
                }
            }

            if (activeRing && activeRing.actual !== undefined && activeRing.target !== undefined) {
                const difference = activeRing.actual - activeRing.target;
                tooltip.innerHTML = `${activeRing.name}: ${activeRing.actual.toFixed(0)} / ${activeRing.target.toFixed(0)} (Fark: ${difference.toFixed(0)})`;
                tooltip.style.display = 'block';
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY + 10}px`;
            } else {
                tooltip.style.display = 'none';
            }
        });

        targetCanvas.addEventListener('mouseout', () => {
            tooltip.style.display = 'none';
        });
    };

    addTooltipListeners(canvas, rings, centerX, centerY, ringWidth);

    canvas.addEventListener('click', () => {
        const modal = document.getElementById('macroModal');
        const modalTitle = document.getElementById('macroModalTitle');
        const modalChart = document.getElementById('macroModalChart');
        const modalAnalysis = document.getElementById('macroModalAnalysis');
        if (!modal || !modalTitle || !modalChart || !modalAnalysis) {
            console.error('Modal elements not found:', { modal, modalTitle, modalChart, modalAnalysis });
            return;
        }

        // Popup canvas'inin boyutlarını açıkça ayarla (kare olacak şekilde)
        modalChart.width = 300;
        modalChart.height = 300;
        const modalCtx = modalChart.getContext('2d');
        console.log(`Popup canvas dimensions: ${modalChart.width}x${modalChart.height}`);

        modalTitle.textContent = title || 'Makro Grafiği';

        modalCtx.clearRect(0, 0, modalChart.width, modalChart.height);
        const modalCenterX = modalChart.width / 2;
        const modalCenterY = modalChart.height / 2;
        const modalMaxRadius = Math.min(modalChart.width, modalChart.height) * 0.4;
        const modalRingWidth = modalMaxRadius * 0.2;
        const modalGap = 2;

        const modalRings = [
            { name: 'Kalori', value: data.calories, actual: actualValues?.calories || 0, target: targetValues?.calories || 0, radius: modalMaxRadius, color: 'rgba(40, 167, 69, 0.8)', excessColor: 'rgba(20, 120, 40, 0.8)' },
            { name: 'Yağ', value: data.fat, actual: actualValues?.fat || 0, target: targetValues?.fat || 0, radius: modalMaxRadius - modalRingWidth - modalGap, color: 'rgba(255, 193, 7, 0.8)', excessColor: 'rgba(200, 150, 0, 0.8)' },
            { name: 'Protein', value: data.protein, actual: actualValues?.protein || 0, target: targetValues?.protein || 0, radius: modalMaxRadius - 2 * (modalRingWidth + modalGap), color: 'rgba(0, 123, 255, 0.8)', excessColor: 'rgba(0, 80, 200, 0.8)' },
            { name: 'Karb.', value: data.carbs, actual: actualValues?.carbs || 0, target: targetValues?.carbs || 0, radius: modalMaxRadius - 3 * (modalRingWidth + modalGap), color: 'rgba(220, 53, 69, 0.8)', excessColor: 'rgba(180, 30, 40, 0.8)' }
        ];

        modalRings.forEach(ring => {
            console.log('Drawing popup ring:', ring);
            drawRing(modalCtx, ring.value, ring.radius, ring.color, ring.excessColor, modalCenterX, modalCenterY, modalRingWidth);
        });

        addTooltipListeners(modalChart, modalRings, modalCenterX, modalCenterY, modalRingWidth);

        let day = null;
        try {
            day = title.includes('Günlük') && title.match(/\(([^)]+)\)/) ? title.match(/\(([^)]+)\)/)[1] : null;
        } catch (error) {
            console.error('Error extracting day from title:', title, error);
            day = 'Bilinmeyen Gün';
        }

        const analysisText = generateAnalysisText(type, day, actualValues, targetValues, weeklyData);
        console.log('Generated Analysis Text:', analysisText);
        modalAnalysis.innerHTML = analysisText || '<p>Analiz metni oluşturulamadı.</p>';

        modal.style.display = 'flex';

        const closeBtn = document.querySelector('.macro-modal-close');
        if (closeBtn) {
            closeBtn.onclick = () => {
                modal.style.display = 'none';
            };
        }

        window.onclick = (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    });
}
function showNotification(message, type = 'success', duration = 5000) {
    console.log(`Bildirim: ${message} (${type})`);
    const notification = document.getElementById('notification');
    notification.className = `alert alert-${type}`;
    notification.innerHTML = message.replace(/\n/g, '<br>');
    notification.style.display = 'block';
    setTimeout(() => { notification.style.display = 'none'; }, duration);
}

function handlePatientChange() {
    currentPatient = document.getElementById('patientSelect').value;
    console.log("Hasta seçildi:", currentPatient);

    if (currentPatient) {
        // Hasta verisini ve planını yükle
        loadPatientData();
        loadCategories();
        calculateMacros();

        // --- HASTAYA AİT PLANLARI (weeks) YÜKLE ---
        let loadedWeeks = null;

        // 1. window değişkeni (öncelik)
        if (window[`weeks_patient_${currentPatient}`] && Array.isArray(window[`weeks_patient_${currentPatient}`]) && window[`weeks_patient_${currentPatient}`].length > 0) {
            loadedWeeks = window[`weeks_patient_${currentPatient}`];
        }
        // 2. localStorage (JSON'dan gelmiş olabilir)
        else if (localStorage.getItem(`patient_${currentPatient}`)) {
            try {
                const patientObj = JSON.parse(localStorage.getItem(`patient_${currentPatient}`));
                if (patientObj && Array.isArray(patientObj.weeks) && patientObj.weeks.length > 0) {
                    loadedWeeks = patientObj.weeks;
                }
            } catch (e) {
                console.warn("localStorage weeks parse hatası:", e);
            }
        }
        // 3. window.patients (JSON'dan topluca yüklenmişse)
        else if (window.patients && window.patients[`patient_${currentPatient}`] && Array.isArray(window.patients[`patient_${currentPatient}`].weeks) && window.patients[`patient_${currentPatient}`].weeks.length > 0) {
            loadedWeeks = window.patients[`patient_${currentPatient}`].weeks;
        }

        // Sonuç: Eğer weeks bulunduysa ata, yoksa sıfırdan başlat
        if (loadedWeeks && loadedWeeks.length > 0) {
            window.weeks = JSON.parse(JSON.stringify(loadedWeeks));
        } else {
            window.weeks = [];
            initializeWeeks();
        }

        // Seçili hafta ve gün sıfırla
        selectedWeek = 1;
        selectedDay = "monday";

        renderWeekTabs();
        renderDayTabs();
        renderMeals();
        showNotification(`Hasta "${currentPatient}" seçildi ve planı yüklendi!`, 'success', 3000);
    } else {
        currentPatient = null;
        loadPatientData();
        loadCategories();
        calculateMacros();
        renderMeals();
        showNotification("Hasta seçimi kaldırıldı.", 'warning', 3000);
    }
}

        function loadPatientData() {
            if (!currentPatient) return;
            const patientData = JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}');
            document.getElementById('likedFoodsDisplay').value = patientData.likedFoods ? patientData.likedFoods.join(', ') : '';
            document.getElementById('dislikedFoodsDisplay').value = patientData.dislikedFoods ? patientData.dislikedFoods.join(', ') : '';
            document.getElementById('likedFoods').innerHTML = patientData.likedFoods ? `Sevdiği: ${patientData.likedFoods.join(', ')}` : '';
            document.getElementById('dislikedFoods').innerHTML = patientData.dislikedFoods ? `Sevmediği: ${patientData.dislikedFoods.join(', ')}` : '';
        }

        function updatePatientPreferences() {
            if (!currentPatient) return;
            const likedFoods = document.getElementById('likedFoodsDisplay').value.split(',').map(f => f.trim()).filter(f => f);
            const dislikedFoods = document.getElementById('dislikedFoodsDisplay').value.split(',').map(f => f.trim()).filter(f => f);
            const patientData = JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}');
            patientData.likedFoods = likedFoods;
            patientData.dislikedFoods = dislikedFoods;
            localStorage.setItem(`patient_${currentPatient}`, JSON.stringify(patientData));
            loadPatientData();
            loadCategories();
            showNotification("Hasta tercihleri güncellendi!");
        }

        // Hasta ekleme fonksiyonu (güncellenmiş)
// Hasta ekleme fonksiyonu (güncellenmiş)
function addPatient() {
    openPatientFormModal('add');
}

// Hasta düzenleme fonksiyonu (güncellenmiş)
function editPatient() {
    if (!currentPatient) {
        showNotification("Önce bir hasta seçin!", 'warning', 3000);
        return;
    }
    openPatientFormModal('edit', currentPatient);
}


// Hasta formu kaydetme fonksiyonu (düzeltilmiş)
async function handlePatientFormSubmit(event) {
    event.preventDefault();
  closeAddFoodModal();

    // Form elemanlarını al
    const userNameInput = document.getElementById('userName');
    const userWeightInput = document.getElementById('userWeight');
    const userActivityInput = document.getElementById('userActivity');
    const likedFoodsInput = document.getElementById('likedFoodsInput');
    const dislikedFoodsInput = document.getElementById('dislikedFoodsInput');

    if (!userNameInput || !userWeightInput || !userActivityInput || !likedFoodsInput || !dislikedFoodsInput) {
        console.warn("Hasta formu elemanları bulunamadı!");
        showNotification("Form elemanları eksik, lütfen sayfayı yenileyin!", 'error', 3000);
        return;
    }

    const name = userNameInput.value.trim();
    const isEditing = userNameInput.disabled;

    // İsim benzersizliğini kontrol et (düzenleme modunda değilse)
    if (!isEditing && localStorage.getItem(`patient_${name}`)) {
        showNotification("Bu isimde bir hasta zaten mevcut!", 'warning', 3000);
        return;
    }

    // Form verilerini al
    const weight = parseFloat(userWeightInput.value) || 70;
    const activity = parseInt(userActivityInput.value) || 3;
    const likedFoods = likedFoodsInput.value.split(',').map(f => f.trim()).filter(f => f);
    const dislikedFoods = dislikedFoodsInput.value.split(',').map(f => f.trim()).filter(f => f);

    // Hasta verilerini oluştur
    const patientData = {
        name,
        weight,
        activity,
        likedFoods,
        dislikedFoods
    };

    try {
        // localStorage'a kaydet
        localStorage.setItem(`patient_${name}`, JSON.stringify(patientData));

        // window.patients'a ekle
        if (!window.patients) window.patients = {};
        window.patients[`patient_${name}`] = patientData;

        // Eğer düzenleme modundaysa ve isim değişmediyse, eski veriyi koru
        if (isEditing && name !== currentPatient) {
            localStorage.removeItem(`patient_${currentPatient}`);
            delete window.patients[`patient_${currentPatient}`];
        }

        currentPatient = name;

        // Hasta seçimini güncelle
        loadPatientSelect();
        document.getElementById('patientSelect').value = name;
        handlePatientChange();

        // GitHub'a güncelle
        await updateGitHubData();

        showNotification(`Hasta "${name}" başarıyla ${isEditing ? 'düzenlendi' : 'eklendi'}!`, 'success', 3000);
        closePatientFormModal();
    } catch (error) {
        console.error("Hasta kaydetme hatası:", error);
        showNotification("Hasta kaydedilirken bir hata oluştu!", 'error', 3000);
    }
}

        function deletePatient() {
            if (!currentPatient) {
                showNotification("Önce bir hasta seçin!", 'warning');
                return;
            }
            if (confirm(`${currentPatient} adlı hastayı silmek istiyor musunuz?`)) {
                localStorage.removeItem(`patient_${currentPatient}`);
                currentPatient = null;
                loadPatientSelect();
                document.getElementById('patientSelect').value = '';
                handlePatientChange();
                showNotification("Hasta silindi!");
            }
        }

        function loadPatientSelect() {
    const patientSelect = document.getElementById('patientSelect');
    if (!patientSelect) {
        console.error("patientSelect elementi bulunamadı! DOM'da 'patientSelect' ID'sine sahip bir eleman yok.");
        return;
    }

    // localStorage'dan hastaları al
    const localPatients = Object.keys(localStorage)
        .filter(key => key.startsWith('patient_'))
        .map(key => JSON.parse(localStorage.getItem(key)));

    // window.patients ile senkronize et
    if (!window.patients) window.patients = {};
    localPatients.forEach(patient => {
        window.patients[`patient_${patient.name}`] = patient;
    });

    const patients = Object.values(window.patients);
    console.log("Yüklenen hastalar:", patients);

    if (patients.length === 0) {
        patientSelect.innerHTML = '<option value="">Hasta Yok</option>';
    } else {
        patientSelect.innerHTML = '<option value="">Hasta Seç</option>' + 
            patients.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
    }
}

// Modal açma/kapatma fonksiyonları
function openPatientFormModal(mode = 'add', patientName = '') {
    const modal = document.getElementById('patientFormModal');
    const formTitle = document.getElementById('patientFormTitle');
    const form = document.getElementById('patientForm');
    if (!modal || !formTitle || !form) {
        console.warn("Hasta formu elemanları bulunamadı!");
        showNotification("Form elemanları eksik, lütfen sayfayı yenileyin!", 'error', 3000);
        return;
    }

    // Formu sıfırla
    form.reset();
    document.getElementById('userName').disabled = false;

    if (mode === 'edit' && patientName) {
        // Düzenleme modu: Seçili hastanın bilgilerini doldur
        formTitle.textContent = 'Hasta Düzenle';
        const patientData = JSON.parse(localStorage.getItem(`patient_${patientName}`) || '{}');
        document.getElementById('userName').value = patientName || '';
        document.getElementById('userName').disabled = true; // İsim değiştirilemez
        document.getElementById('userWeight').value = patientData.weight || 70;
        document.getElementById('userActivity').value = patientData.activity || 3;
        document.getElementById('likedFoodsInput').value = patientData.likedFoods?.join(', ') || '';
        document.getElementById('dislikedFoodsInput').value = patientData.dislikedFoods?.join(', ') || '';
    } else {
        // Ekleme modu: Boş form
        formTitle.textContent = 'Hasta Ekle';
    }

    modal.style.display = 'flex';
}

function closePatientFormModal() {
    const modal = document.getElementById('patientFormModal');
    if (modal) {
        modal.style.display = 'none';
    }
}


async function testGitHubToken(token) {
    const testUrl = "https://api.github.com/user";
    try {
        const response = await fetch(testUrl, {
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });
        if (response.ok) {
            const data = await response.json();
            console.log("Token geçerli, kullanıcı:", data.login);
            return true;
        } else {
            const errorData = await response.json();
            console.error("Token testi başarısız:", errorData.message);
            return false;
        }
    } catch (error) {
        console.error("Hata:", error);
        return false;
    }
}

        document.getElementById('exportButton').addEventListener('click', exportAllData);


        async function exportAllData() {
    const token = document.getElementById('githubToken')?.value || "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";
    const repoOwner = "mustafasacar35";
    const repoName = "beslenme";
    const filePath = "sistem_JSON.json";
    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}`;




    const data = {
    categories,
    rules,
    mealTemplates,
    compatibilityTable,
    patients: Object.keys(localStorage)
        .filter(key => key.startsWith('patient_'))
        .reduce((obj, key) => {
            obj[key] = JSON.parse(localStorage.getItem(key));
            // Her hastanın planını da ekle
            obj[key].weeks = window[`weeks_${key}`] || [];
            return obj;
        }, {})
};

    // window.patients'ı da güncelle
    window.patients = data.patients;

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));

    try {
        const response = await fetch(apiUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });
        const fileData = await response.json();
        const sha = fileData.sha;

        const updateResponse = await fetch(apiUrl, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                message: "Veriler güncellendi",
                content: content,
                sha: sha,
                branch: "main"
            })
        });

        if (updateResponse.ok) {
            showNotification("Veriler GitHub'a başarıyla yüklendi!", "success");
            console.log("GitHub güncelleme başarılı!");
        } else {
            const errorData = await updateResponse.json();
            showNotification("GitHub'a yükleme başarısız: " + errorData.message, "warning");
            console.error("GitHub güncelleme hatası:", errorData);
        }
    } catch (error) {
        showNotification("Bir hata oluştu: " + error.message, "warning");
        console.error("Hata:", error);
    }
}

        function importAllData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);

            // Kategorileri yükle
            categories.length = 0;
            categories.push(...data.categories);

            // Haftaları yükle
            weeks.length = 0;
            weeks.push(...data.weeks);

            // Kuralları yükle ve eksik alanları tamamla
            rules.length = 0;
            rules.push(...data.rules.map(rule => {
                if (rule.type === 'frequency') {
                    rule.criteria = rule.criteria || {}; // criteria yoksa boş nesne
                } else if (rule.type === 'pairWith' || rule.type === 'avoidPair') {
                    rule.criteria1 = rule.criteria1 || {}; // criteria1 yoksa boş nesne
                    rule.criteria2 = rule.criteria2 || {}; // criteria2 yoksa boş nesne
                }
                return rule;
            }));
            console.log('Yüklenen kurallar:', rules);
            // Diğer verileri yükle
            mealTemplates.length = 0;
            mealTemplates.push(...data.mealTemplates);
            compatibilityTable.length = 0;
            compatibilityTable.push(...data.compatibilityTable);
            Object.entries(data.patients).forEach(([key, value]) => localStorage.setItem(key, JSON.stringify(value)));

            // Arayüzü güncelle
            loadCategories();
            renderWeekTabs();
            renderDayTabs();
            renderMeals();
            loadPatientSelect();
            loadRules();
            loadMealTemplates();
            loadCompatibilityRules();
            calculateMacros();
            showNotification("Veriler içe aktarıldı!");
        } catch (error) {
            console.error('Dosya yüklenirken hata:', error);
            showNotification('Geçersiz dosya formatı!', 'danger');
        }
    };
    reader.readAsText(file);
}

        function exportToTXT() {
            let txtContent = "";
            weeks.forEach((week, wIndex) => {
                txtContent += `Hafta ${wIndex + 1}\n`;
                Object.entries(week.days).forEach(([day, dayData]) => {
                    txtContent += `  ${day.charAt(0).toUpperCase() + day.slice(1)}:\n`;
                    Object.entries(dayData.meals).forEach(([mealType, items]) => {
                        txtContent += `    ${mealType.charAt(0).toUpperCase() + mealType.slice(1)}:\n`;
                        items.forEach(item => {
                            const food = findFood(item.name);
                            txtContent += `      - ${item.name} (${item.quantity || 1}x): ${food.calories * (item.quantity || 1)} kcal, ${food.protein * (item.quantity || 1)}g protein, ${food.carbs * (item.quantity || 1)}g karb, ${food.fat * (item.quantity || 1)}g yağ\n`;
                        });
                    });
                });
                txtContent += "\n";
            });
            const blob = new Blob([txtContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'nutrition_plan.txt';
            a.click();
            URL.revokeObjectURL(url);
            showNotification("TXT olarak dışa aktarıldı!");
        }
function exportTemplatesToTXT() {
    let txtContent = "Öğün Şablonları\n\n";
    mealTemplates.forEach((template, index) => {
        txtContent += `Şablon ${index + 1}: ${template.mealType} (Haftada ${template.frequency} Gün)\n`;
        template.items.forEach(item => {
            txtContent += `  - ${item.keyword} (${item.role}, ${item.quantity}x)\n`;
        });
        txtContent += "\n";
    });
    const blob = new Blob([txtContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'meal_templates.txt';
    a.click();
    URL.revokeObjectURL(url);
    showNotification("Şablonlar TXT olarak dışa aktarıldı!");
}
function importTemplatesFromTXT(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const lines = e.target.result.split('\n');
        let newTemplates = [];
        let currentTemplate = null;

        lines.forEach(line => {
            line = line.trim();
            if (!line) return;

            // Şablon başlığını algıla
            if (line.startsWith('Şablon')) {
                if (currentTemplate) newTemplates.push(currentTemplate);
                const match = line.match(/Şablon \d+: (\w+) \(Haftada (\d+) Gün\)/);
                if (match) {
                    currentTemplate = {
                        mealType: match[1],
                        frequency: parseInt(match[2]),
                        items: []
                    };
                }
            }
            // Öğeleri algıla
            else if (line.startsWith('-') && currentTemplate) {
                const itemMatch = line.match(/- (.+) \((\w+), (\d+)x\)/);
                if (itemMatch) {
                    currentTemplate.items.push({
                        keyword: itemMatch[1],
                        role: itemMatch[2],
                        quantity: parseInt(itemMatch[3])
                    });
                }
            }
        });
        if (currentTemplate) newTemplates.push(currentTemplate);

        // Mevcut şablonlarla çakışmaları kontrol et
        let addedCount = 0;
        newTemplates.forEach(newTemplate => {
            const isDuplicate = mealTemplates.some(existing => 
                existing.mealType === newTemplate.mealType &&
                existing.frequency === newTemplate.frequency &&
                existing.items.length === newTemplate.items.length &&
                existing.items.every((item, i) => 
                    item.keyword === newTemplate.items[i].keyword &&
                    item.role === newTemplate.items[i].role &&
                    item.quantity === newTemplate.items[i].quantity
                )
            );
            if (!isDuplicate) {
                mealTemplates.push(newTemplate);
                addedCount++;
            }
        });

        loadMealTemplates();
        showNotification(`${addedCount} yeni şablon eklendi! (Tekrarlananlar eklenmedi)`);
    };
    reader.readAsText(file);
}

function importFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileExtension = file.name.split('.').pop().toLowerCase();
    console.log("Yüklenen dosya:", file.name, "Uzantı:", fileExtension);

    const reader = new FileReader();
    reader.onload = function(e) {
        const data = e.target.result;
        console.log("Dosya içeriği:", data);

        let currentMealType = null;
        let currentItems = [];
        let mealIndex = { lunch: 1, dinner: 1 };
        const existingKeys = new Set();
        const newFoods = [];

        const filterPatterns = [
            /^\*/i,
            /^-/,
            /^\d+\.\s*hafta/i,
            /gün/i,
            /^\s*$/ // Boş satırları filtrele
        ];

        if (fileExtension === 'xlsx' || fileExtension === 'xls') {
            const workbook = XLSX.read(data, { type: "binary" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            rows.forEach((row) => {
                const line = row[0] ? row[0].toString().trim() : "";
                if (!line || filterPatterns.some(p => p.test(line.toLowerCase()))) return;

                if (line.match(/lunch\s*\(1x\)/i) || /öğle/i.test(line)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "lunch";
                    currentItems = [];
                    const mealContent = line.replace(/lunch\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("Öğle öğünü tespit edildi:", currentItems);
                    return;
                }

                if (line.match(/dinner\s*\(1x\)/i) || /akşam/i.test(line)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "dinner";
                    currentItems = [];
                    const mealContent = line.replace(/dinner\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("Akşam öğünü tespit edildi:", currentItems);
                    return;
                }

                if (currentMealType && row.length >= 5 && line.length > 2) {
                    const name = line;
                    const calories = parseFloat(row[1]) || 0;
                    const carbs = parseFloat(row[2]) || 0;
                    const protein = parseFloat(row[3]) || 0;
                    const fat = parseFloat(row[4]) || 0;
                    if (calories > 0 || carbs > 0 || protein > 0 || fat > 0) {
                        currentItems.push({ name, calories, carbs, protein, fat });
                    }
                }
            });
        } else if (fileExtension === 'txt') {
            const lines = data.split('\n');
            lines.forEach((line) => {
                const trimmedLine = line.trim();
                if (!trimmedLine || filterPatterns.some(p => p.test(trimmedLine.toLowerCase()))) return;

                if (trimmedLine.match(/lunch\s*\(1x\)/i) || /öğle/i.test(trimmedLine)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "lunch";
                    currentItems = [];
                    const mealContent = trimmedLine.replace(/lunch\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("TXT: Öğle öğünü tespit edildi:", currentItems);
                    return;
                }

                if (trimmedLine.match(/dinner\s*\(1x\)/i) || /akşam/i.test(trimmedLine)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "dinner";
                    currentItems = [];
                    const mealContent = trimmedLine.replace(/dinner\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("TXT: Akşam öğünü tespit edildi:", currentItems);
                    return;
                }
            });
        } else {
            showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
            return;
        }

        if (currentItems.length > 0 && currentMealType) {
            saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
        }

        let newCategory = categories.find(cat => cat.name === "Yeni Eklenenler");
        if (!newCategory) {
            newCategory = { name: "Yeni Eklenenler", items: [] };
            categories.push(newCategory);
        }
        newFoods.forEach(food => {
            if (!newCategory.items.some(item => item.name.toLowerCase() === food.name.toLowerCase())) {
                newCategory.items.push(food);
            }
        });

        console.log("Son mealTemplates:", mealTemplates);
        console.log("Son newFoods:", newFoods);

        loadMealTemplates();
        loadCategories();
        showNotification(`Dosyadan ${mealIndex.lunch + mealIndex.dinner - 2} şablon ve ${newFoods.length} yeni yemek eklendi!`, "success");
    };

    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        reader.readAsBinaryString(file);
    } else if (fileExtension === 'txt') {
        reader.readAsText(file);
    } else {
        showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
    }
}


        function importFromTXT(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const lines = e.target.result.split('\n');
                let currentCategory = null;
                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('-')) return;
                    if (line.match(/^[A-ZÇĞİÖŞÜ]+$/)) {
                        currentCategory = line;
                        if (!categories.some(cat => cat.name === currentCategory)) {
                            categories.push({ name: currentCategory, items: [] });
                        }
                    } else if (line.includes(':')) {
                        const [name, details] = line.split(':');
                        const [calories, protein, carbs, fat] = details.match(/[\d.]+/g).map(Number);
                        const category = categories.find(cat => cat.name === currentCategory);
                        if (category) {
                            category.items.push({
                                name: name.trim(),
                                calories,
                                protein,
                                carbs,
                                fat,
                                maxQuantity: 1,
                                tags: [],
                                role: "mainDish",
                                mealType: "breakfast,lunch,dinner",
                                keto: dietMode === 'keto',
                                lowcarb: true
                            });
                        }
                    }
                });
                loadCategories();
                showNotification("TXT'dan yemekler eklendi!");
            };
            reader.readAsText(file);
        }

        function clearCache() {
            localStorage.clear();
            currentPatient = null;
            weeks.length = 0;
            initializeWeeks();
            loadPatientSelect();
            loadCategories();
            renderWeekTabs();
            renderDayTabs();
            renderMeals();
            calculateMacros();
            showNotification("Cache temizlendi!");
        }

        // addRule fonksiyonu
// addRule fonksiyonu
function addRule() {
    console.log("addRule fonksiyonu çağrıldı!");

    const frequencyForm = document.getElementById('frequencyRuleForm');
    const dependOnForm = document.getElementById('dependOnRuleForm');
    const compatibilityForm = document.getElementById('compatibilityRuleForm'); // Yeni eklenen form
    let activeForm = null;
    let ruleType = null;

    if (frequencyForm && frequencyForm.style.display !== 'none') {
        activeForm = frequencyForm;
        ruleType = 'frequency';
    } else if (dependOnForm && dependOnForm.style.display !== 'none') {
        activeForm = dependOnForm;
        ruleType = 'dependOn';
    } else if (compatibilityForm && compatibilityForm.style.display !== 'none') {
        activeForm = compatibilityForm;
        ruleType = 'compatibility';
    } else {
        console.warn("Hiçbir kural formu aktif değil!");
        return;
    }

    const editIndex = activeForm.dataset.editIndex;
    const isEditing = editIndex !== undefined && editIndex !== '' && rules[editIndex];

    let rule = { type: ruleType };

    if (isEditing) {
        rule.id = rules[editIndex].id;
        if (!rule.id) {
            console.warn(`Düzenlenen kuralda ID eksik, index: ${editIndex}`, rules[editIndex]);
            rule.id = Math.max(...rules.map(r => r.id || 0)) + 1;
        }
    } else {
        const maxId = rules.length > 0 ? Math.max(...rules.map(r => r.id || 0)) : 0;
        rule.id = maxId + 1;
    }

    if (ruleType === 'frequency' && activeForm === frequencyForm) {
        rule.frequency = parseInt(document.getElementById('freqCount')?.value) || 1;
        rule.scope = document.getElementById('freqScope')?.value || 'meal';
        rule.frequencyType = document.getElementById('freqType')?.value || 'exact';
        rule.weekRange = document.getElementById('freqWeekRange')?.value.trim() || 'all';

        if (!['meal', 'day', 'week'].includes(rule.scope)) {
            console.warn(`Geçersiz scope değeri: ${rule.scope}. Varsayılan olarak 'meal' kullanılıyor.`);
            rule.scope = 'meal';
        }

        if (!['exact', 'min', 'max'].includes(rule.frequencyType)) {
            console.warn(`Geçersiz frequencyType değeri: ${rule.frequencyType}. Varsayılan olarak 'exact' kullanılıyor.`);
            rule.frequencyType = 'exact';
        }

        rule.nameCheck = document.getElementById('freqNameCheck')?.checked || false;
        const nameInput = document.getElementById('freqName')?.value.trim();
        if (rule.nameCheck && nameInput) {
            if (nameInput.includes(',,')) {
                rule.nameOperator = 'AND';
                rule.names = nameInput.split(',,').map(n => n.trim()).filter(n => n);
            } else if (nameInput.includes(';;')) {
                rule.nameOperator = 'OR';
                rule.names = nameInput.split(';;').map(n => n.trim()).filter(n => n);
            } else {
                rule.nameOperator = 'OR';
                rule.names = [nameInput];
            }
            delete rule.name;
        } else {
            rule.names = [];
        }

        rule.tagsCheck = document.getElementById('freqTagCheck')?.checked || false;
        const tagInput = document.getElementById('freqTag')?.value.trim();
        if (rule.tagsCheck && tagInput) {
            if (tagInput.includes(',,')) {
                rule.tagOperator = 'AND';
                rule.tags = tagInput.split(',,').map(t => t.trim()).filter(t => t);
            } else if (tagInput.includes(';;')) {
                rule.tagOperator = 'OR';
                rule.tags = tagInput.split(';;').map(t => t.trim()).filter(t => t);
            } else {
                rule.tagOperator = 'AND';
                rule.tags = tagInput.split(',').map(t => t.trim()).filter(t => t);
            }
        } else {
            rule.tags = [];
        }

        rule.roleCheck = document.getElementById('freqRoleCheck')?.checked || false;
        rule.role = rule.roleCheck ? document.getElementById('freqRole')?.value : '';

        rule.catCheck = document.getElementById('freqCatCheck')?.checked || false;
        rule.category = rule.catCheck ? document.getElementById('freqCat')?.value : '';

        rule.mealTypeCheck = rule.scope === 'meal';
        rule.mealType = rule.mealTypeCheck ? document.getElementById('freqMeal')?.value : '';

        console.log("Oluşturulan/Güncellenen kural (frequency):", JSON.stringify(rule, null, 2));
        if (!rule.nameCheck && !rule.tagsCheck && !rule.roleCheck && !rule.catCheck) {
            showNotification("Hata: Frequency kuralı için isim, etiket, rol veya kategoriden en az biri belirtilmeli!", "error");
            console.log("Hata: Hiçbir kriter seçilmedi.");
            return;
        }
    } else if (ruleType === 'dependOn' && activeForm === dependOnForm) {
        rule.food = document.getElementById('dependOnFood')?.value.trim();
        rule.requiredFood = document.getElementById('dependOnRequiredFood')?.value.trim();
        rule.scope = document.getElementById('dependOnScope')?.value || 'meal';

        if (!['meal', 'day'].includes(rule.scope)) {
            console.warn(`Geçersiz scope değeri: ${rule.scope}. Varsayılan olarak 'meal' kullanılıyor.`);
            rule.scope = 'meal';
        }

        if (!rule.food || !rule.requiredFood) {
            showNotification("Hata: DependOn kuralı için hem yemek hem de gerekli yemek belirtilmeli!", "error");
            console.log("Hata: Eksik yemek bilgisi.");
            return;
        }

        console.log("Oluşturulan/Güncellenen kural (dependOn):", JSON.stringify(rule, null, 2));
    } else if (ruleType === 'compatibility' && activeForm === compatibilityForm) {
        rule.keyword1 = document.getElementById('compatKeyword1')?.value.trim();
        const keyword2Input = document.getElementById('compatKeyword2')?.value.trim();
        rule.keyword2 = keyword2Input ? keyword2Input.split(',').map(k => k.trim()).filter(k => k) : [];
        rule.degree = parseInt(document.getElementById('compatDegree')?.value) || 0;
        rule.conjunction = document.getElementById('compatConjunction')?.value || 'and';

        if (!rule.keyword1 || rule.keyword2.length === 0) {
            showNotification("Hata: Compatibility kuralı için hem keyword1 hem de keyword2 belirtilmeli!", "error");
            console.log("Hata: Eksik uyumluluk bilgisi.");
            return;
        }

        console.log("Oluşturulan/Güncellenen kural (compatibility):", JSON.stringify(rule, null, 2));
    } else {
        console.warn(`Desteklenmeyen kural tipi: ${ruleType}`);
        return;
    }

    if (isEditing) {
        rules[editIndex] = rule;
        showNotification(`Kural (${rule.id}) güncellendi!`, "success");
    } else {
        rules.push(rule);
        showNotification(`Kural (${rule.id}) eklendi!`, "success");
    }

    loadRules();
    activeForm.style.display = 'none';
    delete activeForm.dataset.editIndex;
}



function loadRules() {
    const rulesList = document.getElementById('rulesList');
    if (!rulesList) {
        console.warn("rulesList elementi bulunamadı.");
        if (typeof showNotification === 'function') {
            showNotification("Kurallar listesi elementi eksik!", "error", 3000);
        }
        return;
    }

    rulesList.innerHTML = rules.map((rule, index) => {
        let description = '';

        switch (rule.type) {
            case 'frequency':
                const criteriaText = [];
                if (rule.nameCheck && rule.names?.length) {
                    const connector = rule.nameOperator === 'OR' ? 'veya' : 've';
                    criteriaText.push(`İsim: ${rule.names.join(` ${connector} `)}`);
                } else if (rule.nameCheck && rule.name) {
                    criteriaText.push(`İsim: ${rule.name}`);
                }
                if (rule.tagsCheck && rule.tags?.length) {
                    const connector = rule.tagOperator === 'OR' ? 'veya' : 've';
                    criteriaText.push(`Etiket: ${rule.tags.join(` ${connector} `)}`);
                }
                if (rule.roleCheck && rule.role) criteriaText.push(`Rol: ${rule.role}`);
                if (rule.catCheck && rule.category) criteriaText.push(`Kategori: ${rule.category}`);
                const criteriaDisplay = criteriaText.length ? criteriaText.join(', ') : 'Herhangi bir yemek';
                const scopeText = rule.scope === 'meal' ? `her ${rule.mealType || 'öğünde'}` :
                                 rule.scope === 'day' ? 'günde' :
                                 'haftada';
                const frequencyText = rule.frequencyType === 'min' ? 'en az' :
                                     rule.frequencyType === 'max' ? 'en fazla' :
                                     '';
                description = `(${rule.id}) ${criteriaDisplay} ${scopeText} ${frequencyText} ${rule.frequency || 1} kez`.trim();
                break;
            case 'pairWith':
            case 'avoidPair':
                const pairText = rule.type === 'pairWith' ? 'birlikte olsun' : 'birlikte olmasın';
                const scopePairText = rule.scope === 'meal' ? `her ${rule.mealType || 'öğünde'}` :
                                     rule.scope === 'day' ? 'günde' :
                                     'haftada';
                description = `(${rule.id}) ${rule.name1 || 'Belirsiz'} ile ${rule.name2 || 'Belirsiz'} ${scopePairText} ${pairText}`;
                break;
            case 'dependOn':
                const dependScopeText = rule.scope === 'meal' ? 'her öğünde' : 'her gün';
                description = `(${rule.id}) ${rule.food || 'Belirsiz'} yalnızca ${rule.requiredFood || 'Belirsiz'} ile ${dependScopeText} eklensin`;
                break;
            case 'categoryLock':
                const lockScopeText = rule.scope === 'week' ? 'hafta boyunca' : 'her zaman';
                description = `(${rule.id}) ${rule.category || 'Belirsiz'} kategorisinde ${lockScopeText} sadece ${rule.item || 'Belirsiz'} kullanılsın`;
                break;
            case 'compatibility':
                const compatText = rule.degree > 0 ? 'Uyumlu' : 'Uyumsuz';
                description = `(${rule.id}) ${rule.keyword1 || 'Belirsiz'} ile ${rule.keyword2?.join(', ') || 'Belirsiz'} (${compatText}, ${rule.conjunction === 'or' ? 'veya' : 've'})`;
                break;
            case 'maxRoleCount':
                const roleScopeText = rule.scope === 'meal' ? `her ${rule.mealType || 'öğünde'}` :
                                     rule.scope === 'day' ? 'günde' :
                                     'haftada';
                description = `(${rule.id}) ${rule.role || 'Belirsiz'} rolü ${roleScopeText} en fazla ${rule.count || 1} kez kullanılsın`;
                break;
            default:
                description = `(${rule.id}) Bilinmeyen kural tipi: ${rule.type}`;
                console.warn(`Bilinmeyen kural tipi: ${JSON.stringify(rule)}`);
        }

        if (rule.weekRange && rule.weekRange !== 'all') {
            description += ` [Hafta ${rule.weekRange}]`;
        }

        return `
            <div class="mb-1 d-flex justify-content-between align-items-center">
                <span>${description}</span>
                <div>
                    <button class="btn btn-warning btn-sm me-1" onclick="editRule(${index})" title="Düzenle"><i class="bi bi-pencil"></i></button>
                    <button class="btn btn-danger btn-sm" onclick="deleteRule(${index})" title="Sil"><i class="bi bi-trash"></i></button>
                </div>
            </div>
        `;
    }).join('');

    // Accordion'u açık tut
    const rulesCollapse = document.getElementById('rulesCollapse');
    if (rulesCollapse) {
        rulesCollapse.classList.add('close');
    }

    console.log("Kurallar yüklendi:", rules);
}


function editRule(index) {
    console.log(`editRule çağrıldı, index: ${index}`);
    const rule = rules[index];
    if (!rule) {
        console.error(`Kural bulunamadı, index: ${index}`);
        if (typeof showNotification === 'function') {
            showNotification("Kural bulunamadı!", "warning", 3000);
        }
        return;
    }

    const form = document.getElementById('editRuleForm');
    if (!form) {
        console.error("editRuleForm bulunamadı!");
        if (typeof showNotification === 'function') {
            showNotification("Düzenleme formu bulunamadı!", "error", 3000);
        }
        return;
    }

    document.getElementById('editRuleIndex').value = index;
    document.getElementById('editRuleType').value = rule.type || 'frequency';
    document.getElementById('editRuleScope').value = rule.scope || 'meal';
    document.getElementById('editRuleWeekRange').value = rule.weekRange || 'all';

    document.getElementById('editRuleNameCheck').checked = rule.nameCheck || false;
    document.getElementById('editRuleName').value = rule.names ? rule.names.join(rule.nameOperator === 'AND' ? ',,' : rule.nameOperator === 'OR' ? ';;' : ', ') : rule.name || '';
    document.getElementById('editRuleName').disabled = !rule.nameCheck;

    document.getElementById('editRuleTagsCheck').checked = rule.tagsCheck || false;
    document.getElementById('editRuleTags').value = rule.tags ? rule.tags.join(rule.tagOperator === 'AND' ? ',,' : rule.tagOperator === 'OR' ? ';;' : ', ') : '';
    document.getElementById('editRuleTags').disabled = !rule.tagsCheck;

    document.getElementById('editRuleCategoryCheck').checked = rule.categoryCheck || false;
    document.getElementById('editRuleCategory').value = rule.category || '';
    document.getElementById('editRuleCategory').disabled = !rule.categoryCheck;

    document.getElementById('editRuleRoleCheck').checked = rule.roleCheck || false;
    document.getElementById('editRuleRole').value = rule.role || '';
    document.getElementById('editRuleRole').disabled = !rule.roleCheck;

    document.getElementById('editRuleMealTypeCheck').checked = rule.mealTypeCheck || false;
    document.getElementById('editRuleMealType').value = rule.mealType || 'lunch';
    document.getElementById('editRuleMealType').disabled = !rule.mealTypeCheck;

    if (rule.type === 'frequency') {
        document.getElementById('editFrequencyInput').style.display = 'block';
        document.getElementById('editRuleFrequency').value = rule.frequency || 1;
        document.getElementById('freqType').value = rule.frequencyType || 'exact';
    } else {
        document.getElementById('editFrequencyInput').style.display = 'none';
    }

    if (rule.type === 'minCount' || rule.type === 'maxCount' || rule.type === 'maxRoleCount') {
        document.getElementById('editCountInput').style.display = 'block';
        document.getElementById('editRuleCount').value = rule.count || 1;
    } else {
        document.getElementById('editCountInput').style.display = 'none';
    }

    if (rule.type === 'pairWith' || rule.type === 'avoidPair') {
        document.getElementById('editPairInput').style.display = 'block';
        document.getElementById('editRulePair').value = rule.pair || '';
    } else {
        document.getElementById('editPairInput').style.display = 'none';
    }

    if (rule.type === 'compatibility') {
        document.getElementById('editCompatInput').style.display = 'block';
        document.getElementById('editKeyword1').value = rule.keyword1 || '';
        document.getElementById('editCompatibleFood').value = rule.keyword2 ? rule.keyword2.join(', ') : '';
        document.getElementById('editCompatibilityDegree').value = rule.degree || 0;
        document.getElementById('editCompatibilityType').value = rule.conjunction || 'and';
    } else {
        document.getElementById('editCompatInput').style.display = 'none';
    }

    updateRuleForm(true);
    form.style.display = 'block';
    console.log(`Kural formu dolduruldu:`, rule);
}


function toggleInput(checkboxId, inputId) {
    const checkbox = document.getElementById(checkboxId);
    const input = document.getElementById(inputId);
    if (checkbox && input) {
        input.disabled = !checkbox.checked;
        checkbox.addEventListener('change', () => {
            input.disabled = !checkbox.checked;
        });
    }
}
// Mevsim bilgisini localStorage'a kaydetme fonksiyonu
function saveSeasonInfoToLocalStorage(foodName, seasonRange) {
  try {
    const seasonInfo = {
      name: foodName,
      seasonRange: seasonRange,
      updatedAt: new Date().toISOString()
    };
    
    // Mevcut kaydedilmiş bilgileri al
    const savedSeasonInfos = JSON.parse(localStorage.getItem('foodSeasonInfos') || '[]');
    
    // Aynı yemek için varolan kaydı güncelle veya yeni kayıt ekle
    const existingIndex = savedSeasonInfos.findIndex(info => info.name === foodName);
    if (existingIndex !== -1) {
      savedSeasonInfos[existingIndex] = seasonInfo;
    } else {
      savedSeasonInfos.push(seasonInfo);
    }
    
    // Güncellenmiş listeyi kaydet
    localStorage.setItem('foodSeasonInfos', JSON.stringify(savedSeasonInfos));
    
    console.log(`Mevsim bilgisi kaydedildi: ${foodName}, Aralık: ${seasonRange}`);
  } catch (error) {
    console.error('Mevsim bilgisi kaydedilemedi:', error);
    showNotification('Mevsim bilgisi kaydetme hatası', 'error');
  }
}

// Mevsim bilgisini localStorage'dan yükleme fonksiyonu
function loadSeasonInfoFromLocalStorage(foodName) {
    const foodList = JSON.parse(localStorage.getItem("food_list")) || {};
    for (const category in foodList) {
        const food = foodList[category].find(item => item.name === foodName);
        if (food && food.seasonRange) {
            return food.seasonRange;
        }
    }
    return null;
}


function saveEditedFood(event) {
    event.preventDefault();
    console.log("saveEditedFood çağrıldı");
    saveState();

    const originalName = document.getElementById('editFoodOriginalName').value.trim();
    const newName = document.getElementById('editFoodName').value.trim();
    const category = document.getElementById('editFoodMoveToCategory').value;
    const role = document.getElementById('editFoodRole').value || 'mainDish';
    const calories = parseFloat(document.getElementById('editFoodCalories').value) || 0;
    const protein = parseFloat(document.getElementById('editFoodProtein').value) || 0;
    const carbs = parseFloat(document.getElementById('editFoodCarbs').value) || 0;
    const fat = parseFloat(document.getElementById('editFoodFat').value) || 0;
    const maxQuantity = parseFloat(document.getElementById('editFoodMaxQuantity').value) || 1;
    const minQuantity = parseFloat(document.getElementById('editFoodMinQuantity').value) || 0.5;
    const step = parseFloat(document.getElementById('editFoodStep').value) || 0.5;
    const tags = document.getElementById('editFoodTags').value.split(',').map(t => t.trim()).filter(t => t);
    const compatibilityTags = document.getElementById('editFoodCompatibilityTags').value.split(',').map(t => t.trim()).filter(t => t);
    const keto = document.getElementById('editFoodKeto').checked;
    const lowcarb = document.getElementById('editFoodLowCarb').checked;
    const fillerLunch = document.getElementById('editFoodFillerLunch').checked;
    const fillerDinner = document.getElementById('editFoodFillerDinner').checked;
    const portionFixed = document.getElementById('editFoodPortionFixed').checked;
    const multiplier = parseFloat(document.getElementById('editFoodMultiplier').value) || 1;

    // Sezon aralığını al
    let seasonFrom = 1;
    let seasonTo = 12;
    const seasonFromElement = document.getElementById('editFoodSeasonFrom');
    const seasonToElement = document.getElementById('editFoodSeasonTo');
    if (seasonFromElement && seasonFromElement.value) {
        seasonFrom = parseInt(seasonFromElement.value);
    }
    if (seasonToElement && seasonToElement.value) {
        seasonTo = parseInt(seasonToElement.value);
    }
    const seasonRange = JSON.stringify([Math.max(1, Math.min(seasonFrom, 12)), Math.max(1, Math.min(seasonTo, 12))]);
    console.log(`Kaydedilen mevsim aralığı: ${seasonRange}`);

    const mealTypes = [];
    ['breakfast', 'lunch', 'dinner'].forEach(type => {
        const checkbox = document.getElementById(`editMealType_${type}`);
        if (checkbox && checkbox.checked) {
            mealTypes.push(type);
        }
    });

    if (!newName || !category) {
        showNotification("Yemek adı ve kategori zorunludur!", "warning");
        return;
    }

    // Çakışan isimleri kontrol et
    const duplicates = checkForDuplicateFoods(newName, category);
    if (duplicates.length > 0 && newName !== originalName) {
        console.warn(`Hata: "${newName}" adına sahip ${duplicates.length} yemek bulundu!`, duplicates);
        showNotification(`Bu isimde başka yemekler mevcut. Lütfen benzersiz bir isim kullanın.`, "warning");
        return;
    }

    // Yemeği bul
    const food = findFood(originalName);
    if (!food || !food.category) {
        console.error(`Yemek bulunamadı: ${originalName}`);
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }

    // Yeni yemek verisi
    const updatedFood = {
        name: newName,
        category,
        role,
        calories,
        protein,
        carbs,
        fat,
        maxQuantity,
        minQuantity,
        step,
        tags,
        compatibilityTags,
        keto,
        lowcarb,
        fillerLunch,
        fillerDinner,
        portionFixed,
        multiplier,
        seasonRange,
        mealType: mealTypes,
        isReversedSeason: false
    };

    // localStorage güncelleme
    let foodList = JSON.parse(localStorage.getItem("food_list")) || {};

    // Eski yemeği tüm kategorilerden kaldır
    let found = false;
    let originalCategory = null;
    for (const cat in foodList) {
        const index = foodList[cat].findIndex(item => item.name === originalName);
        if (index !== -1) {
            foodList[cat].splice(index, 1);
            found = true;
            originalCategory = cat;
            console.log(`Eski yemek kaldırıldı: ${originalName} (Kategori: ${cat})`);
        }
    }

    if (!found) {
        console.warn(`localStorage'da eski yemek bulunamadı: ${originalName}`);
    }

    // Yeni yemeği ekle
    if (!foodList[category]) {
        foodList[category] = [];
    }
    foodList[category].push(updatedFood);
    console.log(`Yeni yemek localStorage'a eklendi: ${newName} (Kategori: ${category}, seasonRange: ${seasonRange})`);

    // localStorage'a kaydet
    localStorage.setItem("food_list", JSON.stringify(foodList));

    // categories dizisini güncelle
    // Eski yemeği tüm kategorilerden kaldır
    categories.forEach(cat => {
        const index = cat.items.findIndex(item => item.name === originalName);
        if (index !== -1) {
            cat.items.splice(index, 1);
            console.log(`Eski yemek categories'den kaldırıldı: ${originalName} (Kategori: ${cat.name})`);
        }
    });

    // Yeni kategoriyi bul veya oluştur
    let categoryObj = categories.find(cat => cat.name === category);
    if (!categoryObj) {
        categoryObj = { name: category, items: [] };
        categories.push(categoryObj);
        console.log(`Yeni kategori oluşturuldu: ${category}`);
    }

    // Yeni yemeği categories'e ekle
    categoryObj.items.push(updatedFood);
    console.log(`Yeni yemek categories'e eklendi: ${newName} (Kategori: ${category})`);

    // Öğün verilerindeki katsayıları kontrol et
    weeks.forEach((week, wIndex) => {
        Object.values(week.days).forEach(day => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                if (day.meals[mealType]) {
                    day.meals[mealType].forEach(item => {
                        if (item.name === updatedFood.name && item.quantity > updatedFood.maxQuantity) {
                            item.quantity = updatedFood.maxQuantity;
                            console.log(`Öğün katsayısı güncellendi: ${item.name} (${mealType}) -> ${item.quantity}`);
                        }
                    });
                }
            });
        });
    });

    // GitHub'a güncelle
    updateGitHubData();

    showNotification(`"${updatedFood.name}" yemeği güncellendi!`, "success");
    closeEditFoodPanel();
    loadCategories();
    renderMeals();
    calculateMacros();
}

function createFrequencyRule(newRule) {
    newRule.type = "frequency";
    newRule.frequency = parseInt(document.getElementById("freqCount")?.value) || 1;
    newRule.frequencyType = document.getElementById("freqType")?.value || "exact";
    newRule.scope = document.getElementById("freqScope")?.value || "week";
    newRule.weekRange = document.getElementById("freqWeekRange")?.value.trim() || "all";

    newRule.nameCheck = document.getElementById("freqNameCheck")?.checked || false;
    const nameInput = document.getElementById("freqName")?.value.trim();
    newRule.names = processInput(nameInput, newRule.nameCheck, "nameOperator");

    newRule.tagsCheck = document.getElementById("freqTagCheck")?.checked || false;
    const tagInput = document.getElementById("freqTag")?.value.trim();
    newRule.tags = processInput(tagInput, newRule.tagsCheck, "tagOperator");

    newRule.roleCheck = document.getElementById("freqRoleCheck")?.checked || false;
    newRule.role = newRule.roleCheck ? document.getElementById("freqRole")?.value : "";
    newRule.catCheck = document.getElementById("freqCatCheck")?.checked || false;
    newRule.category = newRule.catCheck ? document.getElementById("freqCat")?.value : "";
    newRule.mealTypeCheck = newRule.scope === "meal";
    newRule.mealType = newRule.mealTypeCheck ? document.getElementById("freqMeal")?.value : "";

    if (!newRule.nameCheck && !newRule.tagsCheck && !newRule.roleCheck && !newRule.catCheck) {
        throw new Error("Sıklık kuralı için isim, etiket, rol veya kategoriden en az biri belirtilmeli!");
    }

    return newRule;
}

function createDependOnRule(newRule) {
    newRule.type = "dependOn";
    const dependOnFood = document.getElementById("dependOnFood")?.value.trim();
    const dependOnRequiredFood = document.getElementById("dependOnRequiredFood")?.value.trim();
    newRule.scope = document.getElementById("dependOnScope")?.value || "meal";

    if (!dependOnFood || !dependOnRequiredFood) {
        throw new Error("Bağımlı yemek ve gerekli yemek boş olamaz!");
    }

    return {
        ...newRule,
        food: dependOnFood,
        requiredFood: dependOnRequiredFood,
        scope: newRule.scope
    };
}

function createCompatibilityRule(newRule) {
    newRule.type = "compatibility";
    const keyword1El = document.getElementById("compatKeyword1");
    const keyword2El = document.getElementById("compatKeyword2");
    const degreeEl = document.getElementById("compatDegree");
    const conjunctionEl = document.getElementById("compatConjunction");

    if (!keyword1El || !keyword2El || !degreeEl || !conjunctionEl) {
        throw new Error("Uyumluluk kuralı form elemanları eksik!");
    }

    const keyword1 = keyword1El.value.trim();
    const keyword2Input = keyword2El.value.trim();
    const degree = parseInt(degreeEl.value) || 0;
    const conjunction = conjunctionEl.value || "and";
    const keyword2 = keyword2Input ? keyword2Input.split(",").map(k => k.trim()).filter(k => k) : [];

    if (!keyword1) {
        throw new Error("Birinci kelime boş olamaz!");
    }

    return {
        ...newRule,
        keyword1,
        keyword2,
        degree,
        conjunction
    };
}

function createCategoryLockRule(newRule) {
    newRule.type = "categoryLock";
    const category = document.getElementById("categoryLockCategory")?.value;
    newRule.scope = document.getElementById("categoryLockScope")?.value || "week";

    if (!category) {
        throw new Error("Kilitlenecek kategori belirtilmeli!");
    }

    return {
        ...newRule,
        category,
        scope: newRule.scope
    };
}

function createPairRule(newRule) {
    newRule.type = document.getElementById("pairType")?.value === "together" ? "pairWith" : "avoidPair";
    const pair1Name = document.getElementById("pair1Name")?.value.trim();
    const pair2Name = document.getElementById("pair2Name")?.value.trim();
    newRule.scope = document.getElementById("pairScope")?.value || "meal";
    newRule.conjunction = document.getElementById("pairConjunction")?.value || "and";
    newRule.direction = document.getElementById("pairDirection")?.value || "bidirectional";
    newRule.mealType = newRule.scope === "meal" ? document.getElementById("pairMeal")?.value : "";
    newRule.weekRange = document.getElementById("pairWeekRange")?.value.trim() || "all";

    if (!pair1Name || !pair2Name) {
        throw new Error("Birinci ve ikinci kelime boş olamaz!");
    }

    return {
        ...newRule,
        name1Check: document.getElementById("pair1NameCheck")?.checked || false,
        name1: document.getElementById("pair1NameCheck")?.checked ? pair1Name : "",
        tag1Check: document.getElementById("pair1TagCheck")?.checked || false,
        tag1: document.getElementById("pair1TagCheck")?.checked ? document.getElementById("pair1Tag")?.value.trim() : "",
        role1Check: document.getElementById("pair1RoleCheck")?.checked || false,
        role1: document.getElementById("pair1RoleCheck")?.checked ? document.getElementById("pair1Role")?.value : "",
        cat1Check: document.getElementById("pair1CatCheck")?.checked || false,
        cat1: document.getElementById("pair1CatCheck")?.checked ? document.getElementById("pair1Cat")?.value : "",
        name2Check: document.getElementById("pair2NameCheck")?.checked || false,
        name2: document.getElementById("pair2NameCheck")?.checked ? pair2Name : "",
        tag2Check: document.getElementById("pair2TagCheck")?.checked || false,
        tag2: document.getElementById("pair2TagCheck")?.checked ? document.getElementById("pair2Tag")?.value.trim() : "",
        role2Check: document.getElementById("pair2RoleCheck")?.checked || false,
        role2: document.getElementById("pair2RoleCheck")?.checked ? document.getElementById("pair2Role")?.value : "",
        cat2Check: document.getElementById("pair2CatCheck")?.checked || false,
        cat2: document.getElementById("pair2CatCheck")?.checked ? document.getElementById("pair2Cat")?.value : ""
    };
}

function processInput(input, isChecked, operatorKey) {
    if (!isChecked || !input) {
        return [];
    }

    let operator = "AND";
    let items = [];

    if (input.includes(",,")) {
        operator = "AND";
        items = input.split(",,").map(i => i.trim()).filter(i => i);
    } else if (input.includes(";;")) {
        operator = "OR";
        items = input.split(";;").map(i => i.trim()).filter(i => i);
    } else {
        operator = operatorKey === "tagOperator" ? "AND" : "OR";
        items = operatorKey === "tagOperator" ? input.split(",").map(i => i.trim()).filter(i => i) : [input];
    }

    return items.length > 0 ? items : [];
}
function saveEditedRule(event) {
    event.preventDefault();
    console.log("saveEditedRule çağrıldı");
    saveState();

    const ruleIndex = parseInt(document.getElementById('editRuleIndex')?.value);
    const ruleType = document.getElementById('editRuleType')?.value;
    const ruleScope = document.getElementById('editRuleScope')?.value;
    const ruleWeekRange = document.getElementById('editRuleWeekRange')?.value;

    if (isNaN(ruleIndex) || ruleIndex < 0 || ruleIndex >= rules.length) {
        console.error("Geçersiz kural indeksi:", ruleIndex);
        showNotification("Kural güncellenemedi: Geçersiz kural!", "warning");
        return;
    }

    const updatedRule = {
        type: ruleType,
        scope: ruleScope,
        weekRange: ruleWeekRange || "all",
        nameCheck: document.getElementById('editRuleNameCheck')?.checked || false,
        names: document.getElementById('editRuleName')?.value.split(',').map(n => n.trim()).filter(n => n) || [],
        tagsCheck: document.getElementById('editRuleTagsCheck')?.checked || false,
        tags: document.getElementById('editRuleTags')?.value.split(',').map(t => t.trim()).filter(t => t) || [],
        categoryCheck: document.getElementById('editRuleCategoryCheck')?.checked || false,
        category: document.getElementById('editRuleCategory')?.value || '',
        mealTypeCheck: document.getElementById('editRuleMealTypeCheck')?.checked || false,
        mealType: document.getElementById('editRuleMealType')?.value || '',
        roleCheck: document.getElementById('editRuleRoleCheck')?.checked || false,
        role: document.getElementById('editRuleRole')?.value || ''
    };

    if (ruleType === 'frequency') {
        updatedRule.frequency = parseInt(document.getElementById('editRuleFrequency')?.value) || 1;
        updatedRule.frequencyType = document.getElementById('freqType')?.value || 'exact';
        if (updatedRule.nameCheck && updatedRule.names.length > 1) {
            updatedRule.nameOperator = document.getElementById('editRuleName')?.value.includes(',,') ? 'AND' : 'OR';
        }
        if (updatedRule.tagsCheck && updatedRule.tags.length > 1) {
            updatedRule.tagOperator = document.getElementById('editRuleTags')?.value.includes(',,') ? 'AND' : 'OR';
        }
    } else if (ruleType === 'minCount' || ruleType === 'maxCount') {
        updatedRule.count = parseInt(document.getElementById('editRuleCount')?.value) || 1;
    } else if (ruleType === 'pairWith' || ruleType === 'avoidPair') {
        updatedRule.pair = document.getElementById('editRulePair')?.value.trim() || '';
    } else if (ruleType === 'compatibility') {
        updatedRule.keyword1 = document.getElementById('editKeyword1')?.value.trim() || '';
        updatedRule.keyword2 = document.getElementById('editCompatibleFood')?.value.split(',').map(k => k.trim()).filter(k => k) || [];
        updatedRule.degree = parseInt(document.getElementById('editCompatibilityDegree')?.value) || 0;
        updatedRule.conjunction = document.getElementById('editCompatibilityType')?.value || 'and';
    } else if (ruleType === 'maxRoleCount') {
        updatedRule.count = parseInt(document.getElementById('editRuleCount')?.value) || 1;
        updatedRule.mealType = document.getElementById('editRuleMealType')?.value || 'lunch';
        updatedRule.role = document.getElementById('editRuleRole')?.value || 'mainDish';
    }

    if (['frequency', 'exclude', 'include', 'singleItem', 'minCount', 'maxCount', 'maxRoleCount'].includes(ruleType)) {
        if (!updatedRule.nameCheck && !updatedRule.tagsCheck && !updatedRule.categoryCheck && !updatedRule.mealTypeCheck && !updatedRule.roleCheck) {
            showNotification("Hata: En az bir kriter (isim, etiket, kategori, öğün veya rol) belirtilmeli!", "error");
            return;
        }
    }

    updatedRule.id = rules[ruleIndex].id;
    rules[ruleIndex] = updatedRule;
    console.log(`Kural güncellendi: ID ${updatedRule.id}`, updatedRule);

    // localStorage'a kaydet
    localStorage.setItem("rules", JSON.stringify(rules));

    // GitHub'a güncelle
    updateGitHubData();

    showNotification(`Kural "${updatedRule.id}" güncellendi!`, "success");
    document.getElementById('editRuleForm').style.display = 'none';
    loadRules();
}
// handleRuleSave fonksiyonu
function handleRuleSave(event) {
    event.preventDefault();
    console.log("handleRuleSave çağrıldı");

    const indexValue = document.getElementById("editRuleIndex")?.value;
    const isEditing = indexValue !== "" && indexValue !== undefined;

    if (isEditing) {
        // Düzenleme modu
        saveEditedRule(new Event("submit"));
        return;
    }

    // Yeni kural ekleme modu
    const formId = event.target.closest("div[id]").id;
    let newRule = {};

    // Maksimum ID'yi bul
    const maxId = rules.length > 0 ? Math.max(...rules.map(r => r.id || 0)) : 0;
    newRule.id = maxId + 1;

    try {
        if (formId === "frequencyRuleForm") {
            newRule = createFrequencyRule(newRule);
        } else if (formId === "dependOnRuleForm") {
            newRule = createDependOnRule(newRule);
        } else if (formId === "compatibilityRuleForm") {
            newRule = createCompatibilityRule(newRule);
        } else if (formId === "categoryLockRuleForm") {
            newRule = createCategoryLockRule(newRule);
        } else if (formId === "pairRuleForm") {
            newRule = createPairRule(newRule);
        } else {
            showNotification("Hata: Geçersiz form ID'si!", "error");
            console.error("Geçersiz form ID'si:", formId);
            return;
        }

        // Yeni kuralı ekle
        rules.push(newRule);
        loadRules();
        updateGitHubData();
        showNotification("Kural eklendi!", "success");

        // Tüm formları gizle
        cancelEditRule();
    } catch (error) {
        showNotification("Kural eklenirken hata oluştu: " + error.message, "error");
        console.error("handleRuleSave hatası:", error);
    }
}

// Diğer yardımcı fonksiyonlar
function cancelEditRule() {
    console.log("Kural formu iptal ediliyor...");
    const forms = [
        "editRuleForm",
        "frequencyRuleForm",
        "dependOnRuleForm",
        "compatibilityRuleForm",
        "categoryLockRuleForm",
        "pairRuleForm"
    ];

    // Tüm formları gizle
    forms.forEach(formId => {
        const form = document.getElementById(formId);
        if (form) {
            form.style.display = "none";
        } else {
            console.warn(`${formId} bulunamadı.`);
        }
    });

    // Kural ekleme butonunun metnini sıfırla
    const addRuleButton = document.getElementById("addRuleButton");
    if (addRuleButton) {
        addRuleButton.textContent = "Kural Ekle";
    } else {
        console.warn("addRuleButton bulunamadı.");
    }
}

function deleteRule(index) {
    rules.splice(index, 1);
    loadRules();
    showNotification("Kural silindi!", "success");
}

function populateCategoryDropdown() {
    console.log("Kategori dropdown'u dolduruluyor...");
    const catSelects = [
        document.getElementById("freqCat"),
        document.getElementById("editRuleCategory"),
        document.getElementById("categoryLockCategory"),
        document.getElementById("pair1Cat"),
        document.getElementById("pair2Cat")
    ].filter(el => el);

    if (!catSelects.length) {
        console.warn("Kategori dropdown elementi bulunamadı!");
        return;
    }

    if (!Array.isArray(categories)) {
        console.error("categories bir dizi değil:", categories);
        categories = [];
        return;
    }

    catSelects.forEach(catSelect => {
        catSelect.innerHTML = '<option value="">Kategori Seç</option>';
        categories.forEach(category => {
            const option = document.createElement("option");
            option.value = category.name;
            option.textContent = category.name;
            catSelect.appendChild(option);
        });
    });
    console.log("Kategoriler yüklendi:", categories.map(c => c.name));
}

function openFrequencyRuleForm(index) {
    const form = document.getElementById('frequencyRuleForm');
    form.style.display = 'block';

    // Formu sıfırla
    document.getElementById('freqName').value = '';
    document.getElementById('freqTag').value = '';
    document.getElementById('freqCount').value = 1;
    document.getElementById('freqWeekRange').value = '';
    document.getElementById('freqScope').value = 'week';
    document.getElementById('freqMeal').value = 'lunch';
    document.getElementById('freqType').value = 'exact';
    document.getElementById('freqNameCheck').checked = false;
    document.getElementById('freqTagCheck').checked = false;
    document.getElementById('freqRoleCheck').checked = false;
    document.getElementById('freqCatCheck').checked = false;
    document.getElementById('freqName').disabled = true;
    document.getElementById('freqTag').disabled = true;
    document.getElementById('freqRole').disabled = true;
    document.getElementById('freqCat').disabled = true;

    // Düzenleme moduysa, mevcut kuralı yükle
    if (index !== undefined && rules[index]) {
        const rule = rules[index];
        form.dataset.editIndex = index;
        if (rule.type === 'frequency') {
            document.getElementById('freqNameCheck').checked = rule.nameCheck || false;
            document.getElementById('freqName').value = rule.names ? rule.names.join(rule.nameOperator === 'AND' ? ',,' : ';;') : '';
            document.getElementById('freqName').disabled = !rule.nameCheck;

            document.getElementById('freqTagCheck').checked = rule.tagsCheck || false;
            document.getElementById('freqTag').value = rule.tags ? rule.tags.join(rule.tagOperator === 'AND' ? ',,' : ';;') : '';
            document.getElementById('freqTag').disabled = !rule.tagsCheck;

            document.getElementById('freqRoleCheck').checked = rule.roleCheck || false;
            document.getElementById('freqRole').value = rule.role || '';
            document.getElementById('freqRole').disabled = !rule.roleCheck;

            document.getElementById('freqCatCheck').checked = rule.catCheck || false;
            document.getElementById('freqCat').value = rule.category || '';
            document.getElementById('freqCat').disabled = !rule.catCheck;

            document.getElementById('freqCount').value = rule.frequency || 1;
            document.getElementById('freqType').value = rule.frequencyType || 'exact';
            document.getElementById('freqScope').value = rule.scope || 'week';
            document.getElementById('freqMeal').value = rule.mealType || 'lunch';
            document.getElementById('freqWeekRange').value = rule.weekRange || 'all';
            document.getElementById('freqMealContainer').style.display = rule.scope === 'meal' ? 'block' : 'none';
        }
    } else {
        delete form.dataset.editIndex;
    }

    populateCategoryDropdown();
    console.log(`Sıklık kuralı formu açıldı, düzenleme modu: ${index !== undefined}`);
}
function toggleInput(checkboxId, inputId) {
    const checkbox = document.getElementById(checkboxId);
    const input = document.getElementById(inputId);
    if (checkbox && input) {
        checkbox.addEventListener('change', function() {
            input.disabled = !this.checked;
        });
    }
}

function toggleMealSelect(scopeId, mealId) {
    const scopeSelect = document.getElementById(scopeId);
    const mealSelect = document.getElementById(mealId);
    if (scopeSelect && mealSelect) {
        mealSelect.style.display = scopeSelect.value === 'meal' ? 'inline' : 'none';
        scopeSelect.addEventListener('change', function() {
            mealSelect.style.display = this.value === 'meal' ? 'inline' : 'none';
        });
    }
}

// Event Listener'lar ve Başlatma
document.getElementById('freqNameCheck').addEventListener('change', function() {
    document.getElementById('freqName').disabled = !this.checked;
});
document.getElementById('freqScope').addEventListener('change', function() {
    document.getElementById('freqMeal').style.display = this.value === 'meal' ? 'block' : 'none';
});

toggleInput('freqNameCheck', 'freqName');
toggleInput('freqTagCheck', 'freqTag');
toggleInput('freqRoleCheck', 'freqRole');
toggleInput('freqCatCheck', 'freqCat');
toggleInput('pair1NameCheck', 'pair1Name');
toggleInput('pair2NameCheck', 'pair2Name');

toggleMealSelect('freqScope', 'freqMeal');
toggleMealSelect('pairScope', 'pairMeal');

initializeWeeks();
loadCategories();
renderWeekTabs();
renderDayTabs();
renderMeals();
loadPatientSelect();
loadRules();
loadMealTemplates();
loadCompatibilityRules();
loadSettingsTemplates();
loadRuleTemplates();
calculateMacros();
searchEditFood('');
updateRuleForm();

// Eklenmesi gereken satırlar
toggleMealSelect('freqScope', 'freqMeal'); // Sıklık Kuralı için ilk durumu ayarla
toggleMealSelect('pairScope', 'pairMeal'); // Birliktelik Kuralı için ilk durumu ayarla


// Optional: Add range input value display functionality
document.addEventListener('DOMContentLoaded', () => {
    const compatibilityDegreeInputs = document.querySelectorAll('input[type="range"][id^="compatibilityDegree"], input[type="range"][id^="editCompatibilityDegree"]');
    
    compatibilityDegreeInputs.forEach(input => {
        const degreeValueSpan = document.getElementById(input.id.replace('compatibilityDegree', 'degreeValue'));
        
        input.addEventListener('input', () => {
            if (degreeValueSpan) {
                degreeValueSpan.textContent = input.value;
            }
        });
    });
});

function updateRuleForm(isEditForm = false) {
    const formId = isEditForm ? 'editRuleForm' : 'ruleForm';
    const typeId = isEditForm ? 'editRuleType' : 'ruleType';
    const form = document.getElementById(formId);
    const ruleType = document.getElementById(typeId)?.value;

    if (!form || !ruleType) {
        console.warn("Kural formu veya kural tipi seçimi bulunamadı!");
        if (typeof showNotification === 'function') {
            showNotification("Kural formu elemanları eksik, lütfen sayfayı yenileyin!", "error", 3000);
        }
        return;
    }

    const defaultRuleForm = document.getElementById('defaultRuleForm');
    const frequencyInput = document.getElementById(isEditForm ? 'editFrequencyInput' : 'countInput');
    const countInput = document.getElementById(isEditForm ? 'editCountInput' : 'countInput');
    const pairInput = document.getElementById(isEditForm ? 'editPairInput' : 'pairInput');
    const compatInput = document.getElementById(isEditForm ? 'editCompatInput' : 'compatInput');

    if (!defaultRuleForm || !frequencyInput || !countInput || !pairInput || !compatInput) {
        console.warn("Form elemanları eksik:", { defaultRuleForm, frequencyInput, countInput, pairInput, compatInput });
        if (typeof showNotification === 'function') {
            showNotification("Form elemanları eksik, lütfen sayfayı yenileyin!", "error", 3000);
        }
        return;
    }

    // Form elemanlarını göster/gizle
    defaultRuleForm.style.display = ['frequency', 'exclude', 'include', 'minCount', 'maxCount', 'singleItem', 'maxRoleCount'].includes(ruleType) ? 'block' : 'none';
    frequencyInput.style.display = ruleType === 'frequency' ? 'block' : 'none';
    countInput.style.display = ['minCount', 'maxCount', 'maxRoleCount'].includes(ruleType) ? 'block' : 'none';
    pairInput.style.display = ['pairWith', 'avoidPair'].includes(ruleType) ? 'block' : 'none';
    compatInput.style.display = ruleType === 'compatibility' ? 'block' : 'none';

    // Kural tipine göre ek alanları yönet
    if (ruleType === 'dependOn') {
        defaultRuleForm.style.display = 'none';
        // DependOn için özel form elemanları gerekirse eklenebilir
    } else if (ruleType === 'categoryLock') {
        defaultRuleForm.style.display = 'none';
        // CategoryLock için özel form elemanları gerekirse eklenebilir
    }

    console.log(`Kural formu güncellendi, tip: ${ruleType}, edit: ${isEditForm}`);
}
// Optional: Add range input value display functionality
document.addEventListener('DOMContentLoaded', () => {
    const compatibilityDegreeInputs = document.querySelectorAll('input[type="range"][id^="compatibilityDegree"], input[type="range"][id^="editCompatibilityDegree"]');
    
    compatibilityDegreeInputs.forEach(input => {
        const degreeValueSpan = document.getElementById(input.id.replace('compatibilityDegree', 'degreeValue'));
        
        input.addEventListener('input', () => {
            if (degreeValueSpan) {
                degreeValueSpan.textContent = input.value;
            }
        });
    });
});


    // Seçilen türe göre doğru formu göster
    if (type === 'frequency') {
        frequencyForm.style.display = 'block';
    } else if (type === 'pairWith' || type === 'avoidPair') {
        pairForm.style.display = 'block';
    } else if (type === 'dependOn') { // Yeni eklenen: Bağımlı Olsun kuralı
        dependOnForm.style.display = 'block';
    } else if (type === 'categoryLock') { // Yeni eklenen: Kategori Kilidi kuralı
        categoryLockForm.style.display = 'block';
    } else {
        defaultForm.style.display = 'block';
        frequencyInput.style.display = type === 'frequency' ? 'block' : 'none';
        countInput.style.display = 'none'; // Min ve Max kalktığı için hep gizli
        pairInput.style.display = ['pairWith', 'avoidPair'].includes(type) ? 'block' : 'none';
    }



function saveRuleTemplate() {
    const templateName = document.getElementById('templateName').value;
    if (!templateName) {
        showNotification("Şablon adı girin!", 'warning');
        return;
    }
    localStorage.setItem(`ruleTemplate_${templateName}`, JSON.stringify(rules));
    loadRuleTemplates();
    showNotification("Şablon kaydedildi!");
}























function loadRuleTemplates() {
    const templateSelect = document.getElementById('templateSelect');
    const templates = Object.keys(localStorage).filter(key => key.startsWith('ruleTemplate_')).map(key => key.replace('ruleTemplate_', ''));
    templateSelect.innerHTML = '<option value="">Şablon Yükle</option>' + templates.map(t => `<option value="${t}">${t}</option>`).join('');
}

function loadRuleTemplate() {
    const templateName = document.getElementById('templateSelect').value;
    if (!templateName) return;
    rules.length = 0;
    rules.push(...JSON.parse(localStorage.getItem(`ruleTemplate_${templateName}`) || '[]'));
    loadRules();
    showNotification("Şablon yüklendi!");
}

function deleteRuleTemplate() {
    const templateName = document.getElementById('templateSelect').value;
    if (!templateName) return;
    localStorage.removeItem(`ruleTemplate_${templateName}`);
    loadRuleTemplates();
    showNotification("Şablon silindi!");
}

function checkCompatibility(food, currentMeal) {
    // Hızlı kontroller önce
    if (!food || !currentMeal || !currentMeal.length) {
        return true; // Eksik veri durumunda uyumlu kabul et
    }

    // Performans için rules dizisini kopyalama
    const compatRules = rules.filter(rule => 
        rule.type === 'compatibility' && rule.keyword1 && rule.keyword2 && rule.keyword2.length > 0
    );

    // Hiç kural yoksa hızlıca dön
    if (!compatRules.length) return true;

    // ÖNEMLİ: ÖNCELİKLE compatibilityTags'ı kontrol ediyoruz, yoksa normal tags'e geri dönüyoruz
    // Food'un uyumluluk etiketlerini lowercase yapıp önbelleğe al (her seferinde dönüştürmemek için)
    const foodCompatTags = (food.compatibilityTags && food.compatibilityTags.length) ? 
                          food.compatibilityTags.map(tag => tag.toLowerCase()) : 
                          food.tags ? food.tags.map(tag => tag.toLowerCase()) : [];
    
    // Eğer hiç etiket yoksa uyumluluk kontrolü yapılamaz, kabul et
    if (foodCompatTags.length === 0) return true;
    
    // Öğündeki yemeklerin uyumluluk etiketlerini önbelleğe al
    const mealCompatTagsMap = new Map();
    for (const item of currentMeal) {
        if (!item) continue;
        
        const mealFood = typeof item === 'string' ? findFood(item) : item;
        if (!mealFood) continue;
        
        // Uyumluluk etiketleri veya normal etiketleri kullan
        const mealTags = (mealFood.compatibilityTags && mealFood.compatibilityTags.length) ? 
                         mealFood.compatibilityTags.map(tag => tag.toLowerCase()) : 
                         mealFood.tags ? mealFood.tags.map(tag => tag.toLowerCase()) : [];
        
        if (mealTags.length > 0) {
            // Yemek adını anahtar, etiketleri değer olarak önbelleğe al
            const mealName = mealFood.name;
            if (!mealCompatTagsMap.has(mealName)) {
                mealCompatTagsMap.set(mealName, mealTags);
            }
        }
    }

    // Her kural için tek bir geçiş yap
    for (const rule of compatRules) {
        const keyword1Lower = rule.keyword1.toLowerCase();
        const keyword2Lower = rule.keyword2.map(k => k.toLowerCase());
        
        // Kural keyword1 uyumluluk etiketi olarak mevcut mu?
        const keyword1Match = foodCompatTags.includes(keyword1Lower);
        if (!keyword1Match) continue; // Bu kural bu yemek için geçerli değil
        
        // Öğündeki diğer yemeklerde keyword2 var mı?
        let hasCompatibleFood = false;
        let hasSameTagFood = false;
        
        for (const [_, mealTags] of mealCompatTagsMap) {
            // Aynı yemekte hem keyword1 hem de keyword2 varsa, bu durumu işaretle
            if (mealTags.includes(keyword1Lower) && 
                mealTags.some(tag => keyword2Lower.includes(tag))) {
                hasSameTagFood = true;
                continue;
            }
            
            // Diğer yemekte keyword2 tag'lerinden biri var mı?
            if (mealTags.some(tag => keyword2Lower.includes(tag))) {
                hasCompatibleFood = true;
                break; // Bir tane bulmak yeterli
            }
        }
        
        // Eğer aynı yemekte hem keyword1 hem de keyword2 tag'leri varsa,
        // bu kural geçerli değil
        if (hasSameTagFood) continue;
        
        // Uyumluluk derecesine göre sonuç
        if (rule.degree > 0 && !hasCompatibleFood) {
            // Olumlu uyumluluk kuralı: Bu etiketlere sahip yemekler birlikte olmalı
            // Ama öğünde uyumlu yemek yok, bu yüzden uyumlu değil
            return false;
        } else if (rule.degree < 0 && hasCompatibleFood) {
            // Olumsuz uyumluluk kuralı: Bu etiketlere sahip yemekler birlikte olmamalı
            // Ama öğünde uyumsuz yemek var, bu yüzden uyumlu değil
            return false;
        }
    }
    
    // Tüm kurallar kontrol edildi ve hiçbiri uyumsuzluk çıkarmadı
    return true;
}

function importFoodList() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                let newCount = 0; // Yeni eklenen yemek sayısını tutacak

                // JSON'dan gelen kategorileri işleyelim
                jsonData.categories.forEach(newCat => {
                    let existingCat = categories.find(cat => cat.name === newCat.name);
                    if (!existingCat) {
                        existingCat = { name: newCat.name, items: [] };
                        categories.push(existingCat);
                        console.log(`Yeni kategori oluşturuldu: ${newCat.name}`);
                    }
                    newCat.items.forEach(newItem => {
                        const existingItem = existingCat.items.find(item => item.name === newItem.name);
                        if (!existingItem) {
                            existingCat.items.push(newItem);
                            newCount++; // Her yeni yemek için sayacı artır
                            console.log(`Yeni yemek eklendi: ${newItem.name}`);
                        } else {
                            console.log(`${newItem.name} zaten mevcut, eklenmedi.`);
                        }
                    });
                });

                loadCategories(); // Arayüzü güncelle
                const message = `🍽 Yemek listesi eklendi! Çakışanlar korunarak ${newCount} yeni yemek eklendi.`;
                showNotification(message, "success");
                console.log("Eklenen yemek sayısı:", newCount);
            } catch (error) {
                showNotification("Hata: Geçersiz JSON dosyası!", "warning");
                console.error("JSON parse hatası:", error);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function processJsonFoodList(jsonData) {
    console.log("processJsonFoodList çalışıyor...");
    const newMeals = jsonData.meals || jsonData;
    if (!Array.isArray(newMeals)) {
        showNotification("Hata: JSON 'meals' array formatında olmalı!", "warning");
        console.log("Hatalı JSON formatı:", jsonData);
        return;
    }

    let newCount = 0;
    const addedMeals = [];

    console.log("Mevcut kategoriler:", categories);
    newMeals.forEach(meal => {
        let exists = false;
        categories.forEach(category => {
            if (category.items.some(item => item.name.toLowerCase() === meal.name.toLowerCase())) {
                exists = true;
                console.log(`${meal.name} zaten mevcut, eklenmeyecek.`);
            }
        });

        if (!exists) {
            const newFood = {
                name: meal.name,
                calories: parseFloat(meal.calories) || 0,
                protein: parseFloat(meal.protein) || 0,
                carbs: parseFloat(meal.carbs) || 0,
                fat: parseFloat(meal.fat) || 0,
                category: meal.category || "Tanımsız",
                mealType: meal.mealType || ["lunch"],
                tags: meal.tags || ["keto"],
                role: meal.role || determineRole(meal.name),
                keto: meal.keto !== undefined ? meal.keto : true,
                lowcarb: meal.lowcarb !== undefined ? meal.lowcarb : true,
                fillerLunch: meal.fillerLunch || false,
                fillerDinner: meal.fillerDinner || false,
                step: parseFloat(meal.step) || 0.5,
                maxQuantity: parseFloat(meal.maxQuantity) || 1,
                minQuantity: parseFloat(meal.minQuantity) || 0.5
            };

            let category = categories.find(cat => cat.name === newFood.category);
            if (!category) {
                category = { name: newFood.category, items: [] };
                categories.push(category);
                console.log(`Yeni kategori oluşturuldu: ${newFood.category}`);
            }
            category.items.push(newFood);
            newCount++;
            addedMeals.push(newFood.name);
            console.log(`Yeni yemek eklendi: ${newFood.name}`);
        }
    });

    loadCategories(); // Arayüzü güncelle
    const message = `🍽 Yemek listesi eklendi! Çakışanlar korunarak ${newCount} yeni yemek eklendi.`;
    showNotification(message, "success");
    console.log("İşlem tamamlandı. Eklenen yemekler:", addedMeals);
    console.log("Gösterilen mesaj:", message);
}

function exportFoodList() {
    const jsonContent = JSON.stringify({ categories: categories }, null, 2);
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'food_list.json';
    a.click();
    URL.revokeObjectURL(url);
    showNotification("Son yemek listesi JSON olarak dışa aktarıldı!");
}



        function loadCompatibilityRules() {
            const compatList = document.getElementById('compatibilityList');
            compatList.innerHTML = compatibilityTable.map((rule, index) => `
                <div class="mb-1 d-flex justify-content-between">
                    <span>${rule.keyword1} ↔ ${rule.keyword2.join(', ')} (${rule.degree})</span>
                    <button class="btn btn-danger btn-sm" onclick="deleteCompatibilityRule(${index})" title="Sil"><i class="bi bi-trash"></i></button>
                </div>
            `).join('');
        }

        function deleteCompatibilityRule(index) {
            compatibilityTable.splice(index, 1);
            loadCompatibilityRules();
            showNotification("Uyumluluk kuralı silindi!");
        }
        
        function addMealTemplate() {
            const mealType = document.getElementById('templateMealType').value;
            const frequency = parseInt(document.getElementById('templateFrequency').value);
            const items = [];
            const templateItems = document.getElementById('templateItems');
            const rows = templateItems.getElementsByClassName('row');
            for (let i = 0; i < rows.length; i++) {
                const keyword = document.getElementById(`templateItem${i + 1}Keyword`).value;
                const role = document.getElementById(`templateItem${i + 1}Role`).value;
                const quantity = parseInt(document.getElementById(`templateItem${i + 1}Quantity`).value);
                if (keyword) items.push({ keyword, role, quantity });
            }
            mealTemplates.push({ mealType, frequency, items });
            loadMealTemplates();
            templateItems.innerHTML = `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="templateItem1Keyword" class="form-label">Etiket</label>
                        <input type="text" id="templateItem1Keyword" class="form-control" placeholder="örn: yumurta, omlet">
                    </div>
                    <div class="col-4">
                        <label for="templateItem1Role" class="form-label">Rol</label>
                        <select id="templateItem1Role" class="form-select">
                            <option value="mainDish">Ana Yemek</option>
                            <option value="sideDish">Yan Yemek</option>
                            <option value="drink">İçecek</option>
                            <option value="soup">Çorba</option>
                            <option value="dessert">Tatlı</option>
                            <option value="fruit">Meyve</option>
                            <option value="bread">Ekmek</option>
                            <option value="snack">Atıştırmalık</option>
                            <option value="supplement">Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="templateItem1Quantity" class="form-label">Sayı</label>
                        <input type="number" id="templateItem1Quantity" class="form-control" value="1" min="1">
                    </div>
                </div>
            `;
            showNotification("Öğün şablonu eklendi!");
        }

        function addTemplateItem() {
            const templateItems = document.getElementById('templateItems');
            const itemCount = templateItems.getElementsByClassName('row').length + 1;
            templateItems.innerHTML += `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="templateItem${itemCount}Keyword" class="form-label">Etiket</label>
                        <input type="text" id="templateItem${itemCount}Keyword" class="form-control" placeholder="örn: yumurta, omlet">
                    </div>
                    <div class="col-4">
                        <label for="templateItem${itemCount}Role" class="form-label">Rol</label>
                        <select id="templateItem${itemCount}Role" class="form-select">
                            <option value="mainDish">Ana Yemek</option>
                            <option value="sideDish">Yan Yemek</option>
                            <option value="drink">İçecek</option>
                            <option value="soup">Çorba</option>
                            <option value="dessert">Tatlı</option>
                            <option value="fruit">Meyve</option>
                            <option value="bread">Ekmek</option>
                            <option value="snack">Atıştırmalık</option>
                            <option value="supplement">Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="templateItem${itemCount}Quantity" class="form-label">Sayı</label>
                        <input type="number" id="templateItem${itemCount}Quantity" class="form-control" value="1" min="1">
                    </div>
                </div>
            `;
        }

        function loadMealTemplates() {
            console.log("mealTemplates içeriği:", mealTemplates);
    const templatesList = document.getElementById('mealTemplatesList');
    templatesList.innerHTML = mealTemplates.map((template, index) => `
        <div class="mb-1 d-flex justify-content-between">
            <span>${template.mealType} (${template.frequency}x): ${template.items.map(i => `${i.keyword} (${i.role})`).join(', ')}</span>
            <div>
                <button class="btn btn-success btn-sm" onclick="addTemplateToMeal(${index})" title="Öğüne Ekle">
                    <i class="bi bi-plus-circle"></i>
                </button>
                <button class="btn btn-warning btn-sm" onclick="editMealTemplate(${index})" title="Düzenle"><i class="bi bi-pencil"></i></button>
                <button class="btn btn-danger btn-sm" onclick="deleteMealTemplate(${index})" title="Sil"><i class="bi bi-trash"></i></button>
            </div>
        </div>
    `).join('');
}

function addTemplateToMeal(index) {
    const template = mealTemplates[index];
    if (!template) {
        alert("Şablon bulunamadı!");
        return;
    }

    // Şablondaki öğeleri uygun öğüne ekleme işlemi
    template.items.forEach(item => {
        const food = findFood(item.keyword); // Yemeği bul
        if (food) {
            // Yemeği öğüne ekle
            weeks[selectedWeek - 1].days[selectedDay].meals[template.mealType].push({
                name: food.name,
                quantity: item.quantity
            });
        } else {
            console.error(`Yemek bulunamadı: ${item.keyword}`);
        }
    });

    // Veri modelini kontrol etmek için konsola yazdır
    console.log("Güncellenmiş weeks dizisi:", weeks);

    // Öğünleri yeniden çiz ve makroları hesapla
    renderMeals();
    calculateMacros();
    showNotification("Şablon öğüne eklendi!");
}

// Şablondaki bir öğeyi ilgili öğüne ekleyen fonksiyon
function addMealItem(mealType, keyword, role, quantity) {
    const mealSection = document.getElementById(`${mealType}Meal`);
    if (!mealSection) {
        alert(`Öğün bölümü bulunamadı: ${mealType}`);
        return;
    }

    // Yeni yemek öğesi oluştur
    const mealItem = document.createElement("div");
    mealItem.classList.add("meal-item");
    mealItem.innerHTML = `${keyword} (${role}) - Miktar: ${quantity}`;

    // Öğüne DOM'a ekle
    mealSection.appendChild(mealItem);

    // Veri modeline de ekle
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType].push({
        name: keyword,
        quantity: quantity
    });
}



        function editMealTemplate(index) {
            const template = mealTemplates[index];
            document.getElementById('editTemplateIndex').value = index;
            document.getElementById('editTemplateName').value = `${template.mealType}_${index}`;
            document.getElementById('editTemplateMealType').value = template.mealType;
            document.getElementById('editTemplateFrequency').value = template.frequency;
            const itemsDiv = document.getElementById('editTemplateItems');
            itemsDiv.innerHTML = template.items.map((item, i) => `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Keyword" class="form-label">Etiket</label>
                        <input type="text" id="editTemplateItem${i + 1}Keyword" class="form-control" value="${item.keyword}">
                    </div>
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Role" class="form-label">Rol</label>
                        <select id="editTemplateItem${i + 1}Role" class="form-select">
                            <option value="mainDish" ${item.role === 'mainDish' ? 'selected' : ''}>Ana Yemek</option>
                            <option value="sideDish" ${item.role === 'sideDish' ? 'selected' : ''}>Yan Yemek</option>
                            <option value="drink" ${item.role === 'drink' ? 'selected' : ''}>İçecek</option>
                            <option value="soup" ${item.role === 'soup' ? 'selected' : ''}>Çorba</option>
                            <option value="dessert" ${item.role === 'dessert' ? 'selected' : ''}>Tatlı</option>
                            <option value="fruit" ${item.role === 'fruit' ? 'selected' : ''}>Meyve</option>
                            <option value="bread" ${item.role === 'bread' ? 'selected' : ''}>Ekmek</option>
                            <option value="snack" ${item.role === 'snack' ? 'selected' : ''}>Atıştırmalık</option>
                            <option value="supplement" ${item.role === 'supplement' ? 'selected' : ''}>Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Quantity" class="form-label">Sayı</label>
                        <input type="number" id="editTemplateItem${i + 1}Quantity" class="form-control" value="${item.quantity}" min="1">
                    </div>
                </div>
            `).join('');
            document.getElementById('editTemplateForm').style.display = 'block';
        }

        function saveEditedTemplate(event) {
            event.preventDefault();
  closeAddFoodModal();
            const index = parseInt(document.getElementById('editTemplateIndex').value);
            const mealType = document.getElementById('editTemplateMealType').value;
            const frequency = parseInt(document.getElementById('editTemplateFrequency').value);
            const items = [];
            const itemsDiv = document.getElementById('editTemplateItems');
            const rows = itemsDiv.getElementsByClassName('row');
            for (let i = 0; i < rows.length; i++) {
                const keyword = document.getElementById(`editTemplateItem${i + 1}Keyword`).value;
                const role = document.getElementById(`editTemplateItem${i + 1}Role`).value;
                const quantity = parseInt(document.getElementById(`editTemplateItem${i + 1}Quantity`).value);
                if (keyword) items.push({ keyword, role, quantity });
            }
            mealTemplates[index] = { mealType, frequency, items };
            loadMealTemplates();
            cancelEditTemplate();
            showNotification("Şablon güncellendi!");
        }

        function cancelEditTemplate() {
            document.getElementById('editTemplateForm').style.display = 'none';
        }
        function deleteMealTemplate(index) {
            mealTemplates.splice(index, 1);
            loadMealTemplates();
            showNotification("Şablon silindi!");
        }
        function generateRandomTemplate() {
            rules.forEach(rule => {
        if (rule.type === 'frequency' && rule.scope === 'weekly' && rule.name) {
            let weeklyCount = 0;
            weeks.forEach(week => {
                Object.values(week.days).forEach(day => {
                    ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                        weeklyCount += (day.meals[mt] || []).filter(item => 
                            item.name.toLowerCase().includes(rule.name.toLowerCase())
                        ).length;
                    });
                });
            });
            if (weeklyCount > rule.frequency) {
                weeks.forEach(week => {
                    Object.values(week.days).forEach(day => {
                        ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                            day.meals[mt] = day.meals[mt].filter(item => {
                                if (item.name.toLowerCase().includes(rule.name.toLowerCase())) {
                                    if (weeklyCount <= rule.frequency) return true;
                                    weeklyCount--;
                                    return false;
                                }
                                return true;
                            });
                        });
                    });
                });
            }
        }
    });
            const mealType = document.getElementById('templateMealType').value;
            const frequency = parseInt(document.getElementById('templateFrequency').value);
            const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
            const likedFoods = patientData.likedFoods || [];
            const dislikedFoods = patientData.dislikedFoods || [];
            const items = [];
            const availableFoods = categories.flatMap(cat => cat.items)
                .filter(f => f.mealType.includes(mealType) && (dietMode === 'keto' ? f.keto : f.lowcarb))
                .filter(f => !dislikedFoods.some(df => f.name.toLowerCase().includes(df.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))));
            const rolesToInclude = ['mainDish', 'sideDish', 'drink', 'soup', 'dessert'];
            rolesToInclude.forEach(role => {
                const filtered = availableFoods.filter(f => f.role === role);
                if (filtered.length > 0) {
                    const preferred = filtered.filter(f => likedFoods.some(lf => f.name.toLowerCase().includes(lf.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(lf.toLowerCase()))));
                    const food = preferred.length > 0 ? preferred[Math.floor(Math.random() * preferred.length)] : filtered[Math.floor(Math.random() * filtered.length)];
                    items.push({ keyword: food.name, role, quantity: 1 });
                }
            });
            mealTemplates.push({ mealType, frequency, items });
            loadMealTemplates();
            showNotification("Rastgele şablon oluşturuldu!");
        }
        // Mevcut generateAutoPlan fonksiyonunu bulun (yaklaşık 2200. satır) ve komple şu kodla değiştirin:
        function generateAutoPlan() {
    const settings = getPlanningSettings();
    settings.targetCalories = globalTargetCalories || 1064;
    settings.targetProtein = globalTargetProtein || 56;
    settings.targetCarbs = globalTargetCarbs || 21;
    settings.targetFat = globalTargetFat || 83;
    settings.macroTolerance = parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1;
    settings.breakfastMin = parseInt(document.getElementById('breakfastMin')?.value) || 1;
    settings.breakfastMax = parseInt(document.getElementById('breakfastMax')?.value) || 1;
    settings.lunchMin = parseInt(document.getElementById('lunchMin')?.value) || 2;
    settings.lunchMax = parseInt(document.getElementById('lunchMax')?.value) || 5;
    settings.dinnerMin = parseInt(document.getElementById('dinnerMin')?.value) || 2;
    settings.dinnerMax = parseInt(document.getElementById('dinnerMax')?.value) || 5;

    console.log("generateAutoPlan: Planlama başlatılıyor, hedef kalori:", settings.targetCalories);
    generatePlan(settings);
}
console.time('planGeneration');

/**
 * 🚀 YENİ GELİŞMİŞ PLAN OLUŞTURMA FONKSİYONU
 * Smart Planning Engine ile optimize edilmiş plan oluşturma
 * GitHub entegrasyonu ile cloud-based veri yönetimi
 */
async function generateAdvancedPlan() {
    console.log('🎯 GitHub Entegreli Gelişmiş Plan Oluşturma Başlatılıyor...');
    
    try {
        // Kullanıcı tercihini kontrol et
        const useSmartAlgorithm = document.getElementById('useSmartPlanning')?.checked;
        
        if (!useSmartAlgorithm) {
            // Klasik algoritma kullan
            generateFastPlan();
            return;
        }

        // Loading göster
        showNotification('🔄 GitHub Smart Planning Engine başlatılıyor...', 'info');
        
        // Mevcut durumu kaydet
        saveState();
        
        // Plan ayarlarını al
        const settings = getPlanningSettings();
        
        // Smart Planning Engine ile GitHub entegreli plan oluştur
        const result = await smartPlanningEngine.generateSmartPlan(settings);
        
        // GitHub'a plan sonuçlarını kaydet
        if (currentPatient && githubDataManager) {
            try {
                console.log('💾 Plan sonuçları GitHub\'a kaydediliyor...');
                await saveCurrentPlanToGitHub();
                showNotification('💾 Plan GitHub\'a başarıyla kaydedildi!', 'success');
            } catch (saveError) {
                console.error('⚠️ GitHub kaydetme hatası:', saveError);
                showNotification('⚠️ Plan oluşturuldu ama GitHub\'a kaydedilemedi', 'warning');
            }
        }
        
        // Başarılı
        showNotification('✅ GitHub entegreli akıllı plan başarıyla oluşturuldu! 🎉', 'success');
        console.log('🎯 GitHub entegreli plan oluşturma tamamlandı:', result);
        
    } catch (error) {
        console.error('❌ Gelişmiş plan oluşturma hatası:', error);
        showNotification('⚠️ Plan oluşturma hatası! Klasik algoritma deneniyor...', 'warning');
        
        // Hata durumunda klasik algoritma kullan
        generateFastPlan();
    }
}

/**
 * PLAN AYARLARI MODAL GÖSTER
 */
function showPlanSettings() {
    // Plan ayarları modalını göster (gelecekte eklenecek)
    showNotification('⚙️ Plan ayarları yakında eklenecek!', 'info');
}

/**
 * PLAN AYARLARINI AL
 */
function getPlanningSettings() {
    // Mevcut hedefleri al
    const targetCalories = parseFloat(document.getElementById('targetCalories')?.value) || globalTargetCalories || 2000;
    const targetProtein = parseFloat(document.getElementById('targetProtein')?.value) || globalTargetProtein || 150;
    const targetCarbs = parseFloat(document.getElementById('targetCarbs')?.value) || globalTargetCarbs || 50;
    const targetFat = parseFloat(document.getElementById('targetFat')?.value) || globalTargetFat || 150;
    
    // Öğün dağılım oranlarını al
    const lunchRatio = parseFloat(document.getElementById('lunchRatio')?.value) || 40;
    const dinnerRatio = parseFloat(document.getElementById('dinnerRatio')?.value) || 35;
    
    return {
        targetCalories,
        targetProtein,
        targetCarbs,
        targetFat,
        lunchRatio,
        dinnerRatio,
        dietMode,
        currentPatient
    };
}

// generateFastPlan fonksiyonunu şu şekilde değiştirin:
function generateFastPlan() {
    console.log("generateFastPlan başladı...");
    saveState();

    // 1. Uygun yemekleri filtrele
    const availableFoods = categories.flatMap(cat => cat.items)
        .filter(f => f.calories > 0 && (dietMode === 'keto' ? f.keto : f.lowcarb));

    const plans = [];
    const sapmalar = [];
    const PLAN_COUNT = 5;

    for (let i = 0; i < PLAN_COUNT; i++) {
        // Her deneme için haftayı sıfırla
        weeks[selectedWeek - 1] = {
    days: {
        monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
        sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
    }
};

        // 2. Ayarları al ve planı oluştur
        const settings = getPlanningSettings();
        generatePlan(settings);

        // 3. Sapmaları hesapla
        let totalProteinSapma = 0;
        let totalFatSapma = 0;
        let daysCounted = 0;

        Object.values(weeks[0].days).forEach(day => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                const meal = day.meals[mealType] || [];
                const mealProtein = meal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.protein * (item.quantity || 1) : 0);
                }, 0);
                const mealFat = meal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.fat * (item.quantity || 1) : 0);
                }, 0);

                // Hedef oranları
                const mealRatio = mealType === 'breakfast'
                    ? (1 - (settings.lunchCalorieRatio || 40) / 100 - (settings.dinnerCalorieRatio || 30) / 100)
                    : mealType === 'lunch'
                        ? (settings.lunchCalorieRatio || 40) / 100
                        : (settings.dinnerCalorieRatio || 30) / 100;

                const targetProtein = (settings.targetProtein || 56) * mealRatio;
                const targetFat = (settings.targetFat || 84) * mealRatio;

                // Sapma oranı
                totalProteinSapma += Math.abs(mealProtein - targetProtein) / (targetProtein || 1);
                totalFatSapma += Math.abs(mealFat - targetFat) / (targetFat || 1);
                daysCounted++;
            });
        });

        const avgProteinSapma = totalProteinSapma / daysCounted;
        const avgFatSapma = totalFatSapma / daysCounted;

        plans.push(JSON.parse(JSON.stringify(weeks)));
        sapmalar.push({ protein: avgProteinSapma, fat: avgFatSapma });
        console.log(`Plan ${i + 1}: Protein sapma ${avgProteinSapma.toFixed(2)}, Yağ sapma ${avgFatSapma.toFixed(2)}`);
    }

    // 4. En iyi planı seç
    let bestPlanIndex = 0;
    let minSapma = Infinity;
    sapmalar.forEach((sapma, index) => {
        const score = sapma.protein * 0.6 + sapma.fat * 0.4;
        if (score < minSapma) {
            minSapma = score;
            bestPlanIndex = index;
        }
    });

    weeks = plans[bestPlanIndex];
    selectedDay = "monday";
    selectedWeek = 1;

    // 5. Kahvaltıya sabit kahve ekle
    if (typeof forceBulletproofCoffee === "function") {
        forceBulletproofCoffee();
    }

    renderMeals();
    calculateMacros();
    console.log("En iyi plan seçildi:", bestPlanIndex + 1);

    if (typeof showNotification === 'function') {
        showNotification("Hızlı planlama tamamlandı! En iyi plan seçildi.", "success");
    }
    if (typeof updateCompatibilityStatus === 'function') {
        updateCompatibilityStatus();
    }
}

// Bu fonksiyonu generateFastPlan fonksiyonu tanımının üstüne ekleyin
function forceBulletproofCoffee() {
    console.log("forceBulletproofCoffee: Kahvaltılara Kurşun Geçirmez Kahve ekleniyor...");

    let coffee = categories.flatMap(cat => cat.items).find(item =>
        item.name === "Kurşun Geçirmez Kahve" ||
        (item.name.toLowerCase().includes("kurşun") && item.name.toLowerCase().includes("kahve"))
    );

    if (!coffee) {
        console.warn("Kurşun Geçirmez Kahve bulunamadı, varsayılan nesne oluşturuluyor.");
        coffee = {
            name: "Kurşun Geçirmez Kahve",
            calories: 200,
            protein: 0,
            carbs: 0,
            fat: 22,
            role: "drink",
            keto: true,
            lowcarb: true,
            mealType: ["breakfast"],
            seasonRange: "[1,12]"
        };

        let miscCategory = categories.find(cat => cat.name === "Yeni Eklenenler");
        if (!miscCategory) {
            miscCategory = { name: "Yeni Eklenenler", items: [] };
            categories.push(miscCategory);
        }
        miscCategory.items.push(coffee);
        console.log("Kurşun Geçirmez Kahve 'Yeni Eklenenler' kategorisine eklendi.");
    }

    weeks.forEach(week => {
        Object.values(week.days).forEach(day => {
            day.meals.breakfast = [{
                name: coffee.name,
                quantity: 1,
                role: coffee.role || "drink",
                unit: "fincan"
            }];
        });
    });

    console.log("Tüm kahvaltılara yalnızca Kurşun Geçirmez Kahve eklendi!");
}

function getPlanningSettings() {
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    return {
        likedFoods: patientData.likedFoods || [],
        dislikedFoods: patientData.dislikedFoods || [],
        minItems: parseInt(document.getElementById('minItemsPerMeal').value) || 1,
        maxItems: parseInt(document.getElementById('maxItemsPerMeal').value) || 5,
        flexibility: parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1,
        targetCalories: parseFloat(document.getElementById('targetCalories').value) || 2000,
        targetProtein: parseFloat(document.getElementById('targetProtein').value) || 100,
        targetFat: parseFloat(document.getElementById('targetFat').value) || 150,
        targetCarbs: parseFloat(document.getElementById('targetCarbs').value) || (dietMode === 'keto' ? 30 : 75),
        breakfastMin: parseInt(document.getElementById('breakfastMin').value) || 1,
        breakfastMax: parseInt(document.getElementById('breakfastMax').value) || 3,
        lunchMin: parseInt(document.getElementById('lunchMin').value) || 2,
        lunchMax: parseInt(document.getElementById('lunchMax').value) || 5,
        dinnerMin: parseInt(document.getElementById('dinnerMin').value) || 2,
        dinnerMax: parseInt(document.getElementById('dinnerMax').value) || 5,
        macroPriority: parseInt(document.getElementById('macroPriority').value) || 1,
        templatePriority: parseInt(document.getElementById('templatePriority').value) || 1,
        rulePriority: parseInt(document.getElementById('rulePriority').value) || 1,
        compatibilityPriority: parseInt(document.getElementById('compatibilityPriority').value) || 1,
        managementPriority: parseInt(document.getElementById('managementPriority').value) || 1,
        macroTolerance: parseInt(document.getElementById('macroTolerance').value) / 100 || 0.05,
        optimizeCoefficients: document.getElementById('optimizeCoefficients').checked || false,
        breakfastPriority: document.getElementById('breakfastPriority').value || 'medium',
        lunchPriority: document.getElementById('lunchPriority').value || 'medium',
        dinnerPriority: document.getElementById('dinnerPriority').value || 'medium',
        fixedBreakfastMeal: document.getElementById('fixedBreakfastMeal').value || '',
        fixedLunchMeal: document.getElementById('fixedLunchMeal').value || '',
        fixedDinnerMeal: document.getElementById('fixedDinnerMeal').value || ''
    };
}

// applyAllRules fonksiyonu
function applyAllRules() {
  try {
    if (typeof saveState === 'function') {
      saveState(); // İşlemden önce durumu kaydet
    }
    
    const settings = getPlanningSettings();
    if (!settings) {
      throw new Error("Planlama ayarları alınamadı!");
    }

    // Her öğün için uyumluluk etiketlerini kontrol et ve düzelt
    const week = weeks[selectedWeek - 1];
    Object.entries(week.days).forEach(([day, dayData]) => {
      ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
        const mealItems = dayData.meals[mealType] || [];
        
        // Uyumluluk kurallarını al
        const compatRules = rules.filter(rule => 
          rule.type === 'compatibility' && rule.keyword1 && rule.keyword2 && rule.keyword2.length > 0
        );
        
        // Her kural için mevcut öğünü kontrol et
        compatRules.forEach(rule => {
          const keyword1 = rule.keyword1.toLowerCase();
          const keyword2List = rule.keyword2.map(k => k.toLowerCase());
          
          // Yemeklerin etiketlerini kontrol et
          const foodsWithTags = mealItems.map(item => {
            const food = findFood(item.name);
            if (!food) return null;
            
            const tags = (food.compatibilityTags && food.compatibilityTags.length) ? 
                        food.compatibilityTags.map(tag => tag.toLowerCase()) : 
                        (food.tags ? food.tags.map(tag => tag.toLowerCase()) : []);
                        
            return { item, food, tags };
          }).filter(f => f !== null);
          
          // Kural değerlendirmesi
          const hasKeyword1 = foodsWithTags.some(f => f.tags.includes(keyword1));
          const hasKeyword2 = foodsWithTags.some(f => f.tags.some(tag => keyword2List.includes(tag)));
          
          // Pozitif uyumluluk: Her iki etiket de olmalı
          if (rule.degree > 0 && hasKeyword1 && !hasKeyword2) {
            // Keyword1 var ama keyword2 yok, uyumlu bir yemek ekle
            const availableFoods = categories.flatMap(cat => cat.items)
              .filter(f => {
                // Uyumlu bir yemek bul
                const fTags = (f.compatibilityTags && f.compatibilityTags.length) ? 
                             f.compatibilityTags.map(tag => tag.toLowerCase()) : 
                             (f.tags ? f.tags.map(tag => tag.toLowerCase()) : []);
                
                return fTags.some(tag => keyword2List.includes(tag)) && 
                       !mealItems.some(item => item.name === f.name) && 
                       isMealTypeCompatible(f, mealType);
              });
            
            if (availableFoods.length > 0) {
              // Rastgele bir uyumlu yemek seç ve ekle
              const foodToAdd = availableFoods[Math.floor(Math.random() * availableFoods.length)];
              mealItems.push({ name: foodToAdd.name, quantity: 1 });
              console.log(`Uyumluluk kuralı uygulandı: ${foodToAdd.name} eklendi (Kural ID: ${rule.id})`);
            }
          }
          
          // Negatif uyumluluk: İki etiket birlikte olmamalı
          else if (rule.degree < 0 && hasKeyword1 && hasKeyword2) {
            // İki etiket de var, uyumsuz etiketli yemeği çıkar (keyword2)
            const foodWithKeyword2 = foodsWithTags.find(f => 
              f.tags.some(tag => keyword2List.includes(tag))
            );
            
            if (foodWithKeyword2) {
              const index = mealItems.findIndex(item => item.name === foodWithKeyword2.item.name);
              if (index !== -1) {
                mealItems.splice(index, 1);
                console.log(`Uyumluluk kuralı uygulandı: ${foodWithKeyword2.item.name} çıkarıldı (Kural ID: ${rule.id})`);
              }
            }
          }
        });
        
        // Güncellenmiş öğün listesini kaydet
        dayData.meals[mealType] = mealItems;
      });
    });
    
    // Diğer kural uygulamalarını çağır
    settings.rulePriority = 100; // Kurallara maksimum öncelik ver
    generatePlan(settings); // Planı oluştur
    
    renderMeals();
    calculateMacros();
    updateCompatibilityStatus();
    
    if (typeof showNotification === 'function') {
      showNotification("Tüm kurallar başarıyla uygulandı!", "success");
    }
  } catch (error) {
    console.error("Kurallar uygulanırken hata oluştu:", error);
    if (typeof showNotification === 'function') {
      showNotification(`Kurallar uygulanamadı: ${error.message}`, "danger");
    }
  }
}

// Formları tanımla
const forms = {
    frequency: document.getElementById('frequencyRuleForm'),
    pair: document.getElementById('pairRuleForm'),
    dependOn: document.getElementById('dependOnRuleForm'),
    categoryLock: document.getElementById('categoryLockRuleForm'),
    default: document.getElementById('defaultForm')
};

// Tüm formları gizle
function hideAllForms() {
    Object.values(forms).forEach(form => {
        if (form) form.style.display = 'none';
    });
}

// Kural tipine göre formu göster
function showRuleForm(type) {
    if (!forms || typeof forms !== 'object') {
        console.error("forms nesnesi tanımlı değil veya geçersiz!");
        return;
    }

    hideAllForms(); // Önce tüm formları gizle

    const ruleFormMap = {
        'frequency': 'frequencyRuleForm',
        'pairWith': 'pairRuleForm',
        'avoidPair': 'pairRuleForm',
        'dependOn': 'dependOnRuleForm',
        'categoryLock': 'categoryLockRuleForm',
        'maxRoleCount': 'defaultForm' // Yeni kural tipi için varsayılan form
    };

    const formId = ruleFormMap[type] || 'defaultForm';
    const form = forms[formId.replace('RuleForm', '').toLowerCase()] || document.getElementById(formId);

    if (form) {
        form.style.display = 'block';

        // Ek input alanlarını kontrol et ve göster/gizle (yalnızca defaultForm için)
        if (formId === 'defaultForm') {
            const frequencyInput = document.getElementById('frequencyInput');
            const countInput = document.getElementById('countInput');
            const pairInput = document.getElementById('pairInput');

            if (frequencyInput) frequencyInput.style.display = type === 'frequency' ? 'block' : 'none';
            if (countInput) countInput.style.display = type === 'maxRoleCount' ? 'block' : 'none'; // maxRoleCount için countInput
            if (pairInput) pairInput.style.display = ['pairWith', 'avoidPair'].includes(type) ? 'block' : 'none';
        }
    } else {
        console.warn(`${formId} bulunamadı! Kural tipi: ${type}`);
    }

    if (!ruleFormMap[type]) {
        console.warn(`Desteklenmeyen kural tipi: ${type}`);
    }
}

const ruleFormMap = {
    frequency: 'frequencyRuleForm',
    pairWith: 'pairRuleForm',
    avoidPair: 'pairRuleForm',
    dependOn: 'dependOnRuleForm',
    categoryLock: 'categoryLockRuleForm'
};

function checkKeywordConflict(foodName, currentMeal, mealType) {
    if (!['breakfast', 'lunch', 'dinner'].includes(mealType)) {
        console.warn(`checkKeywordConflict: Geçersiz mealType: ${mealType}`);
        return false;
    }

    const food = findFood(foodName);
    if (!food || !Array.isArray(food.tags)) {
        return false;
    }

    const excludedTags = {
        breakfast: document.getElementById('excludedTagsBreakfast')?.value.split(',').map(t => t.trim().toLowerCase()) || [],
        lunch: document.getElementById('excludedTagsLunch')?.value.split(',').map(t => t.trim().toLowerCase()) || [],
        dinner: document.getElementById('excludedTagsDinner')?.value.split(',').map(t => t.trim().toLowerCase()) || []
    };

    const mealExcludedTags = excludedTags[mealType] || [];
    const foodTags = food.tags.map(tag => tag.toLowerCase()).filter(tag => !mealExcludedTags.includes(tag));

    for (const mealItem of currentMeal) {
        const existingFood = findFood(mealItem.name);
        if (!existingFood || !Array.isArray(existingFood.tags)) continue;
        const existingTags = existingFood.tags.map(tag => tag.toLowerCase()).filter(tag => !mealExcludedTags.includes(tag));

        const commonTags = foodTags.filter(tag => existingTags.includes(tag));
        if (commonTags.length > 0) {
            // Alternatif varsa engelle, yoksa izin ver
            const hasAlternative = currentMeal.every(item => {
                const altFood = findFood(item.name);
                if (!altFood || !Array.isArray(altFood.tags)) return true;
                const altTags = altFood.tags.map(tag => tag.toLowerCase()).filter(tag => !mealExcludedTags.includes(tag));
                return !foodTags.some(tag => altTags.includes(tag));
            });
            if (hasAlternative) {
                console.log(`"${foodName}" eklenemedi: "${mealItem.name}" ile etiket çakışması (${commonTags.join(', ')}).`);
                return true;
            }
        }
    }

    const ignoreWords = ["ve", "ile", "gram", "gr", "kaşığı", "tatlı", "yemek", "çorba", "kase", "dilim", "adet", "porsiyon", "zeytinyağı", "tuz", "baharatlar"];
    const foodWords = foodName.toLowerCase().split(/\s+/).filter(word => !ignoreWords.includes(word) && word.length > 2);

    for (const mealItem of currentMeal) {
        const existingWords = mealItem.name.toLowerCase().split(/\s+/).filter(word => !ignoreWords.includes(word) && word.length > 2);
        const commonWords = foodWords.filter(word => existingWords.includes(word));
        if (commonWords.length > 0) {
            console.log(`"${foodName}" eklenemedi: "${mealItem.name}" ile kelime çakışması (${commonWords.join(", ")}).`);
            return true;
        }
    }

    return false;
}

if (!forms.frequency) {
    console.warn("frequencyRuleForm bulunamadı!");
    if (typeof showNotification === 'function') {
        showNotification("Frequency kural formu bulunamadı!", "warning");
    }
}

// Global yardımcı fonksiyonlar
function checkDependOn(foodName, mealItems) {
    const dependentRule = rules.find(r => r.type === 'dependOn' && r.food?.toLowerCase().includes(foodName.toLowerCase()));
    if (!dependentRule) return true;
    const requiredFood = dependentRule.requiredFood?.toLowerCase();
    return mealItems.some(item => item.name.toLowerCase().includes(requiredFood));
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
// Mevcut findBestFood fonksiyonunda uyumluluk skorunu hesapla
function findBestFood(foodList, targets, currentMeal, mealType, prioritizedRules) {
    // Uyumlu yemekleri filtrele
    const filteredFoods = foodList
        .filter(food => {
            if (!food) return false;
            // Uyum kontrolü (ör: checkCompatibility fonksiyonu)
            if (typeof checkCompatibility === "function") {
                return checkCompatibility(food, currentMeal);
            }
            return true;
        })
        .map(food => {
            // Uyum skorunu hesapla
            let compatScore = 0;
            if (typeof checkCompatibility === "function") {
                compatScore = currentMeal.reduce((total, mealItem) => {
                    const mealFood = (mealItem && mealItem.name) ? mealItem : (typeof mealItem === 'string' ? findFood(mealItem) : null);
                    const compatValue = mealFood ? checkCompatibility(food, [mealFood]) : 0;
                    return total + (compatValue ? 1 : -1);
                }, 0);
            }
            // Makro hedeflerine yakınlık skorunu hesapla
            const score =
                (targets.protein > 0 ? Math.min(food.protein / targets.protein, 1) * 0.4 : 0) +
                (targets.fat > 0 ? Math.min(food.fat / targets.fat, 1) * 0.3 : 0) +
                (targets.carbs > 0 ? Math.min(food.carbs / targets.carbs, 1) * 0.15 : 0) +
                (targets.calories > 0 ? Math.min(food.calories / targets.calories, 1) * 0.15 : 0) +
                (compatScore * 0.1);
            return { food, score };
        });

    if (filteredFoods.length === 0) return null;

    // En yüksek puanı bul
    const maxScore = Math.max(...filteredFoods.map(f => f.score));
    // En yüksek puanlı yemekleri al
    const topFoods = filteredFoods.filter(f => f.score === maxScore);
    // Rastgele birini seç (eşit puanlılar arasında)
    const selected = topFoods[Math.floor(Math.random() * topFoods.length)];
    return selected.food;
}

function calculateOptimalQuantity(food, targets, currentMeal, mealType, availableFoods) {
    const minQty = food.minQuantity || 0.5;
    const maxQty = food.maxQuantity || 1;
    const step = food.step || 0.5;

    let bestQty = minQty;
    let minDiff = Infinity;

    for (let qty = minQty; qty <= maxQty; qty += step) {
        const diff = 
            Math.abs(targets.protein - food.protein * qty) * 0.4 +
            Math.abs(targets.fat - food.fat * qty) * 0.3 +
            Math.abs(targets.carbs - food.carbs * qty) * 0.15 +
            Math.abs(targets.calories - food.calories * qty) * 0.15;
        if (diff < minDiff) {
            minDiff = diff;
            bestQty = qty;
        }
    }
    return bestQty;
}
function getCurrentMacro(meal, macro, foodList) {
    return meal.reduce((sum, item) => {
        const food = foodList.find(f => f.name === item.name);
        return sum + (food ? food[macro] * item.quantity : 0);
    }, 0);
}

function isMealTypeCompatible(food, mealType) {
    const mealTypes = Array.isArray(food.mealType) ? food.mealType : [food.mealType];
    return mealTypes.includes(mealType);
}

// Ana generatePlan fonksiyonu - GELIŞTIRILMIŞ VERSIYONU
document.getElementById('fixedBreakfastMeal').value = 'Kurşun Geçirmez Kahve';

/**
 * ⚡ YENİ GELİŞTİRİLMİŞ PLAN OLUŞTURMA
 * Smart Planning Engine ile optimize edilmiş plan oluşturma
 */
async function generatePlan(settings) {
    console.log('🚀 Gelişmiş Plan Oluşturma Başlatılıyor...');
    
    // Kullanıcı tercihlerine göre algoritma seçimi
    const useSmartAlgorithm = document.getElementById('useSmartPlanning')?.checked !== false; // Varsayılan: true
    
    if (useSmartAlgorithm) {
        // 🧠 AKILLI ALGORİTMA KULLAN
        try {
            showNotification('🔄 Akıllı plan algoritması çalışıyor...', 'info');
            const result = await smartPlanner.generateSmartPlan(settings);
            console.log('✅ Smart Planning sonucu:', result);
            return result;
        } catch (error) {
            console.error('Smart Planning hatası:', error);
            showNotification('⚠️ Akıllı algoritma hatası, klasik algoritma kullanılıyor...', 'warning');
            // Hata durumunda klasik algoritma kullan
        }
    }
    
    // 🔄 KLASİK ALGORİTMA (Mevcut sistem - yedek olarak)
    return generatePlanClassic(settings);
}

/**
 * KLASİK PLAN OLUŞTURMA (Eski sistem)
 * Yedek olarak korunuyor
 */
function generatePlanClassic(settings) {
    console.log('🔄 Klasik plan algoritması kullanılıyor...');
    
    if (!Array.isArray(categories)) {
        categories = Object.values(categories);
    }
    let weeklyBreadName = null;

    function hasTagConflictWithMeal(newFood, mealFoods) {
        if (!newFood || !Array.isArray(mealFoods)) return false;
        const excludedTags = ["keto", "lowcarb", "zeytinyağı"];
        const newTags = (newFood.tags || []).map(t => t.toLowerCase()).filter(t => !excludedTags.includes(t));
        for (const item of mealFoods) {
            const existingFood = findFood(item.name);
            if (!existingFood) continue;
            const existingTags = (existingFood.tags || []).map(t => t.toLowerCase()).filter(t => !excludedTags.includes(t));
            if (newTags.some(tag => existingTags.includes(tag))) {
                return true;
            }
        }
        return false;
    }

    function getFoodRole(name) {
        for (const cat of categories) {
            const found = cat.items.find(f => f.name === name);
            if (found) return found.role;
        }
        return null;
    }

    function isFoodNameUsedInDay(meals, foodName) {
        return Object.values(meals).some(mealList =>
            mealList.some(item => item.name === foodName)
        );
    }

    function checkBreadConstraint(food) {
        if (food.role !== 'bread') return false;
        if (weeklyBreadName && food.name !== weeklyBreadName) {
            console.log(`Engellendi: ${food.name} (sabit ekmek: ${weeklyBreadName})`);
            return true;
        }
        if (!weeklyBreadName) {
            weeklyBreadName = food.name;
            console.log(`Haftalık sabit ekmek seçildi: ${weeklyBreadName}`);
        }
        return false;
    }

    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    function isDuplicateInDay(meals, name, role) {
        return Object.values(meals).some(mealList =>
            mealList.some(item => item.name === name && getFoodRole(item.name) === role)
        );
    }

    function shouldSkipFoodAddition(food, mealsOfDay, isFiller = false) {
        const role = food.role;
        if (isDuplicateInDay(mealsOfDay, food.name, role) && role !== 'bread') {
            console.log(`Engellendi: ${food.name} (aynı gün aynı role sahip)`);
            return true;
        }
        if (role === 'bread') {
            if (weeklyBreadName && food.name !== weeklyBreadName) {
                console.log(`Engellendi: ${food.name} (sabit ekmek: ${weeklyBreadName})`);
                return true;
            }
            if (!weeklyBreadName) {
                weeklyBreadName = food.name;
                console.log(`Haftalık sabit ekmek seçildi: ${weeklyBreadName}`);
            }
        }
        return false;
    }

    const filteredFoods = Array.isArray(categories) ? categories.flatMap(cat => cat.items).filter(f => f && f.calories > 0) : [];

    if (!weeks || !Array.isArray(weeks)) {
        console.error("weeks yapısı tanımlı değil veya geçersiz!");
        return;
    }

    console.log("generatePlan: Planlama yapılıyor, hedefler:", {
        calories: settings.targetCalories,
        protein: settings.targetProtein,
        carbs: settings.targetCarbs,
        fat: settings.targetFat
    });

    const currentMonth = new Date().getMonth() + 1;
    console.log("Mevcut ay:", currentMonth);

    function isFoodInSeason(food) {
        if (!food.seasonRange) {
            console.warn(`Yemek için seasonRange tanımlı değil: ${food.name}, tüm yıl kabul ediliyor`);
            return true;
        }
        try {
            const range = JSON.parse(food.seasonRange);
            if (!Array.isArray(range) || range.length !== 2) {
                console.warn(`Geçersiz seasonRange formatı: ${food.name}, ${food.seasonRange}, tüm yıl kabul ediliyor`);
                return true;
            }
            const [start, end] = range.map(Number);
            if (isNaN(start) || isNaN(end) || start < 1 || start > 12 || end < 1 || end > 12) {
                console.warn(`Geçersiz ay değerleri: ${food.name}, ${food.seasonRange}, tüm yıl kabul ediliyor`);
                return true;
            }
            let isInSeason;
            if (start <= end) {
                isInSeason = currentMonth >= start && currentMonth <= end;
            } else {
                isInSeason = currentMonth >= start || currentMonth <= end;
            }
            console.log(`Yemek: ${food.name}, seasonRange: ${food.seasonRange}, Mevcut ay: ${currentMonth}, Dahil mi: ${isInSeason}`);
            return isInSeason;
        } catch (e) {
            console.error(`Yemeğin seasonRange parse edilemedi: ${food.name}, ${food.seasonRange}, tüm yıl kabul ediliyor`, e);
            return true;
        }
    }

    function addFixedBreakfastToWeek(week) {
        if (!week || !week.days) return;
        const coffee = categories.flatMap(cat => cat.items).find(f =>
            f.name === "Kurşun Geçirmez Kahve" ||
            (f.name.toLowerCase().includes("kurşun") && f.name.toLowerCase().includes("kahve"))
        ) || {
            name: "Kurşun Geçirmez Kahve",
            calories: 200,
            protein: 0,
            carbs: 0,
            fat: 22,
            role: "drink",
            keto: true,
            lowcarb: true,
            seasonRange: "[1,12]"
        };
        Object.values(week.days).forEach(day => {
            day.meals.breakfast = [{
                name: coffee.name,
                quantity: 1,
                role: coffee.role || "drink",
                unit: "fincan"
            }];
            console.log(`Kahvaltıya sabit eklendi: ${coffee.name} (Gün: ${day})`);
        });
    }

    const availableFoods = categories.flatMap(cat => cat.items)
        .filter(f => {
            const isValid = f.calories > 0 &&
                (dietMode === 'keto' ? f.keto : f.lowcarb) &&
                !settings.dislikedFoods.some(df =>
                    f.name.toLowerCase().includes(df.toLowerCase()) ||
                    f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))
                ) &&
                isFoodInSeason(f);
            return isValid;
        })
        .sort((a, b) => {
            const aLiked = settings.likedFoods.some(lf =>
                a.name.toLowerCase().includes(lf.toLowerCase()) ||
                a.tags.some(t => t.toLowerCase().includes(lf.toLowerCase()))
            );
            const bLiked = settings.likedFoods.some(lf =>
                b.name.toLowerCase().includes(lf.toLowerCase()) ||
                b.tags.some(t => t.toLowerCase().includes(lf.toLowerCase()))
            );
            return bLiked - aLiked;
        });

    console.log("availableFoods filtrelendi:", availableFoods.map(f => f.name));

    const validRules = rules.filter(rule => rule && typeof rule === 'object' && (
        rule.type === 'frequency' || rule.type === 'dependOn' || rule.type === 'maxRoleCount'
    ));
    const prioritizedRules = validRules;

    const targetCalories = settings.targetCalories;
    const targetProtein = settings.targetProtein;
    const targetFat = settings.targetFat;
    const targetCarbs = settings.targetCarbs;
    const macroTolerance = settings.macroTolerance || 0.1;

    if (!targetCalories || !targetProtein || !targetCarbs || !targetFat) {
        console.error("Makro hedefleri tanımlı değil!", settings);
        showNotification("Makro hedefleri eksik, planlama yapılamadı!", "warning");
        return;
    }

    const excludedBySeason = categories.flatMap(cat => cat.items)
        .filter(f => f.calories > 0 && !isFoodInSeason(f))
        .map(f => f.name);
    if (excludedBySeason.length > 0) {
        showNotification(`${excludedBySeason.length} yemek mevsim dışı olduğu için plana dahil edilmedi.`, "info");
    }

    weeks.forEach(week => addFixedBreakfastToWeek(week));

    const ruleAppliedFoods = new Set();

    prioritizedRules.forEach(rule => {
        if (rule.type === 'frequency') {
            let matchingFoods = [];
            if (rule.nameCheck && rule.names?.length) {
                matchingFoods = availableFoods.filter(food =>
                    rule.names.some(name => food.name.toLowerCase().includes(name.toLowerCase()))
                );
            } else if (rule.nameCheck && rule.name) {
                matchingFoods = availableFoods.filter(food => food.name.toLowerCase().includes(rule.name.toLowerCase()));
            } else {
                matchingFoods = availableFoods;
            }
            if (rule.tagsCheck && rule.tags?.length) {
                matchingFoods = matchingFoods.filter(food => rule.tags.some(tag => food.tags?.some(t => t.toLowerCase().includes(tag.toLowerCase()))));
            }
            if (rule.roleCheck && rule.role) matchingFoods = matchingFoods.filter(food => food.role === rule.role);
            if (rule.catCheck && rule.category) matchingFoods = matchingFoods.filter(food => categories.find(cat => cat.name === rule.category)?.items.some(item => item.name === food.name && item.calories > 0));
            if (matchingFoods.length === 0) {
                console.warn(`Kural (${rule.id}) için uygun yemek bulunamadı: ${JSON.stringify(rule)}`);
                return;
            }
            weeks.forEach((week, weekIndex) => {
                Object.values(week.days).forEach(day => {
                    if (rule.scope === 'meal' && rule.mealType && rule.mealType !== 'breakfast') {
                        const mealItems = day.meals[rule.mealType] = day.meals[rule.mealType] || [];
                        const count = mealItems.filter(item => matchingFoods.some(f => f.name === item.name)).length;
                        if (rule.frequencyType === 'min' && count < rule.frequency) {
                            let remaining = rule.frequency - count;
                            while (remaining > 0 && matchingFoods.length > 0) {
                                const food = matchingFoods[Math.floor(Math.random() * matchingFoods.length)];
                                if (!mealItems.some(item => item.name === food.name) && isMealTypeCompatible(food, rule.mealType)) {
                                    const quantity = calculateOptimalQuantity(food, {
                                        calories: targetCalories,
                                        protein: targetProtein,
                                        fat: targetFat,
                                        carbs: targetCarbs
                                    }, mealItems, rule.mealType, availableFoods);
                                    mealItems.push({ name: food.name, quantity });
                                    ruleAppliedFoods.add(food.name);
                                    remaining -= quantity;
                                } else {
                                    matchingFoods = matchingFoods.filter(f => f.name !== food.name);
                                }
                            }
                        } else if (rule.frequencyType === 'max' && count > rule.frequency) {
                            let excess = count - rule.frequency;
                            while (excess > 0) {
                                const index = mealItems.findIndex(item => matchingFoods.some(f => f.name === item.name));
                                if (index !== -1) {
                                    mealItems.splice(index, 1);
                                    excess--;
                                } else break;
                            }
                        } else if (rule.frequencyType === 'exact' && count !== rule.frequency) {
                            if (count < rule.frequency) {
                                let remaining = rule.frequency - count;
                                while (remaining > 0 && matchingFoods.length > 0) {
                                    const food = matchingFoods[Math.floor(Math.random() * matchingFoods.length)];
                                    if (!mealItems.some(item => item.name === food.name) && isMealTypeCompatible(food, rule.mealType)) {
                                        const quantity = calculateOptimalQuantity(food, {
                                            calories: targetCalories,
                                            protein: targetProtein,
                                            fat: targetFat,
                                            carbs: targetCarbs
                                        }, mealItems, rule.mealType, availableFoods);
                                        mealItems.push({ name: food.name, quantity });
                                        ruleAppliedFoods.add(food.name);
                                        remaining -= quantity;
                                    } else {
                                        matchingFoods = matchingFoods.filter(f => f.name !== food.name);
                                    }
                                }
                            } else if (count > rule.frequency) {
                                let excess = count - rule.frequency;
                                while (excess > 0) {
                                    const index = mealItems.findIndex(item => matchingFoods.some(f => f.name === item.name));
                                    if (index !== -1) {
                                        mealItems.splice(index, 1);
                                        excess--;
                                    } else break;
                                }
                            }
                        }
                    }
                });
            });
        } else if (rule.type === 'dependOn' && rule.food && rule.requiredFood) {
            weeks.forEach((week, weekIndex) => {
                Object.values(week.days).forEach(day => {
                    ['lunch', 'dinner'].forEach(mealType => {
                        let mealItems = day.meals[mealType] || [];
                        const hasRequired = mealItems.some(item => item.name.toLowerCase().includes(rule.requiredFood.toLowerCase()));
                        const hasFood = mealItems.some(item => item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        const dependentFood = availableFoods.find(f => f.name.toLowerCase().includes(rule.food.toLowerCase()));
                        if (hasFood && !hasRequired) {
                            day.meals[mealType] = mealItems.filter(item => !item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        } else if (!hasFood && hasRequired && dependentFood && Math.random() < 0.5 && isMealTypeCompatible(dependentFood, mealType)) {
                            const quantity = calculateOptimalQuantity(dependentFood, {
                                calories: targetCalories,
                                protein: targetProtein,
                                fat: targetFat,
                                carbs: targetCarbs
                            }, mealItems, mealType, availableFoods);
                            day.meals[mealType].push({ name: dependentFood.name, quantity });
                            ruleAppliedFoods.add(dependentFood.name);
                        }
                    });
                });
            });
        } else if (rule.type === 'maxRoleCount' && rule.mealType && rule.role && rule.count !== undefined) {
            weeks.forEach((week) => {
                Object.values(week.days).forEach(day => {
                    const mealType = Array.isArray(rule.mealType) ? rule.mealType : [rule.mealType];
                    mealType.forEach(mt => {
                        if (mt !== 'breakfast') {
                            const mealItems = day.meals[mt] || [];
                            const roleCount = mealItems.filter(item => {
                                const food = availableFoods.find(f => f.name === item.name);
                                return food && food.role === rule.role;
                            }).length;
                            if (roleCount > rule.count) {
                                let excess = roleCount - rule.count;
                                while (excess > 0) {
                                    const index = mealItems.findIndex(item => {
                                        const food = availableFoods.find(f => f.name === item.name);
                                        return food && food.role === rule.role;
                                    });
                                    if (index !== -1) {
                                        const removedItem = mealItems.splice(index, 1)[0];
                                        excess--;
                                        console.log(`maxRoleCount kuralı: ${rule.role} rolünden ${removedItem.name} kaldırıldı (${mt})`);
                                    } else break;
                                }
                                day.meals[mt] = mealItems;
                            }
                        }
                    });
                });
            });
        }
    });

    weeks.forEach((week, weekIndex) => {
        Object.entries(week.days).forEach(([day, dayData]) => {
            ['lunch', 'dinner'].forEach(mealType => {
                const mealRatio = mealType === 'lunch'
                    ? parseFloat(document.getElementById('lunchCalorieRatio')?.value || 40) / 100
                    : parseFloat(document.getElementById('dinnerCalorieRatio')?.value || 30) / 100;

                const mealTargets = {
                    calories: targetCalories * mealRatio,
                    protein: targetProtein * mealRatio,
                    fat: targetFat * mealRatio,
                    carbs: targetCarbs * mealRatio
                };

                let currentMeal = dayData.meals[mealType] || [];
                const mealFoods = availableFoods.filter(f => isMealTypeCompatible(f, mealType) &&
                    !settings.dislikedFoods.some(df => f.name.toLowerCase().includes(df.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))));
                const fillers = availableFoods.filter(f => (mealType === 'lunch' ? f.fillerLunch : f.fillerDinner) &&
                    isMealTypeCompatible(f, mealType) && !currentMeal.some(item => item.name === f.name) && isFoodInSeason(f));

                const min = mealType === 'lunch' ? settings.lunchMin : settings.dinnerMin;
                const max = mealType === 'lunch' ? settings.lunchMax : settings.dinnerMax;

                let currentCalories = currentMeal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.calories * item.quantity : 0);
                }, 0);
                let currentProtein = currentMeal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.protein * item.quantity : 0);
                }, 0);
                let currentFat = currentMeal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.fat * item.quantity : 0);
                }, 0);
                let currentCarbs = currentMeal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.carbs * item.quantity : 0);
                }, 0);

                while (currentMeal.length < max && mealFoods.length > 0) {
                    const bestFood = findBestFood(mealFoods, {
                        calories: mealTargets.calories - currentCalories,
                        protein: mealTargets.protein - currentProtein,
                        fat: mealTargets.fat - currentFat,
                        carbs: mealTargets.carbs - currentCarbs
                    }, currentMeal, mealType, prioritizedRules);
            
                    if (!bestFood) {
                        console.log(`Ana yemek ekleme (${mealType}): Uygun yemek bulunamadı.`);
                        break;
                    }
            
                    if (hasTagConflictWithMeal(bestFood, currentMeal)) {
                        console.log(`Etiket çakışması: ${bestFood.name} aynı tag'e sahip başka bir yemek zaten var.`);
                        mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                        continue;
                    }
            
                    if (checkBreadConstraint(bestFood)) {
                        mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                        continue;
                    }
            
                    if ((mealType === 'lunch' || mealType === 'dinner') && bestFood.role === 'mainDish') {
                        const mainDishCount = currentMeal.filter(item => {
                            const food = availableFoods.find(f => f.name === item.name);
                            return food && food.role === 'mainDish';
                        }).length;
                        if (mainDishCount >= 1) {
                            console.log(`Engellendi (${mealType}): ${bestFood.name} (mainDish, zaten bir mainDish var)`);
                            mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                            continue;
                        }
                    }
            
                    if ((mealType === 'lunch' || mealType === 'dinner') && checkKeywordConflict(bestFood.name, currentMeal, mealType)) {
                        console.log(`Engellendi (${mealType}): ${bestFood.name} (etiket çakışması)`);
                        mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                        continue;
                    }
            
                    const quantity = calculateOptimalQuantity(bestFood, {
                        calories: mealTargets.calories - currentCalories,
                        protein: mealTargets.protein - currentProtein,
                        fat: mealTargets.fat - currentFat,
                        carbs: mealTargets.carbs - currentCarbs
                    }, currentMeal, mealType, availableFoods);
            
                    const foodCalories = bestFood.calories * quantity;
                    const foodProtein = bestFood.protein * quantity;
                    const foodFat = bestFood.fat * quantity;
                    const foodCarbs = bestFood.carbs * quantity;
            
                    // --- UYUM KONTROLÜ ---
                    let isMagnet = false;
                    if (bestFood.compatibilityTags && bestFood.compatibilityTags.length > 0 && currentMeal.some(item => {
                        const f = availableFoods.find(ff => ff.name === item.name);
                        return f && f.compatibilityTags && f.compatibilityTags.some(tag => bestFood.compatibilityTags.includes(tag));
                    })) {
                        isMagnet = true;
                    }
            
                    if (currentCalories + foodCalories <= mealTargets.calories * (1 + macroTolerance)) {
                        let itemName = bestFood.name;
                        let itemObj = { name: itemName, quantity };
                        if (isMagnet) {
                            itemName += '✔️';
                            itemObj = { ...itemObj, magnet: true };
                        }
                        itemObj.name = itemName;
                        currentMeal.push(itemObj);
                        currentCalories += foodCalories;
                        currentProtein += foodProtein;
                        currentFat += foodFat;
                        currentCarbs += foodCarbs;
                        console.log(`Eklendi (${mealType}): ${itemName} (${quantity}x), Kalori: ${currentCalories}/${mealTargets.calories}, Protein: ${currentProtein}/${mealTargets.protein}, Yağ: ${currentFat}/${mealTargets.fat}`);
                    } else {
                        console.log(`Engellendi (${mealType}): ${bestFood.name} (kalori sınırı aşıldı)`);
                        break;
                    }
                }

                while ((currentProtein < mealTargets.protein * 0.95 || currentFat < mealTargets.fat * 0.95) && fillers.length > 0 && currentMeal.length < max) {
                    const bestFiller = findBestFood(fillers, {
                        calories: mealTargets.calories - currentCalories,
                        protein: mealTargets.protein - currentProtein,
                        fat: mealTargets.fat - currentFat,
                        carbs: mealTargets.carbs - currentCarbs
                    }, currentMeal, mealType, prioritizedRules);
                
                    if (!bestFiller) {
                        console.log(`Dolgu yemek ekleme (${mealType}): Uygun dolgu yemeği bulunamadı.`);
                        break;
                    }
                
                    // TAG ÇAKIŞMASI KONTROLÜ (filler için de)
                    if (hasTagConflictWithMeal(bestFiller, currentMeal)) {
                        console.log(`Etiket çakışması (filler): ${bestFiller.name} aynı tag'e sahip başka bir yemek zaten var.`);
                        fillers.splice(fillers.indexOf(bestFiller), 1);
                        continue;
                    }
                
                    if (isFoodNameUsedInDay(dayData.meals, bestFiller.name) && bestFiller.role !== 'bread') {
                        console.log(`Engellendi (${mealType}): ${bestFiller.name} (aynı gün içinde zaten var - filler)`);
                        fillers.splice(fillers.indexOf(bestFiller), 1);
                        continue;
                    }

                    if (checkBreadConstraint(bestFiller)) {
                        fillers.splice(fillers.indexOf(bestFiller), 1);
                        continue;
                    }

                    if ((mealType === 'lunch' || mealType === 'dinner') && bestFiller.role === 'mainDish') {
                        const mainDishCount = currentMeal.filter(item => {
                            const food = availableFoods.find(f => f.name === item.name);
                            return food && food.role === 'mainDish';
                        }).length;
                        if (mainDishCount >= 1) {
                            console.log(`Engellendi (${mealType}): ${bestFiller.name} (mainDish, zaten bir mainDish var)`);
                            fillers.splice(fillers.indexOf(bestFiller), 1);
                            continue;
                        }
                    }

                    if ((mealType === 'lunch' || mealType === 'dinner') && checkKeywordConflict(bestFiller.name, currentMeal, mealType)) {
                        console.log(`Engellendi (${mealType}): ${bestFiller.name} (etiket çakışması - dolgu yemeği)`);
                        fillers.splice(fillers.indexOf(bestFiller), 1);
                        continue;
                    }

                    const quantity = calculateOptimalQuantity(bestFiller, {
                        calories: mealTargets.calories - currentCalories,
                        protein: mealTargets.protein - currentProtein,
                        fat: mealTargets.fat - currentFat,
                        carbs: mealTargets.carbs - currentCarbs
                    }, currentMeal, mealType, availableFoods);

                    const foodCalories = bestFiller.calories * quantity;
                    const foodProtein = bestFiller.protein * quantity;
                    const foodFat = bestFiller.fat * quantity;
                    const foodCarbs = bestFiller.carbs * quantity;

                    if (currentCalories + foodCalories <= mealTargets.calories * (1 + macroTolerance)) {
                        // Filler olarak ekleniyorsa isme 🌸 ekle ve veri modelinde filler:true işaretle
                        let fillerName = bestFiller.name;
                        // Eğer uyumluluk nedeniyle de ekleniyorsa ✔️ de ekle (örnek mantık, uyumluluk kontrolü varsa ekle)
                        let isCompatible = false;
                        if (bestFiller.compatibilityTags && bestFiller.compatibilityTags.length > 0 && currentMeal.some(item => {
                            const f = availableFoods.find(ff => ff.name === item.name);
                            return f && f.compatibilityTags && f.compatibilityTags.some(tag => bestFiller.compatibilityTags.includes(tag));
                        })) {
                            isCompatible = true;
                        }
                        if (isCompatible) {
                            fillerName += '🌸✔️';
                        } else {
                            fillerName += '🌸';
                        }
                        currentMeal.push({ name: fillerName, quantity, magnet: true, filler: true });
                        currentCalories += foodCalories;
                        currentProtein += foodProtein;
                        currentFat += foodFat;
                        currentCarbs += foodCarbs;
                        console.log(`Filler eklendi (${mealType}): ${fillerName} (${quantity}x), Kalori: ${currentCalories}/${mealTargets.calories}, Protein: ${currentProtein}/${mealTargets.protein}, Yağ: ${currentFat}/${mealTargets.fat}`);
                        fillers.splice(fillers.indexOf(bestFiller), 1);
                    } else {
                        console.log(`Engellendi (${mealType}): ${bestFiller.name} (kalori sınırı aşıldı)`);
                        break;
                    }
                }

                dayData.meals[mealType] = currentMeal;
                console.log(`${mealType}: Protein: ${getCurrentMacro(currentMeal, 'protein', availableFoods)}/${mealTargets.protein}, Yağ: ${getCurrentMacro(currentMeal, 'fat', availableFoods)}/${mealTargets.fat}, Kalori: ${getCurrentMacro(currentMeal, 'calories', availableFoods)}/${mealTargets.calories}`);
            });
        });
    });

    renderMeals();
    calculateMacros();



    const appliedRules = [];
    const unappliedRules = [];

    prioritizedRules.forEach(rule => {
        let applied = false;
        let reason = '';
function moveSelectedFoods() {
            const selectedFoods = Array.from(document.querySelectorAll('#editCategories input[type="checkbox"]:checked')).map(input => input.value);
            const targetCategory = document.getElementById('editMoveToCategory').value;
            if (!targetCategory) {
                showNotification("Lütfen bir kategori seçin!", 'warning');
                return;
            }
            selectedFoods.forEach(foodName => {
                const food = availableFoods.find(f => f.name === foodName);
                if (food) {
                    food.category = targetCategory;
                    console.log(`Yemek taşındı: ${foodName} -> ${targetCategory}`);
                }
            });
            loadCategories();
            showNotification("Yemekler taşındı!");
        }

weeks.forEach(week => {
    Object.values(week.days).forEach(day => {
        ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
            const meal = day.meals[mealType] || [];
            // Sadece mainDish olanları bul
            const mainDishes = meal.filter(item => {
                const food = findFood(item.name);
                return food && food.role === 'mainDish';
            });
            // Eğer 1'den fazla varsa, sadece ilkini bırak, diğerlerini sil
            if (mainDishes.length > 1) {
                const firstMain = mainDishes[0].name;
                day.meals[mealType] = meal.filter(item => {
                    const food = findFood(item.name);
                    return !(food && food.role === 'mainDish' && item.name !== firstMain);
                });
            }
            // Eğer hiç yoksa, rastgele bir mainDish ekle
            if (mainDishes.length === 0) {
                // Uygun bir mainDish bul
                const candidates = categories.flatMap(cat => cat.items)
                    .filter(f => f.role === 'mainDish' && isMealTypeCompatible(f, mealType));
                if (candidates.length > 0) {
                    const randomMain = candidates[Math.floor(Math.random() * candidates.length)];
                    day.meals[mealType].push({ name: randomMain.name, quantity: 1 });
                }
            }
        });
    });
});
        const excludedBySeason = categories.flatMap(cat => cat.items)
    .filter(f => f.calories > 0 && !isFoodInSeason(f))
    .map(f => f.name);
if (excludedBySeason.length > 0) {
    showNotification(`${excludedBySeason.length} yemek mevsim dışı olduğu için plana dahil edilmedi.`, "info");
}
        weeks.forEach(week => {
            Object.values(week.days).forEach(day => {
                ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                    const mealItems = day.meals[mealType] || [];
                    if (rule.type === 'frequency') {
                        const targetName = rule.name || (rule.names?.length ? rule.names.join(', ') : 'yemek');
                        const countMatches = () => {
                            if (rule.roleCheck && rule.role) {
                                return mealItems.filter(item => {
                                    const food = availableFoods.find(f => f.name === item.name);
                                    return food && food.role === rule.role;
                                }).length;
                            } else if (rule.nameCheck && rule.names?.length) {
                                return mealItems.filter(item =>
                                    rule.names.some(name => item.name.toLowerCase().includes(name.toLowerCase()))
                                ).length;
                            } else if (rule.nameCheck && rule.name) {
                                return mealItems.filter(item => item.name.toLowerCase().includes(rule.name.toLowerCase())).length;
                            }
                            return 0;
                        };
                        if (rule.scope === 'meal' && rule.mealType === mealType) {
                            const count = countMatches();
                            if (rule.frequencyType === 'min' && count >= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'min') {
                                reason = `"${targetName}" en az ${rule.frequency} kez olmalı, ancak ${count} kez bulundu (öğün: ${mealType}).`;
                            }
                            if (rule.frequencyType === 'max' && count <= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'max') {
                                reason = `"${targetName}" maksimum ${rule.frequency} kez olmalı, ancak ${count} kez bulundu (öğün: ${mealType}).`;
                            }
                            if (rule.frequencyType === 'exact' && count === rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'exact') {
                                reason = `"${targetName}" tam ${rule.frequency} kez olmalı, ancak ${count} kez bulundu (öğün: ${mealType}).`;
                            }
                        } else if (rule.scope === 'day') {
                            let dailyCount = 0;
                            ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                                const mealItems = day.meals[mt] || [];
                                dailyCount += countMatches();
                            });
                            if (rule.frequencyType === 'min' && dailyCount >= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'min') {
                                reason = `"${targetName}" günde en az ${rule.frequency} kez olmalı, ancak ${dailyCount} kez bulundu.`;
                            }
                            if (rule.frequencyType === 'max' && dailyCount <= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'max') {
                                reason = `"${targetName}" günde maksimum ${rule.frequency} kez olmalı, ancak ${dailyCount} kez bulundu.`;
                            }
                            if (rule.frequencyType === 'exact' && dailyCount === rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'exact') {
                                reason = `"${targetName}" günde tam ${rule.frequency} kez olmalı, ancak ${dailyCount} kez bulundu.`;
                            }
                        } else if (rule.scope === 'week') {
                            let weeklyCount = 0;
                            Object.values(week.days).forEach(day => {
                                ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                                    const mealItems = day.meals[mt] || [];
                                    weeklyCount += countMatches();
                                });
                            });
                            if (rule.frequencyType === 'min' && weeklyCount >= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'min') {
                                reason = `"${targetName}" haftada en az ${rule.frequency} kez olmalı, ancak ${weeklyCount} kez bulundu.`;
                            }
                            if (rule.frequencyType === 'max' && weeklyCount <= rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'max') {
                                reason = `"${targetName}" haftada maksimum ${rule.frequency} kez olmalı, ancak ${weeklyCount} kez bulundu.`;
                            }
                            if (rule.frequencyType === 'exact' && weeklyCount === rule.frequency) {
                                applied = true;
                            } else if (rule.frequencyType === 'exact') {
                                reason = `"${targetName}" haftada tam ${rule.frequency} kez olmalı, ancak ${weeklyCount} kez bulundu.`;
                            }
                        }
                    } else if (rule.type === 'dependOn' && rule.food && rule.requiredFood) {
                        const hasFood = mealItems.some(item => item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        const hasRequired = mealItems.some(item => item.name.toLowerCase().includes(rule.requiredFood.toLowerCase()));
                        if (hasFood && hasRequired) {
                            applied = true;
                        } else if (!hasFood) {
                            applied = true;
                        } else {
                            reason = `"${rule.food}" mevcut, ancak bağımlı olduğu "${rule.requiredFood}" bulunamadı (öğün: ${mealType}).`;
                        }
                    } else if (rule.type === 'maxRoleCount' && rule.role && rule.count !== undefined) {
                        const applicableMealTypes = Array.isArray(rule.mealType) ? rule.mealType : [rule.mealType];
                        if (applicableMealTypes.includes(mealType)) {
                            const roleCount = mealItems.filter(item => {
                                const food = availableFoods.find(f => f.name === item.name);
                                return food && food.role === rule.role;
                            }).length;
                            if (roleCount <= rule.count) {
                                applied = true;
                            } else {
                                reason = `"${rule.role}" rolü için maksimum ${rule.count} yemek olmalı, ancak ${roleCount} yemek bulundu (öğün: ${mealType}).`;
                            }
                        } else {
                            applied = true;
                        }
                    }
                });
            });
        });

        if (applied) {
            appliedRules.push(`(${rule.id}) ${rule.type} (${rule.frequencyType || '-'})`);
        } else {
            unappliedRules.push({
                rule: `(${rule.id}) ${rule.type} (${rule.frequencyType || '-'})`,
                reason: reason || 'Uygun yemek bulunamadı veya kural kriterleri sağlanmadı.'
            });
            console.warn(`Kural uygulanmadı: ${JSON.stringify(rule)}, Neden: ${reason || 'Bilinmeyen neden'}`);
        }
    });

    const ruleTextElement = document.getElementById("ruleTextElement");
    if (ruleTextElement) {
        ruleTextElement.innerHTML = `
            <strong>Uygulanan kurallar:</strong> ${appliedRules.join(', ') || 'Yok'}<br>
            <strong>Uygulanmayan kurallar:</strong><br>
            ${unappliedRules.length > 0 ?
                unappliedRules.map(r => `${r.rule}: ${r.reason}`).join('<br>') :
                'Yok'}
        `;
    } else {
        console.warn("ruleTextElement bulunamadı.");
    }

    console.log("Bildirim: Uygulanan:", appliedRules, "Uygulanmayan:", unappliedRules);
    if (typeof showNotification === 'function') {
        const notificationMessage = `
            Planlama tamamlandı!\n
            Uygulanan Kurallar (${appliedRules.length}): ${appliedRules.join(', ') || 'Yok'}\n
            Uygulanmayan Kurallar (${unappliedRules.length}):\n
            ${unappliedRules.length > 0 ?
                unappliedRules.map(r => `${r.rule}: ${r.reason}`).join('\n') :
                'Yok'}
        `;
        showNotification(notificationMessage, 'success', 7000);
    }
}






function saveSettingsTemplate(isDefault = false) {
            const templateName = isDefault ? 'default' : (document.getElementById('settingsTemplate').value || currentPatient);
            if (!templateName) {
                showNotification("Şablon adı girin!", 'warning');
                return;
            }
            const settings = {
                minItemsPerMeal: document.getElementById('minItemsPerMeal').value,
                maxItemsPerMeal: document.getElementById('maxItemsPerMeal').value,
                lunchCalorieRatio: document.getElementById('lunchCalorieRatio').value,
                dinnerCalorieRatio: document.getElementById('dinnerCalorieRatio').value,
                calorieFlexibility: document.getElementById('calorieFlexibility').value,
                varietyScore: document.getElementById('varietyScore').value,
                carbMultiplier: document.getElementById('carbMultiplier').value,
                proteinMultiplier: document.getElementById('proteinMultiplier').value,
                fatMultiplier: document.getElementById('fatMultiplier').value,
                useName: document.getElementById('useName').checked,
                useTags: document.getElementById('useTags').checked,
                prefBreakfastDrink: document.getElementById('prefBreakfastDrink').checked,
                prefLunchEgg: document.getElementById('prefLunchEgg').checked,
                prefLunchSoup: document.getElementById('prefLunchSoup').checked,
                prefDinnerNuts: document.getElementById('prefDinnerNuts').value,
                prefDinnerSoup: document.getElementById('prefDinnerSoup').value,
                prefDinnerDessert: document.getElementById('prefDinnerDessert').value,
                prefDinnerFruit: document.getElementById('prefDinnerFruit').value,
                breakfastMin: document.getElementById('breakfastMin').value,
                breakfastMax: document.getElementById('breakfastMax').value,
                lunchMin: document.getElementById('lunchMin').value,
                lunchMax: document.getElementById('lunchMax').value,
                dinnerMin: document.getElementById('dinnerMin').value,
                dinnerMax: document.getElementById('dinnerMax').value
            };
            localStorage.setItem(`settingsTemplate_${templateName}`, JSON.stringify(settings));
            loadSettingsTemplates();
            showNotification(`Ayarlar ${isDefault ? 'varsayılan olarak' : 'hasta için'} kaydedildi!`);
        }

        function loadSettingsTemplates() {
            const templateSelect = document.getElementById('settingsTemplateSelect');
            const templates = Object.keys(localStorage).filter(key => key.startsWith('settingsTemplate_')).map(key => key.replace('settingsTemplate_', ''));
            templateSelect.innerHTML = '<option value="">Ayar Yükle</option>' + templates.map(t => `<option value="${t}">${t}</option>`).join('');
        }

        function loadSettingsTemplate() {
            const templateName = document.getElementById('settingsTemplateSelect').value;
            if (!templateName) return;
            const settings = JSON.parse(localStorage.getItem(`settingsTemplate_${templateName}`) || '{}');
            document.getElementById('minItemsPerMeal').value = settings.minItemsPerMeal || 2;
            document.getElementById('maxItemsPerMeal').value = settings.maxItemsPerMeal || 5;
            document.getElementById('lunchCalorieRatio').value = settings.lunchCalorieRatio || 40;
            document.getElementById('dinnerCalorieRatio').value = settings.dinnerCalorieRatio || 50;
            document.getElementById('calorieFlexibility').value = settings.calorieFlexibility || 10;
            document.getElementById('varietyScore').value = settings.varietyScore || 0.7;
            document.getElementById('carbMultiplier').value = settings.carbMultiplier || (dietMode === 'keto' ? 0.3 : 0.6);
            document.getElementById('proteinMultiplier').value = settings.proteinMultiplier || 0.8;
            document.getElementById('fatMultiplier').value = settings.fatMultiplier || (dietMode === 'keto' ? 1.2 : 1.0);
            document.getElementById('useName').checked = settings.useName !== false;
            document.getElementById('useTags').checked = settings.useTags !== false;
            document.getElementById('prefBreakfastDrink').checked = settings.prefBreakfastDrink !== false;
            document.getElementById('prefLunchEgg').checked = settings.prefLunchEgg !== false;
            document.getElementById('prefLunchSoup').checked = settings.prefLunchSoup !== false;
            document.getElementById('prefDinnerNuts').value = settings.prefDinnerNuts || 50;
            document.getElementById('prefDinnerSoup').value = settings.prefDinnerSoup || 50;
            document.getElementById('prefDinnerDessert').value = settings.prefDinnerDessert || 50;
            document.getElementById('prefDinnerFruit').value = settings.prefDinnerFruit || 50;
            document.getElementById('breakfastMin').value = settings.breakfastMin || 1;
            document.getElementById('breakfastMax').value = settings.breakfastMax || 1;
            document.getElementById('lunchMin').value = settings.lunchMin || 2;
            document.getElementById('lunchMax').value = settings.lunchMax || 5;
            document.getElementById('dinnerMin').value = settings.dinnerMin || 2;
            document.getElementById('dinnerMax').value = settings.dinnerMax || 5;
            calculateMacros();
            showNotification("Ayarlar yüklendi!");
        }

        function applySettings() {
            calculateMacros();
            generateAutoPlan();
            showNotification("Ayarlar uygulandı ve plan güncellendi!");
        }

        function searchEditFood(query) {
        console.log(`Yemek aranıyor: ${query}`);
    console.log("searchEditFood çalışıyor, query:", query);
    const filterType = document.getElementById('editSearchFilterType').value;
    const editCategoriesDiv = document.getElementById('editCategories');
    editCategoriesDiv.innerHTML = `
    <div class="accordion" id="mainCategoriesAccordion">
        <div class="accordion-item">
            <h2 class="accordion-header" id="mainCategoriesHeading" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1rem;">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#mainCategoriesCollapse" aria-expanded="false" aria-controls="mainCategoriesCollapse" style="margin: 0; padding: 0.25rem 0.5rem;">
                    Kategoriler
                </button>
                <div class="d-flex align-items-center">
                    <select id="editMoveToCategory" class="form-select d-inline w-auto" style="font-size: 0.85rem; margin-right: 0.5rem;">
                        <option value="">Kategori Seç</option>
                        ${categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('')}
                    </select>
                    <button class="btn btn-primary d-inline" onclick="moveSelectedFoods()" style="font-size: 0.85rem; padding: 0.3rem 0.6rem;">Taşı</button>
                </div>
            </h2>
            <div id="mainCategoriesCollapse" class="accordion-collapse collapse" aria-labelledby="mainCategoriesHeading" data-bs-parent="#mainCategoriesAccordion">
                <div class="accordion-body" style="max-height: 400px; overflow-y: auto;">
                    ${categories.map((category, catIndex) => {
                        const filteredItems = category.items.filter(item => {
                            if (filterType === 'name') return item.name.toLowerCase().includes(query.toLowerCase());
                            if (filterType === 'tags') return item.tags && item.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));
                            if (filterType === 'role') return item.role && item.role.toLowerCase().includes(query.toLowerCase());
                            return true;
                        });
                        return `
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="editHeading${catIndex}">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#editCollapse${catIndex}" aria-expanded="false" aria-controls="editCollapse${catIndex}">
                                        <input type="checkbox" class="category-checkbox" data-category-index="${catIndex}"> ${category.name} (${filteredItems.length})
                                    </button>
                                </h2>
                                <div id="editCollapse${catIndex}" class="accordion-collapse collapse" aria-labelledby="editHeading${catIndex}">
                                    <div class="accordion-body">
                                        ${filteredItems.map((item, itemIndex) => `
                                            <div class="category-item d-flex justify-content-between">
                                                <div>
                                                    <input type="checkbox" class="food-checkbox" data-category="${category.name}" data-food="${item.name}">
                                                    <span>${item.name} (${item.calories || 0} kcal)</span>
                                                </div>
                                                <div>
                                                    <button class="btn btn-danger btn-sm me-1" onclick="deleteFood('${item.name}', '${category.name}')" title="Sil"><i class="bi bi-trash"></i></button>
                                                    <button class="btn btn-warning btn-sm" onclick="editFood('${item.name}')" title="Düzenle"><i class="bi bi-pencil"></i></button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        </div>
    </div>
    `;
    console.log("editCategories güncellendi, editMoveToCategory mevcut mu?:", document.getElementById('editMoveToCategory'));
}
function deleteFood(foodName, categoryName) {
    if (confirm(`${foodName} yemeğini silmek istediğinize emin misiniz?`)) {
        saveState(); // Silmeden önce durumu kaydet
        const normalizedCategoryName = categoryName.trim().toLowerCase();
        const category = categories.find(cat => cat.name.trim().toLowerCase() === normalizedCategoryName);
        if (category) {
            // Yemek adını normalleştir ve esnek bir eşleştirme yap
            const normalizedFoodName = foodName.trim().toLowerCase().replace(/[()]/g, ''); // Parantezleri kaldır
            const foodIndex = category.items.findIndex(item => {
                const itemName = item.name.trim().toLowerCase().replace(/[()]/g, '');
                return itemName.includes(normalizedFoodName) || normalizedFoodName.includes(itemName);
            });
            if (foodIndex !== -1) {
                category.items.splice(foodIndex, 1);
                showNotification(`${foodName} yemeği silindi!`);
                loadCategories();
                searchEditFood(''); // Sağ paneli yenile
            } else {
                console.error(`Yemek bulunamadı: ${foodName} in ${categoryName}`);
            }
        } else {
            console.error(`Kategori bulunamadı: ${categoryName}`);
        }
    }
}

function moveSelectedFoods(attempts = 5) {
    let categoryElement = document.getElementById("editMoveToCategory");
    if (!categoryElement) {
        if (attempts > 0) {
            console.log("editMoveToCategory elementi henüz yüklenmedi! 1 saniye bekleniyor... Kalan deneme: " + attempts);
            setTimeout(() => moveSelectedFoods(attempts - 1), 1000); // 1 saniye sonra tekrar dene
        } else {
            console.error("editMoveToCategory bulunamadı, işlem iptal edildi!");
            showNotification("Kategori seçme öğesi yüklenemedi!", "danger");
        }
        return;
    }
    let targetCategory = categoryElement.value;
    if (!targetCategory) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }

    const selectedFoods = document.querySelectorAll(".food-checkbox:checked");
    if (selectedFoods.length === 0) {
        showNotification("Taşınacak yemek seçilmedi!", "warning");
        return;
    }

    selectedFoods.forEach(checkbox => {
        const foodName = checkbox.dataset.food;
        const oldCategoryName = checkbox.dataset.category;
        const oldCategory = categories.find(cat => cat.name === oldCategoryName);
        const foodIndex = oldCategory.items.findIndex(item => item.name === foodName);
        const food = oldCategory.items.splice(foodIndex, 1)[0];
        const newCategory = categories.find(cat => cat.name === targetCategory);
        newCategory.items.push(food);
    });

    showNotification(`${selectedFoods.length} yemek "${targetCategory}" kategorisine taşındı!`);
    loadCategories();
    searchEditFood('');
}

function deleteSelectedCategory() {
    const selectedCheckbox = document.querySelector('#editCategories .category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    if (confirm(`${categories[index].name} kategorisini silmek istediğinize emin misiniz?`)) {
        categories.splice(index, 1);
        searchEditFood(''); // Sağ paneli yenile
        loadCategories(); // Sol paneli de yenile
        showNotification("Kategori silindi!");
    }
}

function checkForDuplicateFoods(foodName, excludeCategory) {
    const duplicates = [];
    if (!Array.isArray(categories)) {
        console.error("categories bir dizi değil:", categories);
        return duplicates;
    }
    categories.forEach(cat => {
        if (cat.name !== excludeCategory) {
            cat.items.forEach(item => {
                if (item.name === foodName) {
                    duplicates.push({ name: item.name, category: cat.name });
                }
            });
        }
    });
    return duplicates;
}

function editFood(foodName) {
    const normalizedName = foodName.replace(/\s*\(\d+\s*kcal\)/i, '').trim();
    console.log(`editFood çağrıldı, orijinal isim: ${foodName}, normalleştirilmiş isim: ${normalizedName}`);

    const food = findFood(normalizedName);
    if (!food) {
        console.error(`Yemek bulunamadı: ${normalizedName}`);
        console.log(`categories dizisi:`, JSON.stringify(categories, null, 2));
        showNotification(`Yemek bulunamadı: ${normalizedName}`, "warning");
        return;
    }

    const panel = document.getElementById('editFoodPanel');
    if (!panel) {
        console.error("editFoodPanel elemanı bulunamadı!");
        showNotification("Düzenleme paneli bulunamadı!", "warning");
        return;
    }

    document.getElementById('editFoodIndex').value = '';
    document.getElementById('editFoodOriginalName').value = normalizedName;
    document.getElementById('editFoodName').value = food.name || '';
    document.getElementById('editFoodCalories').value = food.calories || 0;
    document.getElementById('editFoodProtein').value = food.protein || 0;
    document.getElementById('editFoodCarbs').value = food.carbs || 0;
    document.getElementById('editFoodFat').value = food.fat || 0;
    document.getElementById('editFoodMaxQuantity').value = food.maxQuantity || 1;
    document.getElementById('editFoodMinQuantity').value = food.minQuantity || 0.5;
    document.getElementById('editFoodStep').value = food.step || 0.5;
    document.getElementById('editFoodRole').value = food.role || 'mainDish';
    document.getElementById('editFoodTags').value = food.tags && Array.isArray(food.tags) ? food.tags.join(', ') : '';
    document.getElementById('editFoodCompatibilityTags').value =
        food.compatibilityTags && Array.isArray(food.compatibilityTags) ?
        food.compatibilityTags.join(', ') : '';
    document.getElementById('editFoodKeto').checked = !!food.keto;
    document.getElementById('editFoodLowCarb').checked = !!food.lowcarb;
    document.getElementById('editFoodFillerLunch').checked = !!food.fillerLunch;
    document.getElementById('editFoodFillerDinner').checked = !!food.fillerDinner;
    document.getElementById('editFoodPortionFixed').checked = !!food.portionFixed;
    document.getElementById('editFoodMultiplier').value = food.multiplier || 1;

    const seasonFromInput = document.getElementById('editFoodSeasonFrom');
    const seasonToInput = document.getElementById('editFoodSeasonTo');
    let seasonRange = [1, 12];

    const savedSeasonRange = loadSeasonInfoFromLocalStorage(normalizedName);
    if (savedSeasonRange) {
        try {
            seasonRange = JSON.parse(savedSeasonRange);
            console.log(`localStorage'dan seasonRange yüklendi: ${savedSeasonRange}`);
        } catch (e) {
            console.error("localStorage'dan mevsim aralığı parse edilemedi:", savedSeasonRange);
        }
    } else if (food.seasonRange) {
        try {
            seasonRange = JSON.parse(food.seasonRange);
            console.log(`food.seasonRange'den yüklendi: ${food.seasonRange}`);
        } catch (e) {
            console.error("food.seasonRange parse edilemedi:", food.seasonRange);
        }
    } else if (food.season) {
        seasonRange = convertSeasonToRange(food.season);
        console.log(`food.season'dan çevrildi: ${food.season} -> ${seasonRange}`);
    } else {
        console.warn(`Yemek için sezon bilgisi bulunamadı: ${normalizedName}, varsayılan [1,12] kullanılıyor`);
    }

    if (seasonFromInput && seasonToInput) {
        seasonFromInput.value = seasonRange[0];
        seasonToInput.value = seasonRange[1];
        console.log(`Sezon aralığı input'lara ayarlandı: [${seasonRange[0]}, ${seasonRange[1]}]`);
    } else {
        console.error("editFoodSeasonFrom veya editFoodSeasonTo bulunamadı!");
    }

    const startSlider = document.getElementById('editStartMonthSlider');
    const endSlider = document.getElementById('editEndMonthSlider');
    if (startSlider && endSlider) {
        if (!startSlider.noUiSlider || !endSlider.noUiSlider) {
            initializeMonthSliders(
                'editStartMonthSlider',
                'editEndMonthSlider',
                'editFoodSeasonRange',
                'editStartMonthDisplay',
                'editEndMonthDisplay'
            );
        }
        try {
            startSlider.noUiSlider.set(seasonRange[0]);
            endSlider.noUiSlider.set(seasonRange[1]);
            console.log(`Slider'lar ayarlandı: [${seasonRange[0]}, ${seasonRange[1]}]`);
        } catch (e) {
            console.error("Slider değerleri ayarlanamadı:", seasonRange);
            startSlider.noUiSlider.set(1);
            endSlider.noUiSlider.set(12);
        }
    } else {
        console.error("editStartMonthSlider veya editEndMonthSlider bulunamadı!");
    }

    syncMealTypeCheckboxesFromString(food.mealType);

    const categorySelect = document.getElementById('editFoodMoveToCategory');
    if (!categorySelect) {
        console.error("editFoodMoveToCategory elemanı bulunamadı!");
        showNotification("Kategori seçimi elemanı bulunamadı!", "warning");
        return;
    }

    categorySelect.innerHTML = '<option value="">Kategori Seç</option>' +
        categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');

    if (food.category) {
        categorySelect.value = food.category;
        console.log(`Yemek: ${normalizedName}, Mevcut Kategori: ${food.category}, Seçilen Değer: ${categorySelect.value}`);
        if (categorySelect.value !== food.category) {
            console.warn(`Kategori eşleşmedi! Mevcut: ${food.category}, Seçilen: ${categorySelect.value}`);
        }
    } else {
        categorySelect.value = '';
        console.warn(`Yemek için kategori tanımlı değil: ${normalizedName}`);
    }

    updateCaloriesLive();

    panel.style.display = 'block';
}


// Mevsim bilgisini metin formatından aralığa çevirme
function convertSeasonToRange(season) {
    switch (season.toLowerCase()) {
        case 'ilkbahar':
            return [3, 5];
        case 'yaz':
            return [6, 8];
        case 'sonbahar':
            return [9, 11];
        case 'kış':
            return [12, 2];
        case '4 mevsim':
        default:
            return [1, 12];
    }
}

document.addEventListener('DOMContentLoaded', () => {
  const resizer = document.getElementById('resizer');
  const sidebar = document.getElementById('sidebar');
  let isResizing = false;

  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'ew-resize'; // Sürüklerken imleç değişir
  });

  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    const newWidth = e.clientX;
    const minWidth = 100; // Daha esnek minimum
    const maxWidth = window.innerWidth * 0.5; // Ekranın yarısına kadar

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      sidebar.style.width = `${newWidth}px`;
    }
  });

  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = 'default'; // İmleci normale döndür
    }
  });
});
        



document.addEventListener('DOMContentLoaded', () => {
  const resizer = document.getElementById('resizer');
  const sidebar = document.getElementById('sidebar');
  let isResizing = false;

  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'ew-resize';
  });

  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    const newWidth = e.clientX;
    const minWidth = 100;
    const maxWidth = window.innerWidth * 0.5;

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      sidebar.style.width = `${newWidth}px`;
    }
  });

  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = 'default';
    }
  });
});



        function loadCategoryOptions() {
    let categorySelect = document.getElementById("editMoveToCategory");
    if (!categorySelect) {
        console.log("editMoveToCategory bulunamadı!");
        return;
    }
    console.log("Kategoriler:", categories); // categories dizisini kontrol et
    categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
    categories.forEach(category => {
        let option = document.createElement("option");
        option.value = category.name;
        option.textContent = category.name;
        categorySelect.appendChild(option);
    });
    categorySelect.onchange = function() {
        console.log("Seçilen kategori: " + categorySelect.value);
    };
}

// Yemek düzenleme paneli açıldığında kategori listesini güncelle
document.getElementById("editFoodPanel").addEventListener("click", loadCategoryOptions);



// Popup kapatma fonksiyonu
function closeEditFoodPanel() {
    const panel = document.getElementById('editFoodPanel');
    if (panel) {
        panel.style.display = 'none';
    }
    // Sol ve sağ panelleri güncelle
    loadCategories();
    searchEditFood('');
}


// Kategori taşıma fonksiyonu
function moveFoodCategory() {
    const categoryElement = document.getElementById("editFoodMoveToCategory");
    if (!categoryElement) {
        showNotification("Kategori seçme öğesi bulunamadı!", "warning");
        return;
    }
    const selectedValue = categoryElement.value.trim();
    if (!selectedValue) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const foodName = document.getElementById("editFoodOriginalName").value;
    const oldCategory = categories.find(cat => cat.items.some(item => item.name === foodName));
    if (!oldCategory) {
        showNotification("Eski kategori bulunamadı!", "warning");
        return;
    }
    const foodIndex = oldCategory.items.findIndex(item => item.name === foodName);
    if (foodIndex === -1) {
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }
    const food = oldCategory.items.splice(foodIndex, 1)[0];
    const newCategory = categories.find(cat => cat.name === selectedValue);
    if (!newCategory) {
        showNotification("Yeni kategori bulunamadı!", "warning");
        return;
    }
    newCategory.items.push(food);
    showNotification(`"${foodName}" yemeği "${selectedValue}" kategorisine taşındı!`);
    loadCategories();
    searchEditFood('');
    categoryElement.value = selectedValue; // Yeni kategori seçili kalır
}


ddocument.addEventListener('DOMContentLoaded', async () => {
    saveState(); // İlk durumu kaydet
    initializeWeeks();
    
    // GitHub'dan veri yüklenmesini bekle
    await updateGitHubData();
    
    // Veriler yüklendikten sonra kategorileri ve diğer bileşenleri yükle
    loadCategories();
    renderWeekTabs();
    renderDayTabs();
    renderMeals();
    loadPatientSelect();
    loadRules();
    loadMealTemplates();
    loadCompatibilityRules();
    loadSettingsTemplates();
    loadRuleTemplates();
    calculateMacros();
    searchEditFood('');
    document.getElementById("editFoodPanel").addEventListener("click", function(event) {
        if (event.target.tagName !== "SELECT") {
            loadCategoryOptions();
        }
    });
});
    </script>
<script>
        // Mevcut öğünü şablonlara ekleyen fonksiyon
function addCurrentMealToTemplates(mealType) {
    console.log(`${mealType} öğünü şablonlara eklendi.`);
    const selectedMeals = weeks[selectedWeek - 1].days[selectedDay].meals[mealType];
    if (!selectedMeals || selectedMeals.length === 0) {
        showNotification("Bu öğünde yemek bulunmuyor!", "warning");
        return;
    }

    const templateName = prompt("Şablon için bir ad girin:", `${mealType} şablonu`);
    if (!templateName) return;

    const items = selectedMeals.map(meal => ({
        keyword: meal.name,
        role: meal.role || "mainDish",
        quantity: meal.quantity || 1
    }));

    mealTemplates.push({
        mealType,
        frequency: 1,
        items,
        name: templateName
    });

    loadMealTemplates();
    showNotification("Öğün şablonlara eklendi!", "success");
    console.log(`Mevcut öğün (${mealType}) şablonlara eklendi:`, items);
}

// Sayfa yüklendiğinde "Şablona Ekle" butonlarını dinamik olarak ekler
document.addEventListener("DOMContentLoaded", function() {
    setTimeout(() => {
        document.querySelectorAll(".meal-card .card-header").forEach(header => {
            const title = header.childNodes[0].textContent.trim().toLowerCase();
            const mealType = title.includes("öğle") ? "lunch" : title.includes("akşam") ? "dinner" : null;

            // Sadece öğle ve akşam için buton ekle
            if (mealType) {
                // Eğer buton zaten varsa tekrar ekleme
                if (header.querySelector(".template-add-btn")) return;

                const addButton = document.createElement("button");
                addButton.className = "btn btn-sm btn-success template-add-btn mt-1";
                addButton.innerHTML = "Şablona Ekle";
                addButton.onclick = () => addCurrentMealToTemplates(mealType);
                header.appendChild(addButton);
            }
        });
    }, 1000); // Sayfa yüklendikten 1 saniye sonra butonları ekler
});
        </script>
<script>
    function formatQuantityWithText(text) {
    // Sayısal kısmı ayıkla ve yuvarla
    const match = text.match(/^(\d*\.?\d*)\s*(.*)$/);
    if (match) {
        let quantity = parseFloat(match[1]);
        const unit = match[2].trim().toLowerCase();

        // Yuvarlama uygula
        quantity = roundQuantity(quantity);

        // Tanımlı ölçü birimleri için formatlama
        if (['dilim', 'kase', 'bardak', 'yemek', 'porsiyon', 'adet', 'tatlı kaşığı', 'çorba kaşığı', 'tabak', 'fincan', 'yaprak', 'yemek kaşığı', 'gram', 'kare'].includes(unit)) {
            if (quantity === 0.5) return `yarım ${unit}`;
            if (quantity === 0.25) return `çeyrek ${unit}`;
            return `${quantity} ${unit}`;
        }
    }

    return text; // Eğer format uygun değilse orijinali dön
}

    function updateQuantities() {
        const quantityCells = document.querySelectorAll('.quantity-cell'); // Miktar hücrelerinin sınıfı
        quantityCells.forEach(cell => {
            const text = cell.innerText.trim();
            const formattedText = formatQuantityWithText(text);
            if (formattedText !== text) {
                cell.innerText = formattedText;
            }
        });
    }

    document.addEventListener('DOMContentLoaded', updateQuantities);

    document.getElementById('freqCatCheck').addEventListener('change', function() {
    const freqCat = document.getElementById('freqCat');
    freqCat.disabled = !this.checked;
    if (this.checked && freqCat.options.length <= 1) { // Eğer boşsa
        populateCategoryDropdown(); // Tekrar doldur
    }
    console.log("freqCatCheck değişti, freqCat içeriği:", freqCat.innerHTML);
});
</script>
<script>
    function convertMeasurements(text) {
        // "0.5 yemek kaşığı" veya "yarım yemek kaşığı" -> "1 tatlı kaşığı"
        text = text.replace(/\b0\.5\s*yemek kaşığı\b/gi, "1 tatlı kaşığı");
        text = text.replace(/\byarım yemek kaşığı\b/gi, "1 tatlı kaşığı");
        
        // "2 tatlı kaşığı" -> "1 yemek kaşığı"
        text = text.replace(/\b2\s*tatlı kaşığı\b/gi, "1 yemek kaşığı");
        
        // "0.25 yemek kaşığı" -> "çeyrek yemek kaşığı"
        text = text.replace(/\b0\.25\s*yemek kaşığı\b/gi, "çeyrek yemek kaşığı");
        
        return text;
    }

    function applyConversions() {
        const rows = document.querySelectorAll('#mealTable td');
        rows.forEach(cell => {
            const originalText = cell.innerText.trim();
            const convertedText = convertMeasurements(originalText);

            if (originalText !== convertedText) {
                cell.innerText = convertedText;
            }
        });
    }
    function updateSidebar() {
    const sidebarContent = document.getElementById('categories');
    if (!sidebarContent) {
        console.error("categories elementi bulunamadı!");
        return;
    }
    sidebarContent.innerHTML = '';
    categories.forEach((category, index) => {
        // Kalori değeri 0 olmayan yemekleri filtrele
        const validItems = category.items.filter(hasValidCalories);
        const itemCount = validItems.length;
        const accordionItem = `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                        ${category.name} (${itemCount})
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                    <div class="accordion-body">
                        ${validItems.map(food => `
                            <div class="category-item">
                                <span>${food.name} (${food.calories} kcal)</span>
                                <div class="food-checkboxes">
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="breakfast" title="Sabah"> S
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="lunch" title="Öğle"> Ö
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="dinner" title="Akşam"> A
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        sidebarContent.innerHTML += accordionItem;
    });
    console.log("Sidebar güncellendi, kalori 0 olanlar hariç!");
}

    document.addEventListener('DOMContentLoaded', applyConversions);

    async function handleUserFormSubmit(event) {
    event.preventDefault(); // Sayfanın yenilenmesini engeller
    const name = document.getElementById('userName').value;
    const weight = document.getElementById('userWeight').value;
    const activity = document.getElementById('userActivity').value;
    const likedFoods = document.getElementById('likedFoodsInput').value.split(',').map(f => f.trim()).filter(f => f);
    const dislikedFoods = document.getElementById('dislikedFoodsInput').value.split(',').map(f => f.trim()).filter(f => f);

    const patientData = {
        name,
        weight: parseFloat(weight) || 70,
        activity: parseInt(activity) || 3,
        likedFoods,
        dislikedFoods
    };

    // localStorage'a kaydet
    localStorage.setItem(`patient_${name}`, JSON.stringify(patientData));
    currentPatient = name;

    // Hasta seçimini güncelle
    loadPatientSelect();
    document.getElementById('patientSelect').value = name;
    handlePatientChange();

    // GitHub'a güncelle
    await updateGitHubData();

    showNotification("Kullanıcı profili kaydedildi!", "success");
}
async function updateGitHubData() {
    console.log("updateGitHubData başladı!");
    const token = document.getElementById('githubToken').value;
    if (!token) {
        showNotification("Lütfen geçerli bir GitHub token girin!", "warning");
        console.log("Token yok!");
        return;
    }

    if (!(await testGitHubToken(token))) {
        showNotification("Geçersiz GitHub token!", "warning");
        console.log("Token geçersiz!");
        return;
    }

    const repoOwner = "mustafasacar35";
    const repoName = "beslenme";
    const filePath = "sistem_JSON.json";
    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}`;

    const data = {
        categories: categories || [],
        weeks: weeks || [],
        rules: rules || [],
        mealTemplates: mealTemplates || [],
        compatibilityTable: compatibilityTable || [],
        patients: Object.keys(localStorage)
            .filter(key => key.startsWith('patient_'))
            .reduce((obj, key) => {
                obj[key] = JSON.parse(localStorage.getItem(key));
                return obj;
            }, {})
    };

    console.log("GitHub'a gönderilen categories (detaylı):", JSON.stringify(categories, null, 2)); // DETAYLI LOG

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));

    try {
        console.log("Dosya alınmaya çalışılıyor...");
        const response = await fetch(apiUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });

        if (!response.ok) {
            const errorData = await response.json();
            showNotification("Dosya alınamadı: " + errorData.message, "warning");
            console.log("Dosya alınamadı:", errorData.message);
            return;
        }

        const fileData = await response.json();
        const sha = fileData.sha;
        console.log("SHA alındı:", sha);

        console.log("Dosya güncellenmeye çalışılıyor...");
        const updateResponse = await fetch(apiUrl, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                message: "Hasta verileri ve diğer veriler güncellendi",
                content: content,
                sha: sha,
                branch: "main"
            })
        });

        if (updateResponse.ok) {
            showNotification("Veriler GitHub'a başarıyla yüklendi!", "success");
            console.log("Yükleme başarılı!");
        } else {
            const errorData = await updateResponse.json();
            showNotification("GitHub'a yükleme başarısız: " + errorData.message, "warning");
            console.log("Yükleme başarısız:", errorData.message);
        }
    } catch (error) {
        showNotification("Bir hata oluştu: " + error.message, "warning");
        console.error("Hata:", error);
    }
}



document.addEventListener('DOMContentLoaded', () => {
    const savedToken = localStorage.getItem('githubToken');
    if (savedToken) {
        document.getElementById('githubToken').value = savedToken;
    }
});

document.getElementById('githubToken').addEventListener('blur', () => {
    const token = document.getElementById('githubToken').value;
    if (token) {
        localStorage.setItem('githubToken', token);
    }
});


// Global değişkenler
let history = [];
let historyIndex = -1; // Başlangıçta -1, hiçbir durum yok
const maxHistorySize = 10;

// Durumu kaydetme fonksiyonu
function saveState() {
    console.log("Durum kaydediliyor...");
    const currentState = {
        weeks: JSON.parse(JSON.stringify(weeks)),
        categories: JSON.parse(JSON.stringify(categories)),
        rules: JSON.parse(JSON.stringify(rules)),
        mealTemplates: JSON.parse(JSON.stringify(mealTemplates)),
        compatibilityTable: JSON.parse(JSON.stringify(compatibilityTable)),
        food_list: JSON.parse(localStorage.getItem("food_list")) || {},
        selectedDay: selectedDay
    };
if (currentPatient) {
        window[`weeks_patient_${currentPatient}`] = JSON.parse(JSON.stringify(weeks));
    }
    // Eğer mevcut indeksten sonra yeni bir işlem yapılıyorsa, eski ileri işlemleri sil
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }

    history.push(currentState);
    historyIndex++;

    // Geçmiş boyutunu sınırlama
    if (history.length > maxHistorySize) {
        history.shift();
        historyIndex--;
    }

    console.log("Durum kaydedildi, historyIndex:", historyIndex, "history.length:", history.length);
    updateUndoRedoButtons();
}

// Durumu geri alma
function undo() {
    if (historyIndex > 0) { // İlk durumdan önceki bir duruma gidilebilir
        historyIndex--;
        applyState(history[historyIndex]);
        updateUndoRedoButtons();
        if (typeof showNotification === 'function') {
            showNotification("İşlem geri alındı!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("Geri alınacak işlem yok!", "warning");
        }
    }
}

// Durumu ileri alma
function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        applyState(history[historyIndex]);
        updateUndoRedoButtons();
        if (typeof showNotification === 'function') {
            showNotification("İşlem ileri alındı!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("İleri alınacak işlem yok!", "warning");
        }
    }
}

// Durumu uygulama
function applyState(state) {
    weeks = JSON.parse(JSON.stringify(state.weeks));
    categories = JSON.parse(JSON.stringify(state.categories));
    rules = JSON.parse(JSON.stringify(state.rules));
    mealTemplates = JSON.parse(JSON.stringify(state.mealTemplates));
    compatibilityTable = JSON.parse(JSON.stringify(state.compatibilityTable));
    selectedDay = state.selectedDay;
    localStorage.setItem("food_list", JSON.stringify(state.food_list));
    loadCategories();
    renderMeals();
    searchEditFood('');
    calculateMacros();
    console.log("Durum uygulandı, historyIndex:", historyIndex);
}

// Butonların durumunu güncelleme
function updateUndoRedoButtons() {
    const undoButton = document.getElementById("undoButton");
    const redoButton = document.getElementById("redoButton");
    
    if (undoButton) {
        undoButton.disabled = historyIndex < 0; // historyIndex -1 olduğunda pasif
        console.log("Undo butonu durumu:", undoButton.disabled ? "pasif" : "aktif");
    } else {
        console.error("undoButton bulunamadı!");
    }
    
    if (redoButton) {
        redoButton.disabled = historyIndex >= history.length - 1; // İleri durum yoksa pasif
        console.log("Redo butonu durumu:", redoButton.disabled ? "pasif" : "aktif");
    } else {
        console.error("redoButton bulunamadı!");
    }
}


</script>
<!-- Günlük ve Haftalık için Popup -->
<div class="macro-modal" id="macroModal">
<div class="macro-modal-content">
<span class="macro-modal-close">×</span>
<div class="macro-modal-body">
<div class="macro-modal-chart">
<h3 id="macroModalTitle"></h3>
<canvas height="300" id="macroModalChart" width="300"></canvas>
</div>
<div class="macro-modal-analysis" id="macroModalAnalysis"></div>
</div>
</div>
</div>
<script>
// Genel dosya yükleme fonksiyonu (Excel ve TXT desteği)
function importFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileExtension = file.name.split('.').pop().toLowerCase();
    console.log("Yüklenen dosya:", file.name, "Uzantı:", fileExtension);

    const reader = new FileReader();
    reader.onload = function(e) {
        const data = fileExtension === 'txt' ? e.target.result : new Uint8Array(e.target.result);
        processFileData(data, fileExtension);
    };

    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        reader.readAsArrayBuffer(file);
    } else if (fileExtension === 'txt') {
        reader.readAsText(file);
    } else {
        showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
    }
}

// Dosya verisini işleyen ana fonksiyon
function processFileData(data, fileExtension) {
    let currentMealType = null;
    let currentItems = [];
    let mealIndex = { lunch: 1, dinner: 1 };
    const existingTemplates = new Set(); // Tam şablon içeriğiyle tekrar kontrolü
    const newFoods = [];

    const filterPatterns = [
        /^\*/i,
        /^-/,
        /^\d+\.\s*hafta/i,
        /gün/i,
        /^\s*$/,
        /pazartesi|salı|çarşamba|perşembe|cuma|cumartesi|pazar/i,
        /önerilir/i,
        /^\d+$/ // Yalnızca sayı içeren satırları filtrele (örneğin "1048")
    ];

    if (fileExtension === 'txt') {
        const lines = data.split('\n');
        lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (!trimmedLine || filterPatterns.some(p => p.test(trimmedLine.toLowerCase()))) return;

            // Kesin öğün başlıkları ile eşleştirme
            if (trimmedLine.match(/^lunch\s*\(1x\):/i) || trimmedLine.match(/^öğle\s*\(tercihen/i)) {
                if (currentItems.length > 0 && currentMealType) {
                    saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
                }
                currentMealType = "lunch";
                currentItems = [];
                const mealContent = trimmedLine.replace(/^lunch\s*\(1x\):/i, "").replace(/^öğle\s*\(tercihen[^\)]+\):?/i, "").trim();
                if (mealContent) {
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)$/);
                        const name = nameMatch ? nameMatch[1].trim() : item.trim();
                        const roleMatch = item.match(/\(([^)]+)\)$/);
                        const role = roleMatch ? roleMatch[1] : determineRole(name);
                        if (name && !filterPatterns.some(p => p.test(name))) {
                            currentItems.push({ name, role, calories: 0, carbs: 0, protein: 0, fat: 0 });
                        }
                    });
                }
                console.log("TXT: Öğle öğünü tespit edildi:", currentItems);
                return;
            }

            if (trimmedLine.match(/^dinner\s*\(1x\):/i) || trimmedLine.match(/^akşam\s*\(tercihen/i)) {
                if (currentItems.length > 0 && currentMealType) {
                    saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
                }
                currentMealType = "dinner";
                currentItems = [];
                const mealContent = trimmedLine.replace(/^dinner\s*\(1x\):/i, "").replace(/^akşam\s*\(tercihen[^\)]+\):?/i, "").trim();
                if (mealContent) {
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)$/);
                        const name = nameMatch ? nameMatch[1].trim() : item.trim();
                        const roleMatch = item.match(/\(([^)]+)\)$/);
                        const role = roleMatch ? roleMatch[1] : determineRole(name);
                        if (name && !filterPatterns.some(p => p.test(name))) {
                            currentItems.push({ name, role, calories: 0, carbs: 0, protein: 0, fat: 0 });
                        }
                    });
                }
                console.log("TXT: Akşam öğünü tespit edildi:", currentItems);
                return;
            }

            // Eğer bir öğün içindeysek ve satır bir öğün başlığı değilse, öğeyi ekle
            if (currentMealType) {
                const parts = trimmedLine.split('\t');
                const name = parts[0].trim();
                const calories = parseFloat(parts[1]) || 0;
                const carbs = parseFloat(parts[2]) || 0;
                const protein = parseFloat(parts[3]) || 0;
                const fat = parseFloat(parts[4]) || 0;
                // Yalnızca geçerli bir isim ve en az bir makro besin değeri varsa ekle
                if (name && !filterPatterns.some(p => p.test(name)) && (calories > 0 || carbs > 0 || protein > 0 || fat > 0)) {
                    currentItems.push({ name, role: determineRole(name), calories, carbs, protein, fat });
                    console.log("TXT: Öğe eklendi:", { name, calories, carbs, protein, fat });
                }
            }
        });

        // Son öğünü kaydet
        if (currentItems.length > 0 && currentMealType) {
            saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
        }
    }

    integrateNewFoods(newFoods);
    loadMealTemplates();
    loadCategories();
    showNotification(`Dosyadan ${mealIndex.lunch + mealIndex.dinner - 2} şablon ve ${newFoods.length} yeni yemek eklendi!`, "success");
}

// Şablon kaydetme fonksiyonu
function saveImportedTemplate(mealType, items, existingTemplates, mealIndex, newFoods) {
    // Şablonun tam içeriğini sıralı bir şekilde birleştirerek eşsiz bir anahtar oluştur
    const templateKey = `${mealType}|${items.map(i => `${i.name}|${i.role}`).sort().join('|')}`;
    if (existingTemplates.has(templateKey)) {
        console.log("Bu öğün zaten eklendi, tekrar eklenmedi:", templateKey);
        return;
    }
    existingTemplates.add(templateKey);

    const templateItems = items.map(item => {
        const matched = findFood(name);
        if (!matched) {
            const newFood = {
                name: item.name,
                calories: item.calories || 0,
                protein: item.protein || 0,
                carbs: item.carbs || 0,
                fat: item.fat || 0,
                category: "Yeni Eklenenler",
                mealType: [mealType],
                tags: determineTags(item.name),
                role: item.role || determineRole(item.name),
                keto: true,
                lowcarb: true,
                fillerLunch: mealType === "lunch",
                fillerDinner: mealType === "dinner",
                step: 0.5,
                maxQuantity: 1,
                minQuantity: 0.5
            };
            newFoods.push(newFood);
            return {
                keyword: item.name,
                quantity: 1,
                role: newFood.role,
                macros: {
                    calories: newFood.calories,
                    protein: newFood.protein,
                    carbs: newFood.carbs,
                    fat: newFood.fat
                }
            };
        }
        return {
            keyword: item.name,
            quantity: 1,
            role: matched.role || item.role || "mainDish",
            macros: {
                calories: item.calories || 0,
                protein: item.protein || 0,
                carbs: item.carbs || 0,
                fat: item.fat || 0
            }
        };
    });

    const newTemplate = {
        mealType,
        frequency: 1,
        items: templateItems,
        name: (mealType === "lunch" ? "ÖĞLEN " : "AKŞAM ") + mealIndex[mealType]++
    };
    mealTemplates.push(newTemplate);
    console.log("Yeni şablon eklendi:", newTemplate);
}

// Yeni yemekleri entegre etme
function integrateNewFoods(foods) {
    foods.forEach(food => {
        let category = categories.find(cat => cat.name === food.category);
        if (!category) {
            category = { name: food.category, items: [] };
            categories.push(category);
            console.log(`Yeni kategori oluşturuldu: ${food.category}`);
        }
        if (!category.items.some(item => item.name.toLowerCase() === food.name.toLowerCase())) {
            category.items.push(food);
            console.log(`Yeni yemek eklendi: ${food.name}`);
        }
    });
}


function determineRole(foodName) {
    const mainKeywords = ['yumurta', 'köfte', 'tavuk', 'balık', 'kıyma', 'kavurma', 'menemen', 'omlet', 'pirzola', 'et', 'sote'];
    const sideKeywords = ['salata', 'zeytin', 'peynir', 'karnabahar', 'kabak', 'patlıcan', 'mantarlı', 'sebzeli', 'mevsim', 'roka', 'marul'];
    const snackKeywords = ['badem', 'fındık', 'ceviz', 'çekirdeği', 'avokado', 'çikolata'];
    const supplementKeywords = ['kollajen', 'zeytinyağı', 'tereyağı', 'tahin'];
    const drinkKeywords = ['kahve', 'smoothie'];

    const nameLower = foodName.toLowerCase();
    if (mainKeywords.some(k => nameLower.includes(k))) return 'mainDish';
    if (sideKeywords.some(k => nameLower.includes(k))) return 'sideDish';
    if (snackKeywords.some(k => nameLower.includes(k))) return 'snack';
    if (drinkKeywords.some(k => nameLower.includes(k))) return 'drink';
    if (supplementKeywords.some(k => nameLower.includes(k))) return 'supplement';
    return 'sideDish';
}

function determineTags(foodName) {
    const keywords = {
        "yumurta": "yumurta", "köfte": "et", "tavuk": "tavuk", "balık": "balık", "zeytin": "zeytin",
        "peynir": "peynir", "karnabahar": "karnabahar", "kabak": "kabak", "patlıcan": "patlıcan",
        "mantarlı": "mantar", "sebzeli": "sebze", "roka": "roka", "marul": "marul", "badem": "badem",
        "fındık": "fındık", "ceviz": "ceviz", "çekirdeği": "çekirdek", "avokado": "avokado",
        "kahve": "kahve", "smoothie": "smoothie", "kollajen": "kollajen", "zeytinyağı": "zeytinyağı",
        "tereyağı": "tereyağı", "tahin": "tahin", "çikolata": "çikolata"
    };
    let tags = ["keto"];
    for (const [key, tag] of Object.entries(keywords)) {
        if (foodName.toLowerCase().includes(key)) {
            tags.push(tag);
        }
    }
    return tags;
}

// HTML için dosya girişi
document.querySelector('input[type="file"]').addEventListener('change', importFromFile);
</script>
<script>
function deleteFoodFromCategory(foodName, category) {
    if (confirm(`"${foodName}" yemeğini kategoriden silmek istiyor musunuz?`)) {
        let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
        if (storedFoodList[category]) {
            storedFoodList[category] = storedFoodList[category].filter(f => f.name !== foodName);
            localStorage.setItem("food_list", JSON.stringify(storedFoodList));
            alert(`"${foodName}" silindi.`);
            renderCategories(); // kategorileri yeniden çiz
        }
    }
}
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('undoButton').addEventListener('click', undo);
    document.getElementById('redoButton').addEventListener('click', redo);
});
</script>
<script>
// Sayfa yüklendiğinde bağlan
document.addEventListener("DOMContentLoaded", () => {
    const ids = ["editCarbs", "editProtein", "editFat"];
    ids.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesInPopup);
        }
    });
});

function updateCaloriesInPopup() {
    const carbs = parseFloat(document.getElementById("editCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}
</script>
<script>
function initializeEditFoodPanel() {
    ["editFoodCarbs", "editFoodProtein", "editFoodFat"].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesLive);
        }
    });
    updateCaloriesLive();
}

function updateCaloriesLive() {
    const carbs = parseFloat(document.getElementById("editFoodCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editFoodProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFoodFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editFoodCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}

document.addEventListener("DOMContentLoaded", () => {
    const panel = document.getElementById("editFoodPanel");
    if (panel) {
        panel.addEventListener("click", function(event) {
            if (event.target.tagName !== "SELECT") {
                loadCategoryOptions();
            }
        });
    } else {
        console.error("editFoodPanel bulunamadı!");
    }
});
</script>
<script>
document.addEventListener("DOMContentLoaded", function () {
    const resizer = document.getElementById("resizer");
    const sidebar = document.getElementById("sidebar");
    const mainContent = document.getElementById("mainContent");

    let isResizing = false;

    resizer.addEventListener("mousedown", function (e) {
        isResizing = true;
        document.body.style.cursor = "ew-resize";
    });

    document.addEventListener("mousemove", function (e) {
        if (!isResizing) return;

        const newWidth = e.clientX;
        if (newWidth > 150 && newWidth < window.innerWidth - 150) {
            sidebar.style.width = newWidth + "px";
            mainContent.style.flex = "1";
        }
    });

    document.addEventListener("mouseup", function () {
        isResizing = false;
        document.body.style.cursor = "default";
    });
});
</script>
<div class="modal" id="addFoodModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: flex-start;">
<div class="edit-food-panel" style="display: block; background-color: var(--white); padding: 20px; border-radius: 10px; width: 1000px; min-width: 1000px; max-height: 85vh; overflow-y: auto; box-shadow: var(--shadow-lg); margin-top: 40px; cursor: move; position: relative;">
<div id="modalHeader" style="padding: 10px; font-weight: bold; background: #f2f2f2; border-bottom: 1px solid #ccc;">Yeni Yemek Ekle (Sürüklemek için burayı tut)</div>
<h5>Yeni Yemek Ekle</h5>
<span class="modal-close" onclick="closeAddFoodModal()">×</span>
<div class="mb-2" id="addFoodForm">
<form id="addFoodFormInner" onsubmit="addNewFood(event)">
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodRole">Rol</label></div>
<div class="col-9">
<select class="form-select" id="foodRole" required="">
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="drink">İçecek</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodCategory">Kategori</label></div>
<div class="col-9">
<select class="form-select" id="foodCategory" required="">
<option value="">Kategori Seçin</option>
</select>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodName">Yemek Adı</label></div>
<div class="col-9">
<div style="position: relative;">
<input autocomplete="off" class="form-control" id="foodName" placeholder="Yemek Adı" required="" type="text"/>
<div id="nameWarning" style="color: red; font-size: 0.9em; display: none; margin-top: 4px;">Bu isimde bir yemek zaten var.</div>
<div id="nameSuggestions" style="position: absolute; background: white; border: 1px solid #ccc; max-height: 150px; overflow-y: auto; width: 100%; z-index: 9999; display: none;"></div>
</div>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label">Öğün Türü</label></div>
<div class="col-9">
<div class="form-check form-check-inline">
<input class="form-check-input" id="mealType_breakfast" name="mealType" type="checkbox" value="breakfast"/>
<label class="form-check-label" for="mealType_breakfast">Kahvaltı</label>
</div>
<div class="form-check form-check-inline">
<input class="form-check-input" id="mealType_lunch" name="mealType" type="checkbox" value="lunch"/>
<label class="form-check-label" for="mealType_lunch">Öğle</label>
</div>
<div class="form-check form-check-inline">
<input class="form-check-input" id="mealType_dinner" name="mealType" type="checkbox" value="dinner"/>
<label class="form-check-label" for="mealType_dinner">Akşam</label>
</div>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodCalories">Kalori</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodCalories" min="0" placeholder="Kalori" readonly="true" required="" step="0.1" style="background-color: #f3f3f3;" type="number"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodProtein">Protein (g)</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodProtein" min="0" placeholder="Protein (g)" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodCarbs">Karb. (g)</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodCarbs" min="0" placeholder="Karbonhidrat (g)" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodFat">Yağ (g)</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodFat" min="0" placeholder="Yağ (g)" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodMaxQuantity">Maks. Katsayı</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodMaxQuantity" max="2" min="1" placeholder="Maks. Katsayı" step="0.5" type="number" value="1"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodMinQuantity">Min. Katsayı</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodMinQuantity" max="2" min="0" placeholder="Min. Katsayı" step="0.5" type="number" value="0.5"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodStep">Adım Değeri</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodStep" max="1" min="0.1" placeholder="Adım (örn: 0.5)" step="0.1" type="number" value="0.5"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodTags">Etiketler</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodTags" placeholder="Etiketler (virgülle ayırın)" type="text"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3">
<label class="form-label" for="editFoodSeasonFrom">Mevsim Aralığı</label>
</div>
<div class="col-9">
<div class="d-flex align-items-center">
<input class="form-control form-control-sm" id="editFoodSeasonFrom" max="12" min="1" placeholder="Ay" style="width: 80px;" type="number"/>
<span class="mx-2">-</span>
<input class="form-control form-control-sm" id="editFoodSeasonTo" max="12" min="1" placeholder="Ay" style="width: 80px;" type="number"/>
<span class="ms-2" id="editFoodSeasonLabel">(Ocak → Aralık)</span>
</div>
<small class="form-text text-muted">Boş bırakırsanız tüm yıl kullanılabilir olacaktır.</small>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodCompatibilityTags">Uyumluluk Etiketleri</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodCompatibilityTags" placeholder="Virgülle ayırın (örn: domates, peynir, zeytin)" type="text"/>
<small class="form-text text-muted">Bu etiketler sadece yemeklerin uyumluluğunu kontrol etmek için kullanılır</small>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodPortionFixed">Porsiyon Sabit mi?</label></div>
<div class="col-9">
<input id="foodPortionFixed" name="foodPortionFixed" type="checkbox"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label" for="foodMultiplier">Çarpan</label></div>
<div class="col-9">
<input autocomplete="off" class="form-control" id="foodMultiplier" min="0.1" placeholder="Çarpan (örn: 1)" step="0.1" type="number" value="1"/>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label">Diyet Türü</label></div>
<div class="col-9">
<div class="form-check form-check-inline">
<input id="foodKeto" name="foodKeto" type="checkbox"/>
<label for="foodKeto">Keto</label>
</div>
<div class="form-check form-check-inline">
<input id="foodLowCarb" name="foodLowCarb" type="checkbox"/>
<label for="foodLowCarb">Low-Carb</label>
</div>
</div>
</div>
<div class="row mb-2">
<div class="col-3"><label class="form-label">Dolgu Türü</label></div>
<div class="col-9">
<div class="form-check form-check-inline">
<input id="foodFillerLunch" name="foodFillerLunch" type="checkbox"/>
<label for="foodFillerLunch">Dolgu Öğlen</label>
</div>
<div class="form-check form-check-inline">
<input id="foodFillerDinner" name="foodFillerDinner" type="checkbox"/>
<label for="foodFillerDinner">Dolgu Akşam</label>
</div>
</div>
</div>
<div class="row mt-3">
<div class="col-6">
<button class="btn btn-success w-100" title="Yemeği Ekle" type="submit">Kaydet</button>
</div>
<div class="col-6">
<button class="btn btn-secondary w-100 mt-1" onclick="closeAddFoodModal()" title="İptal Et" type="button">İptal</button>
</div>
</div>
</form>
</div>
</div>
</div>
<script>
function openAddFoodModal() {
    console.log("Modal açılıyor...");
    const modal = document.getElementById("addFoodModal");
    const form = document.getElementById("addFoodFormInner");
    const foodNameInput = document.getElementById("foodName");
    const warningBox = document.getElementById("nameWarning");
    const suggestionBox = document.getElementById("nameSuggestions");
    const seasonRangeInput = document.getElementById("foodSeasonRange");

    // Modal'ı görünür yap
    if (modal) {
        modal.style.display = "flex";
    } else {
        console.error("addFoodModal bulunamadı!");
        return;
    }

    // Formu sıfırla
    if (form) {
        form.reset();
        foodNameInput.value = "";
        document.getElementById("foodMaxQuantity").value = 1;
        document.getElementById("foodMinQuantity").value = 0.5;
        document.getElementById("foodStep").value = 0.5;
        if (seasonRangeInput) {
            seasonRangeInput.value = "[4,9]";
        }
    } else {
        console.error("addFoodFormInner bulunamadı!");
    }

    // Uyarı ve önerileri temizle
    if (warningBox) warningBox.style.display = "none";
    if (suggestionBox) {
        suggestionBox.style.display = "none";
        suggestionBox.innerHTML = "";
    }

    // Kategori dropdown'unu yeniden yükle
    populateCategoryDropdown();

    // Çift slider'ı başlat
    const startSlider = document.getElementById('foodStartMonthSlider');
    const endSlider = document.getElementById('foodEndMonthSlider');
    if (startSlider && endSlider && !startSlider.noUiSlider && !endSlider.noUiSlider) {
        initializeMonthSliders(
            'foodStartMonthSlider',
            'foodEndMonthSlider',
            'foodSeasonRange',
            'foodStartMonthDisplay',
            'foodEndMonthDisplay'
        );
    }

    // Kalori hesaplamasını başlat
    calculateCalories();

    // Form elemanlarını başlat
    initializeEditFoodPanel();
}

function initializeMonthSliders(startSliderId, endSliderId, rangeInputId, startDisplayId, endDisplayId) {
    const startSlider = document.getElementById(startSliderId);
    const endSlider = document.getElementById(endSliderId);
    const seasonFromInput = document.getElementById('editFoodSeasonFrom');
    const seasonToInput = document.getElementById('editFoodSeasonTo');
    const startDisplay = document.getElementById(startDisplayId);
    const endDisplay = document.getElementById(endDisplayId);

    if (!startSlider || !endSlider || !seasonFromInput || !seasonToInput || !startDisplay || !endDisplay) {
        console.error("Slider veya input elemanları bulunamadı:", { startSliderId, endSliderId, startDisplayId, endDisplayId });
        return;
    }

    // Ay isimleri
    const months = [
        "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran",
        "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"
    ];

    // Başlangıç slider'ı
    if (!startSlider.noUiSlider) {
        noUiSlider.create(startSlider, {
            start: parseInt(seasonFromInput.value) || 1, // Varsayılan: Ocak
            range: {
                'min': 1,
                'max': 12
            },
            step: 1,
            tooltips: { to: value => months[Math.round(value) - 1] },
            format: {
                to: value => Math.round(value),
                from: value => Number(value)
            }
        });
    }

    // Bitiş slider'ı
    if (!endSlider.noUiSlider) {
        noUiSlider.create(endSlider, {
            start: parseInt(seasonToInput.value) || 12, // Varsayılan: Aralık
            range: {
                'min': 1,
                'max': 12
            },
            step: 1,
            tooltips: { to: value => months[Math.round(value) - 1] },
            format: {
                to: value => Math.round(value),
                from: value => Number(value)
            }
        });
    }

    // Slider'lar değiştiğinde input'ları güncelle
    function updateInputs() {
        const start = startSlider.noUiSlider.get();
        const end = endSlider.noUiSlider.get();
        seasonFromInput.value = start;
        seasonToInput.value = end;
        startDisplay.textContent = months[start - 1];
        endDisplay.textContent = months[end - 1];
    }

    startSlider.noUiSlider.on("update", updateInputs);
    endSlider.noUiSlider.on("update", updateInputs);

    // Varsayılan değerleri ayarla
    const initialStart = parseInt(seasonFromInput.value) || 1;
    const initialEnd = parseInt(seasonToInput.value) || 12;
    startSlider.noUiSlider.set(initialStart);
    endSlider.noUiSlider.set(initialEnd);
    startDisplay.textContent = months[initialStart - 1];
    endDisplay.textContent = months[initialEnd - 1];
}

function closeAddFoodModal() {
    console.log("Modal kapatılıyor...");
    const modal = document.getElementById("addFoodModal");
    const form = document.getElementById("addFoodFormInner");
    const warningBox = document.getElementById("nameWarning");
    const suggestionBox = document.getElementById("nameSuggestions");

    console.log("Form durumu:", form);

    // Modal'ı gizle
    if (modal) {
        modal.style.display = "none";
    } else {
        console.error("addFoodModal bulunamadı!");
    }

    // Formu sıfırla
    if (form) {
        form.reset();
        document.getElementById("foodMaxQuantity").value = 1; // Varsayılan değeri geri yükle
        document.getElementById("foodMinQuantity").value = 0.5; // Varsayılan değeri geri yükle
        document.getElementById("foodStep").value = 0.5; // Varsayılan değeri geri yükle
    } else {
        console.error("addFoodFormInner bulunamadı!");
    }

    // Uyarı ve önerileri temizle
    if (warningBox) warningBox.style.display = "none";
    if (suggestionBox) {
        suggestionBox.style.display = "none";
        suggestionBox.innerHTML = "";
    }
}

</script><script>
function calculateCalories() {
    const carbs = parseFloat(document.getElementById("foodCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("foodProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("foodFat")?.value) || 0;
    const calories = (carbs * 4) + (protein * 4) + (fat * 9);
    document.getElementById("foodCalories").value = Math.round(calories);
}

// Event listener'ları bağla
["foodCarbs", "foodProtein", "foodFat"].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
        el.addEventListener("input", calculateCalories);
    }
});
</script><script>
const foodNameInput = document.getElementById("foodName");
const suggestionsBox = document.getElementById("nameSuggestions");

function getExistingFoodNames() {
    try {
        const foodList = JSON.parse(localStorage.getItem("food_list") || "{}");
        let names = [];
        for (const cat in foodList) {
            foodList[cat].forEach(item => {
                if (item.name) names.push(item.name);
            });
        }
        return [...new Set(names)];
    } catch (e) {
        return [];
    }
}

function filterSuggestions(query) {
    const keywords = query.toLowerCase().split(" ").filter(k => k.length > 0);
    return getExistingFoodNames().filter(name => {
        const lowerName = name.toLowerCase();
        return keywords.every(k => lowerName.includes(k));
    });
}

foodNameInput.addEventListener("input", function() {
    const query = this.value;
    if (!query || query.length < 2) {
        suggestionsBox.style.display = "none";
        return;
    }

    const matches = filterSuggestions(query);
    suggestionsBox.innerHTML = "";
    if (matches.length === 0) {
        suggestionsBox.style.display = "none";
        return;
    }

    matches.slice(0, 10).forEach(match => {
        const item = document.createElement("div");
        item.textContent = match;
        item.style.padding = "6px 10px";
        item.style.cursor = "pointer";
        item.style.borderBottom = "1px solid #eee";
        item.addEventListener("click", () => {
            foodNameInput.value = match;
            suggestionsBox.style.display = "none";
        });
        suggestionsBox.appendChild(item);
    });

    suggestionsBox.style.display = "block";
});

document.addEventListener("click", function(e) {
    if (!suggestionsBox.contains(e.target) && e.target !== foodNameInput) {
        suggestionsBox.style.display = "none";
    }
});
</script><script>
window.addEventListener("DOMContentLoaded", function () {
  const foodNameInput = document.getElementById("foodName");
  const suggestionBox = document.getElementById("nameSuggestions");
  if (!foodNameInput || !suggestionBox) return;

  function getAllFoodNamesFromCategories() {
    if (typeof categories === 'undefined') return [];
    let names = [];
    categories.forEach(cat => {
      if (cat.items && Array.isArray(cat.items)) {
        cat.items.forEach(item => {
          if (item.name) names.push(item.name);
        });
      }
    });
    return [...new Set(names)];
  }

  function filterSuggestions(query) {
    const keywords = query.toLowerCase().split(" ").filter(k => k.length > 0);
    return getAllFoodNamesFromCategories().filter(name => {
      const lowerName = name.toLowerCase();
      return keywords.every(k => lowerName.includes(k));
    });
  }

  foodNameInput.addEventListener("input", function () {
    const query = this.value;
    if (!query || query.length < 2) {
      suggestionBox.style.display = "none";
      return;
    }

    const matches = filterSuggestions(query);
    suggestionBox.innerHTML = "";
    if (matches.length === 0) {
      suggestionBox.style.display = "none";
      return;
    }

    matches.slice(0, 10).forEach(match => {
      const item = document.createElement("div");
      item.textContent = match;
      item.style.padding = "6px 10px";
      item.style.cursor = "pointer";
      item.style.borderBottom = "1px solid #eee";
      item.addEventListener("click", () => {
        foodNameInput.value = match;
        suggestionBox.style.display = "none";
      });
      suggestionBox.appendChild(item);
    });

    suggestionBox.style.display = "block";
  });

  document.addEventListener("click", function (e) {
    if (!suggestionBox.contains(e.target) && e.target !== foodNameInput) {
      suggestionBox.style.display = "none";
    }
  });
});
</script><script>
window.addEventListener("DOMContentLoaded", function () {
  const foodNameInput = document.getElementById("foodName");
  const warningBox = document.getElementById("nameWarning");
  const submitBtn = document.querySelector("button[type='submit']");

  function getAllFoodNames() {
    if (typeof categories === 'undefined') return [];
    let names = [];
    categories.forEach(cat => {
      if (cat.items && Array.isArray(cat.items)) {
        cat.items.forEach(item => {
          if (item.name) names.push(item.name.toLowerCase());
        });
      }
    });
    return [...new Set(names)];
  }

  foodNameInput.addEventListener("blur", function () {
    const name = this.value.trim().toLowerCase();
    const existing = getAllFoodNames();
    if (existing.includes(name)) {
      warningBox.style.display = "block";
      if (submitBtn) submitBtn.disabled = true;
    } else {
      warningBox.style.display = "none";
      if (submitBtn) submitBtn.disabled = false;
    }
  });

  foodNameInput.addEventListener("input", function () {
    warningBox.style.display = "none";
    if (submitBtn) submitBtn.disabled = false;
  });
});
</script><script>
window.addEventListener("DOMContentLoaded", function () {
  const modal = document.querySelector("#addFoodModal .edit-food-panel");
  const header = document.getElementById("modalHeader");

  let offsetX = 0, offsetY = 0, isDragging = false;

  if (header) {
    header.onmousedown = function (e) {
      isDragging = true;
      offsetX = e.clientX - modal.getBoundingClientRect().left;
      offsetY = e.clientY - modal.getBoundingClientRect().top;
      document.onmousemove = function (e) {
        if (!isDragging) return;
        modal.style.position = "absolute";
        modal.style.margin = "0";
        modal.style.top = (e.clientY - offsetY) + "px";
        modal.style.left = (e.clientX - offsetX) + "px";
      };
      document.onmouseup = function () {
        isDragging = false;
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
  }
});
</script><script>
function syncMealTypeCheckboxesFromString(mealTypeString, prefix = 'editMealType') {
    // Önce tüm checkbox'ları sıfırla
    ['breakfast', 'lunch', 'dinner'].forEach(type => {
        const checkbox = document.getElementById(`${prefix}_${type}`);
        if (checkbox) checkbox.checked = false;
    });

    // mealTypeString varsa, ilgili checkbox'ları işaretle
    if (mealTypeString) {
        let mealTypes = [];
        if (Array.isArray(mealTypeString)) {
            mealTypes = mealTypeString.map(m => m.trim().toLowerCase());
        } else {
            mealTypes = mealTypeString.split(',').map(m => m.trim().toLowerCase());
        }
        mealTypes.forEach(type => {
            const checkbox = document.getElementById(`${prefix}_${type}`);
            if (checkbox) checkbox.checked = true;
        });
    }
}


// Örnek: düzenleme modali açıldığında çalışmalı
// Bu fonksiyon senin mevcut editFood fonksiyonunun sonunda çağrılabilir
// Örneğin:
// syncMealTypeCheckboxesFromString(editedFood.mealType);
</script>
<script>
async function loadMealTagsFromGitHub() {
  const url = 'https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/sistem_JSON.json';
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error('GitHub JSON yüklenemedi.');
    const json = await response.json();

    const map = {};
    for (const category of json.categories || []) {
      for (const item of category.items || []) {
        if (item.name && item.tags) {
          map[item.name] = item.tags;
        }
      }
    }

    window.dynamicMealTagMap = map;
    console.log('Etiket haritası yüklendi:', Object.keys(map).length, 'yemek');
  } catch (err) {
    console.error('Etiket haritası yükleme hatası:', err);
  }
}

document.addEventListener("DOMContentLoaded", () => {
  loadMealTagsFromGitHub();
});

const mealTagsMap = window.dynamicMealTagMap || {};

function normalize(text) {
  return text
    .toLowerCase()
    .replace(/[0-9]+ ?(gram|adet|dilim|kaşık|tatlı|yemek|fincan|çorba|bardak)?/g, '')
    .replace(/[^a-zçğıöşü]+/g, '')
    .trim();
}

function getTagsForFoodName(name) {
  const norm = normalize(name);
  for (const key in mealTagsMap) {
    if (normalize(key) === norm) return mealTagsMap[key];
  }
  return name.toLowerCase().split(/[^a-zçğıöşü]+/).filter(Boolean);
}

function hasTagConflictFromNames(name1, name2) {
  const excludedConflictTags = ['keto', 'lowcarb', 'zeytinyağı'];
  const tags1 = getTagsForFoodName(name1);
  const tags2 = getTagsForFoodName(name2);
  const sharedTags = tags1.filter(tag => tags2.includes(tag));
  const conflictTags = sharedTags.filter(tag => !excludedConflictTags.includes(tag));
  return conflictTags.length > 0;
}

function hasConflictAmongAllGivenFoods(foods) {
  for (let i = 0; i < foods.length; i++) {
    for (let j = i + 1; j < foods.length; j++) {
      if (hasTagConflictFromNames(foods[i].name, foods[j].name)) {
        return true;
      }
    }
  }
  return false;
}



function normalize(text) {
  return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9çğıöşü]/gi, "");
}

function getTagsForFood(food) {
  if (!food) return [];
  const nameTags = food.name.toLowerCase().split(/[^a-zçğıöşü]+/).filter(Boolean);
  const tags = food.tags || [];
  return [...new Set([...nameTags, ...tags])];
}

function hasTagConflict(food1, food2, excludedTags = ["keto", "lowcarb", "zeytinyağı"]) {
  const tags1 = getTagsForFood(food1);
  const tags2 = getTagsForFood(food2);
  const common = tags1.filter(tag => tags2.includes(tag));
  return common.some(tag => !excludedTags.includes(tag));
}

function isCompatible(food1, food2) {
  const comp1 = food1.compatibilityTags || [];
  const comp2 = food2.compatibilityTags || [];
  return comp1.some(tag => comp2.includes(tag));
}

function isCompatibleWithMeal(existingFoods, newFood) {
  for (const existing of existingFoods) {
    if (hasTagConflict(existing, newFood)) return false;
  }
  return true;
}

function compatibilityScore(newFood, existingFoods) {
  let score = 0;
  for (const existing of existingFoods) {
    if (isCompatible(newFood, existing)) score += 1;
  }
  return score;
}

function selectMealCandidates(candidates, existingMealFoods) {
  const filtered = candidates.filter(food => isCompatibleWithMeal(existingMealFoods, food));
  return filtered.sort((a, b) => compatibilityScore(b, existingMealFoods) - compatibilityScore(a, existingMealFoods));
}





function normalize(text) {
  return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9çğıöşü]/gi, "");
}

function getTagsForFood(food) {
  if (!food) return [];
  const nameTags = food.name.toLowerCase().split(/[^a-zçğıöşü]+/).filter(Boolean);
  const tags = food.tags || [];
  return [...new Set([...nameTags, ...tags])];
}

function hasTagConflict(food1, food2, excludedTags = ["keto", "lowcarb", "zeytinyağı"]) {
  const tags1 = getTagsForFood(food1);
  const tags2 = getTagsForFood(food2);
  const common = tags1.filter(tag => tags2.includes(tag));
  return common.some(tag => !excludedTags.includes(tag));
}

function isCompatible(food1, food2) {
  const comp1 = food1.compatibilityTags || [];
  const comp2 = food2.compatibilityTags || [];
  return comp1.some(tag => comp2.includes(tag));
}

function isCompatibleWithMeal(existingFoods, newFood) {
  for (const existing of existingFoods) {
    if (hasTagConflict(existing, newFood)) return false;
  }
  return true;
}

function compatibilityScore(newFood, existingFoods) {
  let score = 0;
  for (const existing of existingFoods) {
    if (isCompatible(newFood, existing)) score += 1;
  }
  return score;
}

function selectMealCandidates(candidates, existingMealFoods) {
  const filtered = candidates.filter(food => isCompatibleWithMeal(existingMealFoods, food));
  return filtered.sort((a, b) => compatibilityScore(b, existingMealFoods) - compatibilityScore(a, existingMealFoods));
}


</script>
</body>
</html>
